{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This is the documentation for the PopGen.jl package. If you're here, you're likely interested in doing some kind of population genetics analyses. Please read through the docs and try the functions out with the test data to get a feel for what PopGen.jl can do. About PopGen.jl is an attempt to shift population genetics analyses away from the patchwork of available pop-gen packages present in the R and Python languages, and combine it with the speed, power, fun(?), and community of the Julia language. We hope to implement common analyses (heterozygosity, kinship, FST, Tajima's D, etc.) in sane , user friendly ways, with syntax used within the package being consistent with the rest of the Julia ecosystem. Goal To be a comprehensive package for population genetics analyses and visualization that's fast and user friendly. This project is developed with a particular mantra: Sanity, Sensibility, Accessibility . Sanity Functions are written in a way such that their use is sane and natural. When possible (or sensible), we use full words for input variables or other components of input/output. The first argument for all functions is the input data without keywords. Always. If a function has a very obvious name, then it likely it won't need keyword arguments, such as remove_loci! , where it would be silly to have a keyword loci= since the name is explicit about what it does and the first argument is always the input data. Sensibility Functions need to be sensible, both in what they do and how they do it. This means they should include only the most relevant arguments, and the most sensible defaults. It also means the outputs need to be flexible enough to use with other Julia packages, such as Query.jl , or Plots . Accessibility Documentation is everything! We recognize Julia is a comparatively young language, and we know which languages and packages other population geneticists are using for their work. We want you to be comfortable using PopGen.jl, and that means investing a lot of time into writing thorough documentation intended for users (vs developers). We also recognize that you (the reader) might not be very familiar with Julia, or other non-R languages (which is ok!), so we've written a section on clarifying some Julia concepts/conventions that will make reading this documentation a whole lot clearer. It is by no means a replacement for sitting down and learning the Julia language a bit ( here is a great online book on that ), but it should hopefully reduce the barrier of entry somewhat. Why Julia (and not Python or R)? Speed and syntax The speed is comparable to C when coded correctly. Also, has Python-like syntax with optional tabs. We are also fans of 1-indexing, but that's more of a perk. Not convinced? Check out our comparison benchmarks . A modern language for modern problems Julia has native support for: parallelization, distributed computing, GPU processing, and pipes! It also has robust machine learning packages (maybe for future work). Community & contribution Julia's internals solve what's know as the \"two language problem\". That is, languages that are easy to write in (e.g. Python, R, Ruby) are slow compared to languages that are more difficult to write in, which are fast (e.g. C, C++, Java, Fortran). For languages that are easier to write in, many of the commonly used packages and functions in those languages are written in another, faster language under the hood for performance reasons. On the whole, that's not really a problem for end-users, because things work and they are easy to use. But , it does become a problem when you want to investigate the code and implementation of a function. This means that, even as an R power-user, you are kind of helpless to investigate the implementation of something you are using in R if it's actually written in C++ under the hood. In a sense, it makes the publications of those methods less reproducible, because the users of it may be familiar with the language it's deployed in (like R), but not the language it's written in, (like C++). What if there are bugs?! What if the code implementation doesn't match the formulations in the publication?! Yikes! So, if we write everything in Julia, and you use everything in Julia, users can themselves diagnose these things if they so choose. Yes, that means that we might be getting more Issues opened up, but a bug found is a lot better than a bug overlooked! Like most Julia packages, PopGen.jl is written entirely in Julia, meaning the community using it need not learn another language if they wanted to contribute! Have you written a clever Julia function to calculate SAMOVA from a PopObj ? Send us a pull request (please!)! Or join the Slack! Package manager Which, let's be honest, is such a delight to use. Installing PopGen.jl should be simple, consistent, and effortless thanks to the brilliant built-in package manager in Julia. Authors Pavel Dimens, PhD Student @ U. Southern Mississippi Jason Selwyn, PhD Candidate @ Texas A&M University - Corpus Christi","title":"Home"},{"location":"#about","text":"PopGen.jl is an attempt to shift population genetics analyses away from the patchwork of available pop-gen packages present in the R and Python languages, and combine it with the speed, power, fun(?), and community of the Julia language. We hope to implement common analyses (heterozygosity, kinship, FST, Tajima's D, etc.) in sane , user friendly ways, with syntax used within the package being consistent with the rest of the Julia ecosystem.","title":"About"},{"location":"#goal","text":"To be a comprehensive package for population genetics analyses and visualization that's fast and user friendly. This project is developed with a particular mantra: Sanity, Sensibility, Accessibility . Sanity Functions are written in a way such that their use is sane and natural. When possible (or sensible), we use full words for input variables or other components of input/output. The first argument for all functions is the input data without keywords. Always. If a function has a very obvious name, then it likely it won't need keyword arguments, such as remove_loci! , where it would be silly to have a keyword loci= since the name is explicit about what it does and the first argument is always the input data. Sensibility Functions need to be sensible, both in what they do and how they do it. This means they should include only the most relevant arguments, and the most sensible defaults. It also means the outputs need to be flexible enough to use with other Julia packages, such as Query.jl , or Plots . Accessibility Documentation is everything! We recognize Julia is a comparatively young language, and we know which languages and packages other population geneticists are using for their work. We want you to be comfortable using PopGen.jl, and that means investing a lot of time into writing thorough documentation intended for users (vs developers). We also recognize that you (the reader) might not be very familiar with Julia, or other non-R languages (which is ok!), so we've written a section on clarifying some Julia concepts/conventions that will make reading this documentation a whole lot clearer. It is by no means a replacement for sitting down and learning the Julia language a bit ( here is a great online book on that ), but it should hopefully reduce the barrier of entry somewhat.","title":"Goal"},{"location":"#why-julia-and-not-python-or-r","text":"","title":"Why Julia (and not Python or R)?"},{"location":"#speed-and-syntax","text":"The speed is comparable to C when coded correctly. Also, has Python-like syntax with optional tabs. We are also fans of 1-indexing, but that's more of a perk. Not convinced? Check out our comparison benchmarks .","title":"Speed and syntax"},{"location":"#a-modern-language-for-modern-problems","text":"Julia has native support for: parallelization, distributed computing, GPU processing, and pipes! It also has robust machine learning packages (maybe for future work).","title":"A modern language for modern problems"},{"location":"#community-contribution","text":"Julia's internals solve what's know as the \"two language problem\". That is, languages that are easy to write in (e.g. Python, R, Ruby) are slow compared to languages that are more difficult to write in, which are fast (e.g. C, C++, Java, Fortran). For languages that are easier to write in, many of the commonly used packages and functions in those languages are written in another, faster language under the hood for performance reasons. On the whole, that's not really a problem for end-users, because things work and they are easy to use. But , it does become a problem when you want to investigate the code and implementation of a function. This means that, even as an R power-user, you are kind of helpless to investigate the implementation of something you are using in R if it's actually written in C++ under the hood. In a sense, it makes the publications of those methods less reproducible, because the users of it may be familiar with the language it's deployed in (like R), but not the language it's written in, (like C++). What if there are bugs?! What if the code implementation doesn't match the formulations in the publication?! Yikes! So, if we write everything in Julia, and you use everything in Julia, users can themselves diagnose these things if they so choose. Yes, that means that we might be getting more Issues opened up, but a bug found is a lot better than a bug overlooked! Like most Julia packages, PopGen.jl is written entirely in Julia, meaning the community using it need not learn another language if they wanted to contribute! Have you written a clever Julia function to calculate SAMOVA from a PopObj ? Send us a pull request (please!)! Or join the Slack!","title":"Community &amp; contribution"},{"location":"#package-manager","text":"Which, let's be honest, is such a delight to use. Installing PopGen.jl should be simple, consistent, and effortless thanks to the brilliant built-in package manager in Julia.","title":"Package manager"},{"location":"#authors","text":"Pavel Dimens, PhD Student @ U. Southern Mississippi Jason Selwyn, PhD Candidate @ Texas A&M University - Corpus Christi","title":"Authors"},{"location":"PopObj_accessing/","text":"A little hands-on training will probably go a long way, so let's through some of the functions available in PopGen.jl with the included data. This tutorial will include both inputs and outputs so you can be confident what you're seeing in your Julia session is exactly what's supposed to happen. Sometimes the outputs can be a little lengthy, so they will be arranged in code \"tabs\", where the left-most tab is the input named after what it's accomplishing, and the right tab is the output of running the command. Loading in the data Let's keep things simple by loading in the nancycats data and calling it ncats load nancycats julia > ncats = nancycats () ; summary ( ncats ) output Object of type PopObj: Marker type: Microsatellite Ploidy: 2 Number of individuals: 237 Number of loci: 9 Longitude: none provided Latitude: none provided Population names and counts: 17\u00d72 DataFrame \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 P01 \u2502 10 \u2502 \u2502 2 \u2502 P02 \u2502 22 \u2502 \u2502 3 \u2502 P03 \u2502 12 \u2502 \u2502 4 \u2502 P04 \u2502 23 \u2502 \u2502 5 \u2502 P05 \u2502 15 \u2502 \u2502 6 \u2502 P06 \u2502 11 \u2502 \u2502 7 \u2502 P07 \u2502 14 \u2502 \u2502 8 \u2502 P08 \u2502 10 \u2502 \u2502 9 \u2502 P09 \u2502 9 \u2502 \u2502 10 \u2502 P10 \u2502 11 \u2502 \u2502 11 \u2502 P11 \u2502 20 \u2502 \u2502 12 \u2502 P12 \u2502 14 \u2502 \u2502 13 \u2502 P13 \u2502 13 \u2502 \u2502 14 \u2502 P14 \u2502 17 \u2502 \u2502 15 \u2502 P15 \u2502 11 \u2502 \u2502 16 \u2502 P16 \u2502 12 \u2502 \u2502 17 \u2502 P17 \u2502 13 \u2502 Now that we have nancycats loaded in, we can use standard Julia accessor conventions to view the elements within our PopObj. samples .samples To view the entire samples dataframe .samples julia > ncats . samples output 237 \u00d75 DataFrames . DataFrame \u2502 Row \u2502 name \u2502 population \u2502 ploidy \u2502 longitude \u2502 latitude \u2502 \u2502 \u2502 String \u2502 Categorical\u2026\u2370 \u2502 Int8 \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 N215 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 2 \u2502 N216 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 3 \u2502 N217 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 4 \u2502 N218 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 5 \u2502 N219 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 6 \u2502 N220 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 7 \u2502 N221 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 8 \u2502 N222 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 9 \u2502 N223 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 10 \u2502 N224 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 11 \u2502 N7 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 12 \u2502 N141 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 13 \u2502 N142 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 14 \u2502 N143 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 15 \u2502 N144 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 16 \u2502 N145 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 17 \u2502 N146 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 220 \u2502 N258 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 221 \u2502 N259 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 222 \u2502 N260 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 223 \u2502 N261 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 224 \u2502 N262 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 225 \u2502 N282 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 226 \u2502 N283 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 227 \u2502 N288 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 228 \u2502 N291 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 229 \u2502 N292 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 230 \u2502 N293 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 231 \u2502 N294 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 232 \u2502 N295 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 233 \u2502 N296 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 234 \u2502 N297 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 235 \u2502 N281 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 236 \u2502 N289 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 237 \u2502 N290 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 .name This will access the names of the individuals as they appeared in the data. .ind julia > ncats . samples . name output 237-element Array{String,1}: \"N215\" \"N216\" \"N217\" \"N218\" \"N219\" \"N220\" \"N221\" \"N222\" \"N223\" \"N224\" \"N7\" \"N141\" \"N142\" \"N143\" \"N144\" \"N145\" \"N146\" \"N147\" \"N148\" \"N149\" \u22ee \"N256\" \"N257\" \"N258\" \"N259\" \"N260\" \"N261\" \"N262\" \"N282\" \"N283\" \"N288\" \"N291\" \"N292\" \"N293\" \"N294\" \"N295\" \"N296\" \"N297\" \"N281\" \"N289\" \"N290\" .population This will access the names of the populations associated with each individual, in the same order as the individuals. .popid julia > ncats . population output 237-element Array{Union{Int64, String},1}: \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \u22ee \"16\" \"16\" \"16\" \"16\" \"16\" \"16\" \"16\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" These ID's aren't super informative. Later, we'll change them using the popid! command. .ploidy This shows you the ploidy of the data per individual. .ploidy julia > ncats . samples . ploidy output 237-element Array{Int8,1}: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \u22ee 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 .latitude This accesses the latitude information of the PopObj. If there is none, like in the nancycats data, it returns an empty array. .latitude julia > ncats . samples . latitude output 237-element Array{Any,1}: missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing \u22ee missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing .longitude This accesses the longitude information of the PopObj. Like before, if there is none, like in the nancycats data, it returns an array of missing values. .longitude julia > ncats . samples . longitude output 237-element Array{Any,1}: missing missing missing missing missing missing missing missing missing missing \u22ee missing missing missing missing missing missing missing missing missing actually seeing some location info The nancycats data has some weird coordinate system for information, so those data were omitted. If you want a proof of concept for .longitude and .latitude , load in gulfsharks and try it out. We'll use hcat (horizontal concatination) to horizontally bind the individual names, their latitude, and longitude. Later, you'll see that the locations command does this and a bit more. load gulfsharks julia > sharks = gulfsharks () ; # semicolon just supresses printing output julia > hcat ( sharks . samples . name , sharks . samples . latitude , sharks . samples . longitude ) output 212\u00d73 Array{Any,2}: \"cc_001\" 28.3062 -80.5993 \"cc_002\" 28.3079 -80.5995 \"cc_003\" 28.3023 -80.5996 \"cc_005\" 28.6123 -80.4225 \"cc_007\" 27.8666 -80.3578 \"cc_008\" 27.8666 -80.3579 \"cc_009\" 27.8682 -80.3482 \"cc_010\" 27.8711 -80.3482 \"cc_012\" 28.4815 -80.4303 \"cc_013\" 28.2421 -80.2494 \u22ee \"seg_021\" 29.9466 -86.0399 \"seg_023\" 29.9969 -85.6494 \"seg_024\" 29.6966 -87.4403 \"seg_025\" 30.064 -86.5374 \"seg_026\" 30.0696 -86.5376 \"seg_027\" 29.9065 -86.0905 \"seg_028\" 30.0532 -87.3661 \"seg_029\" 30.0522 -87.3662 \"seg_030\" 29.8234 -85.7143 \"seg_031\" 29.8234 -85.7143 loci .loci This will show you the entire loci dataframe .loci julia > ncats . loci output 237\u00d79 DataFrames.DataFrame. Omitted printing of 2 columns \u2502 Row \u2502 fca23 \u2502 fca37 \u2502 fca43 \u2502 fca45 \u2502 fca77 \u2502 fca78 \u2502 fca8 \u2502 \u2502 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 (136, 146) \u2502 (208, 208) \u2502 (139, 139) \u2502 (116, 120) \u2502 (156, 156) \u2502 (142, 148) \u2502 missing \u2502 \u2502 2 \u2502 (146, 146) \u2502 (208, 208) \u2502 (139, 145) \u2502 (120, 126) \u2502 (156, 156) \u2502 (142, 148) \u2502 missing \u2502 \u2502 3 \u2502 (136, 146) \u2502 (210, 210) \u2502 (141, 141) \u2502 (116, 116) \u2502 (152, 156) \u2502 (142, 142) \u2502 (135, 143) \u2502 \u2502 4 \u2502 (138, 138) \u2502 (208, 208) \u2502 (139, 141) \u2502 (116, 126) \u2502 (150, 150) \u2502 (142, 148) \u2502 (133, 135) \u2502 \u2502 5 \u2502 (140, 146) \u2502 (208, 208) \u2502 (141, 145) \u2502 (126, 126) \u2502 (152, 152) \u2502 (142, 148) \u2502 (133, 135) \u2502 \u2502 6 \u2502 (136, 146) \u2502 (208, 208) \u2502 (145, 149) \u2502 (120, 126) \u2502 (150, 156) \u2502 (148, 148) \u2502 (135, 143) \u2502 \u2502 7 \u2502 (136, 146) \u2502 (208, 208) \u2502 (139, 145) \u2502 (116, 126) \u2502 (152, 152) \u2502 (142, 148) \u2502 (135, 135) \u2502 \u2502 8 \u2502 (136, 146) \u2502 (208, 212) \u2502 (135, 149) \u2502 (120, 126) \u2502 (154, 158) \u2502 (142, 148) \u2502 (135, 143) \u2502 \u2502 9 \u2502 (136, 146) \u2502 (208, 212) \u2502 (139, 139) \u2502 (116, 126) \u2502 (150, 160) \u2502 (142, 142) \u2502 (137, 143) \u2502 \u2502 10 \u2502 (132, 132) \u2502 (208, 208) \u2502 (141, 145) \u2502 (120, 126) \u2502 (150, 156) \u2502 (148, 148) \u2502 (135, 135) \u2502 \u2502 11 \u2502 (130, 136) \u2502 (182, 182) \u2502 (137, 145) \u2502 (128, 128) \u2502 (152, 152) \u2502 (142, 150) \u2502 (137, 141) \u2502 \u2502 12 \u2502 (130, 136) \u2502 (182, 208) \u2502 (135, 145) \u2502 (126, 128) \u2502 (144, 150) \u2502 (140, 140) \u2502 (129, 133) \u2502 \u2502 13 \u2502 (130, 130) \u2502 (208, 208) \u2502 (135, 145) \u2502 (128, 130) \u2502 (152, 156) \u2502 (142, 142) \u2502 (129, 133) \u2502 \u2502 14 \u2502 (130, 136) \u2502 (182, 206) \u2502 (135, 135) \u2502 (128, 130) \u2502 (156, 156) \u2502 (142, 142) \u2502 (133, 133) \u2502 \u2502 15 \u2502 (136, 136) \u2502 (208, 208) \u2502 (137, 137) \u2502 (126, 130) \u2502 (152, 152) \u2502 (140, 142) \u2502 (131, 135) \u2502 \u2502 16 \u2502 (136, 146) \u2502 (182, 192) \u2502 (135, 135) \u2502 (128, 130) \u2502 (144, 144) \u2502 (142, 142) \u2502 (129, 135) \u2502 \u2502 17 \u2502 (130, 144) \u2502 (182, 192) \u2502 (133, 133) \u2502 (126, 126) \u2502 (144, 144) \u2502 (140, 140) \u2502 (129, 133) \u2502 \u22ee \u2502 220 \u2502 (136, 140) \u2502 (208, 208) \u2502 (139, 145) \u2502 (122, 126) \u2502 (144, 152) \u2502 (142, 150) \u2502 (137, 139) \u2502 \u2502 221 \u2502 (136, 140) \u2502 (206, 208) \u2502 (145, 149) \u2502 (126, 126) \u2502 (152, 152) \u2502 (142, 142) \u2502 (137, 143) \u2502 \u2502 222 \u2502 (136, 136) \u2502 (210, 210) \u2502 (145, 149) \u2502 (122, 126) \u2502 (152, 152) \u2502 (150, 150) \u2502 (135, 139) \u2502 \u2502 223 \u2502 (136, 136) \u2502 (208, 208) \u2502 (145, 145) \u2502 (122, 126) \u2502 (152, 156) \u2502 (142, 142) \u2502 (139, 143) \u2502 \u2502 224 \u2502 (136, 140) \u2502 (208, 208) \u2502 (149, 149) \u2502 (120, 126) \u2502 (152, 152) \u2502 (142, 150) \u2502 (135, 139) \u2502 \u2502 225 \u2502 (136, 138) \u2502 (208, 208) \u2502 (135, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 150) \u2502 (133, 135) \u2502 \u2502 226 \u2502 (136, 136) \u2502 (182, 182) \u2502 (135, 139) \u2502 missing \u2502 (146, 156) \u2502 (142, 142) \u2502 (133, 135) \u2502 \u2502 227 \u2502 (136, 136) \u2502 (182, 208) \u2502 (135, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 150) \u2502 (133, 141) \u2502 \u2502 228 \u2502 (130, 146) \u2502 (208, 208) \u2502 (141, 141) \u2502 missing \u2502 (148, 156) \u2502 (142, 150) \u2502 (133, 141) \u2502 \u2502 229 \u2502 (138, 138) \u2502 (208, 208) \u2502 (141, 145) \u2502 missing \u2502 (148, 156) \u2502 (142, 142) \u2502 (123, 133) \u2502 \u2502 230 \u2502 (138, 138) \u2502 (208, 208) \u2502 (139, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 142) \u2502 (123, 133) \u2502 \u2502 231 \u2502 (136, 146) \u2502 (208, 208) \u2502 (139, 139) \u2502 missing \u2502 (150, 150) \u2502 (142, 148) \u2502 (133, 141) \u2502 \u2502 232 \u2502 (130, 136) \u2502 (208, 208) \u2502 (139, 145) \u2502 missing \u2502 (152, 158) \u2502 (142, 142) \u2502 (133, 141) \u2502 \u2502 233 \u2502 (136, 146) \u2502 (208, 220) \u2502 (139, 145) \u2502 missing \u2502 (150, 158) \u2502 (142, 148) \u2502 (133, 141) \u2502 \u2502 234 \u2502 (130, 130) \u2502 (208, 208) \u2502 (135, 145) \u2502 missing \u2502 (148, 156) \u2502 (142, 142) \u2502 (133, 143) \u2502 \u2502 235 \u2502 (136, 144) \u2502 (208, 208) \u2502 (143, 143) \u2502 missing \u2502 (144, 150) \u2502 (142, 150) \u2502 (135, 141) \u2502 \u2502 236 \u2502 (130, 136) \u2502 (208, 208) \u2502 (135, 145) \u2502 missing \u2502 (150, 150) \u2502 (142, 142) \u2502 (137, 143) \u2502 \u2502 237 \u2502 (130, 146) \u2502 (208, 208) \u2502 (135, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 150) \u2502 (135, 141) \u2502 locus names This will access the names of the loci as they appeared in the data. .loci julia > names ( ncats . loci ) output 9-element Array{Symbol,1}: :fca23 :fca37 :fca43 :fca45 :fca77 :fca78 :fca8 :fca90 :fca96 You'll likely immediately notice the colons, which might not be what you expected, and that the type is Array{Symbol,1} . This is because names pulls the column names from the .loci dataframe of a PopObj , which are actually Symbol and not String . You can just as easily convert them to a string by broadcasting String over names using a dot . . This conversion is only for the output and won't change anything in the PopObj (nor does it need changing!) conversion julia > String . ( names ( ncats . loci )) output 9-element Array{String,1}: \"fca23\" \"fca37\" \"fca43\" \"fca45\" \"fca77\" \"fca78\" \"fca8\" \"fca90\" \"fca96\" view genotypes This is the core of the PopObj type. Each colum is an array of tuples that have the genotypes of each individual in the order with which they appear in samples . The convenience here is that each column of the dataframe is named for the locus, therefore you access genotypes with PopObj.loci.locusname access fca8 julia > ncats . loci . fca8 output 237-element Array{Any,1}: missing missing (135, 143) (135, 133) (135, 133) (135, 143) (135, 135) (135, 143) (143, 137) (135, 135) (137, 141) (133, 129) (133, 129) (133, 133) (135, 131) (135, 129) (133, 129) (135, 129) (135, 135) (135, 131) \u22ee (139, 139) (137, 139) (137, 139) (143, 137) (135, 139) (143, 139) (135, 139) (135, 133) (135, 133) (133, 141) (133, 141) (133, 123) (133, 123) (133, 141) (133, 141) (133, 141) (143, 133) (135, 141) (143, 137) (135, 141) access fca23 julia > ncats . loci . fca23 output 237-element Array{Any,1}: (136, 146) (146, 146) (136, 146) (138, 138) (140, 146) (136, 146) (136, 146) (136, 146) (136, 146) (132, 132) (130, 136) (130, 136) (130, 130) (130, 136) (136, 136) (136, 146) (130, 144) (138, 138) (136, 144) (130, 136) \u22ee (136, 136) (136, 140) (136, 140) (136, 136) (136, 136) (136, 140) (136, 138) (136, 136) (136, 136) (130, 146) (138, 138) (138, 138) (136, 146) (130, 136) (136, 146) (130, 130) (136, 144) (130, 136) (130, 146) Slices general You can likewise use slices to access parts of these data. If you're migrating from R or Python, it's the simple bracket accessor you're already familiar with, used to pull out a range of values. Julia just calls them slices. Let's look at a slice of .name . slice .name julia > ncats . samples . name [ 1 : 6 ] output 6-element Array{String,1}: \"N215\" \"N216\" \"N217\" \"N218\" \"N219\" \"N220\" Here's another example: slice .loci julia > names ( ncats . loci )[ 3 : end ] output 7-element Array{Symbol,1}: :fca43 :fca45 :fca77 :fca78 :fca8 :fca90 :fca96 :end All things start at 1, so there is no need for a special word for it. On the other hand, objects can have unknown lengths or varied lengths as you work with them. In Julia, use the word end in a slice range to indicate you want it to go to the end,, regardless of length or known size. One more example withh genotypes: slice genotypes julia > ncats . loci . fca8 [ 1 : 3 ] output 3-element Array{Any,1}: missing missing (135, 143) Operating on accessors These accessors follow the exact same format as the dot operator in Python, or the $ operator in R, meaning these objects can be assigned to new variables, you can operate on them, iterate over them, etc. Here's a simple example to display the unique population ID's in your PopObj unique julia > unique ( ncats . samples . population ) output 17-element Array{Union{Int64, String},1}: \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"10\" \"11\" \"12\" \"13\" \"14\" \"15\" \"16\" \"17\" Pipes Julia has native piping (much like BASH) which uses the syntax |> (pipe + greater-than). With a pipe, unique(ncats.samples.population) can also be rewritten as ncats.samples.population |> unique for the same result. It's often a matter of preference for which you consider more readable. Use the Pipe package for even more robust piping where you can specify which argument the pipe relates to! \ud83d\uded1\u274c What to avoid! \u274c\ud83d\uded1 Given the relationships of the ordered list of individuals ( .name ) and the order of genotypes in .loci , NEVER USE sort , sort! , or manually arrange/add/delete anything in either dataframes loci or samples !!! There are included functions remove_loci! and remove_inds! that do that kind of thing. That being said, you can rename individuals and their popid's without issue. Just no manual moving or deleting!","title":"Accessing parts of a PopObj"},{"location":"PopObj_accessing/#loading-in-the-data","text":"Let's keep things simple by loading in the nancycats data and calling it ncats load nancycats julia > ncats = nancycats () ; summary ( ncats ) output Object of type PopObj: Marker type: Microsatellite Ploidy: 2 Number of individuals: 237 Number of loci: 9 Longitude: none provided Latitude: none provided Population names and counts: 17\u00d72 DataFrame \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 P01 \u2502 10 \u2502 \u2502 2 \u2502 P02 \u2502 22 \u2502 \u2502 3 \u2502 P03 \u2502 12 \u2502 \u2502 4 \u2502 P04 \u2502 23 \u2502 \u2502 5 \u2502 P05 \u2502 15 \u2502 \u2502 6 \u2502 P06 \u2502 11 \u2502 \u2502 7 \u2502 P07 \u2502 14 \u2502 \u2502 8 \u2502 P08 \u2502 10 \u2502 \u2502 9 \u2502 P09 \u2502 9 \u2502 \u2502 10 \u2502 P10 \u2502 11 \u2502 \u2502 11 \u2502 P11 \u2502 20 \u2502 \u2502 12 \u2502 P12 \u2502 14 \u2502 \u2502 13 \u2502 P13 \u2502 13 \u2502 \u2502 14 \u2502 P14 \u2502 17 \u2502 \u2502 15 \u2502 P15 \u2502 11 \u2502 \u2502 16 \u2502 P16 \u2502 12 \u2502 \u2502 17 \u2502 P17 \u2502 13 \u2502 Now that we have nancycats loaded in, we can use standard Julia accessor conventions to view the elements within our PopObj.","title":"Loading in the data"},{"location":"PopObj_accessing/#samples","text":"","title":"samples"},{"location":"PopObj_accessing/#samples_1","text":"To view the entire samples dataframe .samples julia > ncats . samples output 237 \u00d75 DataFrames . DataFrame \u2502 Row \u2502 name \u2502 population \u2502 ploidy \u2502 longitude \u2502 latitude \u2502 \u2502 \u2502 String \u2502 Categorical\u2026\u2370 \u2502 Int8 \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 N215 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 2 \u2502 N216 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 3 \u2502 N217 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 4 \u2502 N218 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 5 \u2502 N219 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 6 \u2502 N220 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 7 \u2502 N221 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 8 \u2502 N222 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 9 \u2502 N223 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 10 \u2502 N224 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 11 \u2502 N7 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 12 \u2502 N141 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 13 \u2502 N142 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 14 \u2502 N143 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 15 \u2502 N144 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 16 \u2502 N145 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 17 \u2502 N146 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 220 \u2502 N258 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 221 \u2502 N259 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 222 \u2502 N260 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 223 \u2502 N261 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 224 \u2502 N262 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 225 \u2502 N282 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 226 \u2502 N283 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 227 \u2502 N288 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 228 \u2502 N291 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 229 \u2502 N292 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 230 \u2502 N293 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 231 \u2502 N294 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 232 \u2502 N295 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 233 \u2502 N296 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 234 \u2502 N297 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 235 \u2502 N281 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 236 \u2502 N289 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 237 \u2502 N290 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502","title":".samples"},{"location":"PopObj_accessing/#name","text":"This will access the names of the individuals as they appeared in the data. .ind julia > ncats . samples . name output 237-element Array{String,1}: \"N215\" \"N216\" \"N217\" \"N218\" \"N219\" \"N220\" \"N221\" \"N222\" \"N223\" \"N224\" \"N7\" \"N141\" \"N142\" \"N143\" \"N144\" \"N145\" \"N146\" \"N147\" \"N148\" \"N149\" \u22ee \"N256\" \"N257\" \"N258\" \"N259\" \"N260\" \"N261\" \"N262\" \"N282\" \"N283\" \"N288\" \"N291\" \"N292\" \"N293\" \"N294\" \"N295\" \"N296\" \"N297\" \"N281\" \"N289\" \"N290\"","title":".name"},{"location":"PopObj_accessing/#population","text":"This will access the names of the populations associated with each individual, in the same order as the individuals. .popid julia > ncats . population output 237-element Array{Union{Int64, String},1}: \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \u22ee \"16\" \"16\" \"16\" \"16\" \"16\" \"16\" \"16\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" These ID's aren't super informative. Later, we'll change them using the popid! command.","title":".population"},{"location":"PopObj_accessing/#ploidy","text":"This shows you the ploidy of the data per individual. .ploidy julia > ncats . samples . ploidy output 237-element Array{Int8,1}: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \u22ee 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2","title":".ploidy"},{"location":"PopObj_accessing/#latitude","text":"This accesses the latitude information of the PopObj. If there is none, like in the nancycats data, it returns an empty array. .latitude julia > ncats . samples . latitude output 237-element Array{Any,1}: missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing \u22ee missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing","title":".latitude"},{"location":"PopObj_accessing/#longitude","text":"This accesses the longitude information of the PopObj. Like before, if there is none, like in the nancycats data, it returns an array of missing values. .longitude julia > ncats . samples . longitude output 237-element Array{Any,1}: missing missing missing missing missing missing missing missing missing missing \u22ee missing missing missing missing missing missing missing missing missing actually seeing some location info The nancycats data has some weird coordinate system for information, so those data were omitted. If you want a proof of concept for .longitude and .latitude , load in gulfsharks and try it out. We'll use hcat (horizontal concatination) to horizontally bind the individual names, their latitude, and longitude. Later, you'll see that the locations command does this and a bit more. load gulfsharks julia > sharks = gulfsharks () ; # semicolon just supresses printing output julia > hcat ( sharks . samples . name , sharks . samples . latitude , sharks . samples . longitude ) output 212\u00d73 Array{Any,2}: \"cc_001\" 28.3062 -80.5993 \"cc_002\" 28.3079 -80.5995 \"cc_003\" 28.3023 -80.5996 \"cc_005\" 28.6123 -80.4225 \"cc_007\" 27.8666 -80.3578 \"cc_008\" 27.8666 -80.3579 \"cc_009\" 27.8682 -80.3482 \"cc_010\" 27.8711 -80.3482 \"cc_012\" 28.4815 -80.4303 \"cc_013\" 28.2421 -80.2494 \u22ee \"seg_021\" 29.9466 -86.0399 \"seg_023\" 29.9969 -85.6494 \"seg_024\" 29.6966 -87.4403 \"seg_025\" 30.064 -86.5374 \"seg_026\" 30.0696 -86.5376 \"seg_027\" 29.9065 -86.0905 \"seg_028\" 30.0532 -87.3661 \"seg_029\" 30.0522 -87.3662 \"seg_030\" 29.8234 -85.7143 \"seg_031\" 29.8234 -85.7143","title":".longitude"},{"location":"PopObj_accessing/#loci","text":"","title":"loci"},{"location":"PopObj_accessing/#loci_1","text":"This will show you the entire loci dataframe .loci julia > ncats . loci output 237\u00d79 DataFrames.DataFrame. Omitted printing of 2 columns \u2502 Row \u2502 fca23 \u2502 fca37 \u2502 fca43 \u2502 fca45 \u2502 fca77 \u2502 fca78 \u2502 fca8 \u2502 \u2502 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 (136, 146) \u2502 (208, 208) \u2502 (139, 139) \u2502 (116, 120) \u2502 (156, 156) \u2502 (142, 148) \u2502 missing \u2502 \u2502 2 \u2502 (146, 146) \u2502 (208, 208) \u2502 (139, 145) \u2502 (120, 126) \u2502 (156, 156) \u2502 (142, 148) \u2502 missing \u2502 \u2502 3 \u2502 (136, 146) \u2502 (210, 210) \u2502 (141, 141) \u2502 (116, 116) \u2502 (152, 156) \u2502 (142, 142) \u2502 (135, 143) \u2502 \u2502 4 \u2502 (138, 138) \u2502 (208, 208) \u2502 (139, 141) \u2502 (116, 126) \u2502 (150, 150) \u2502 (142, 148) \u2502 (133, 135) \u2502 \u2502 5 \u2502 (140, 146) \u2502 (208, 208) \u2502 (141, 145) \u2502 (126, 126) \u2502 (152, 152) \u2502 (142, 148) \u2502 (133, 135) \u2502 \u2502 6 \u2502 (136, 146) \u2502 (208, 208) \u2502 (145, 149) \u2502 (120, 126) \u2502 (150, 156) \u2502 (148, 148) \u2502 (135, 143) \u2502 \u2502 7 \u2502 (136, 146) \u2502 (208, 208) \u2502 (139, 145) \u2502 (116, 126) \u2502 (152, 152) \u2502 (142, 148) \u2502 (135, 135) \u2502 \u2502 8 \u2502 (136, 146) \u2502 (208, 212) \u2502 (135, 149) \u2502 (120, 126) \u2502 (154, 158) \u2502 (142, 148) \u2502 (135, 143) \u2502 \u2502 9 \u2502 (136, 146) \u2502 (208, 212) \u2502 (139, 139) \u2502 (116, 126) \u2502 (150, 160) \u2502 (142, 142) \u2502 (137, 143) \u2502 \u2502 10 \u2502 (132, 132) \u2502 (208, 208) \u2502 (141, 145) \u2502 (120, 126) \u2502 (150, 156) \u2502 (148, 148) \u2502 (135, 135) \u2502 \u2502 11 \u2502 (130, 136) \u2502 (182, 182) \u2502 (137, 145) \u2502 (128, 128) \u2502 (152, 152) \u2502 (142, 150) \u2502 (137, 141) \u2502 \u2502 12 \u2502 (130, 136) \u2502 (182, 208) \u2502 (135, 145) \u2502 (126, 128) \u2502 (144, 150) \u2502 (140, 140) \u2502 (129, 133) \u2502 \u2502 13 \u2502 (130, 130) \u2502 (208, 208) \u2502 (135, 145) \u2502 (128, 130) \u2502 (152, 156) \u2502 (142, 142) \u2502 (129, 133) \u2502 \u2502 14 \u2502 (130, 136) \u2502 (182, 206) \u2502 (135, 135) \u2502 (128, 130) \u2502 (156, 156) \u2502 (142, 142) \u2502 (133, 133) \u2502 \u2502 15 \u2502 (136, 136) \u2502 (208, 208) \u2502 (137, 137) \u2502 (126, 130) \u2502 (152, 152) \u2502 (140, 142) \u2502 (131, 135) \u2502 \u2502 16 \u2502 (136, 146) \u2502 (182, 192) \u2502 (135, 135) \u2502 (128, 130) \u2502 (144, 144) \u2502 (142, 142) \u2502 (129, 135) \u2502 \u2502 17 \u2502 (130, 144) \u2502 (182, 192) \u2502 (133, 133) \u2502 (126, 126) \u2502 (144, 144) \u2502 (140, 140) \u2502 (129, 133) \u2502 \u22ee \u2502 220 \u2502 (136, 140) \u2502 (208, 208) \u2502 (139, 145) \u2502 (122, 126) \u2502 (144, 152) \u2502 (142, 150) \u2502 (137, 139) \u2502 \u2502 221 \u2502 (136, 140) \u2502 (206, 208) \u2502 (145, 149) \u2502 (126, 126) \u2502 (152, 152) \u2502 (142, 142) \u2502 (137, 143) \u2502 \u2502 222 \u2502 (136, 136) \u2502 (210, 210) \u2502 (145, 149) \u2502 (122, 126) \u2502 (152, 152) \u2502 (150, 150) \u2502 (135, 139) \u2502 \u2502 223 \u2502 (136, 136) \u2502 (208, 208) \u2502 (145, 145) \u2502 (122, 126) \u2502 (152, 156) \u2502 (142, 142) \u2502 (139, 143) \u2502 \u2502 224 \u2502 (136, 140) \u2502 (208, 208) \u2502 (149, 149) \u2502 (120, 126) \u2502 (152, 152) \u2502 (142, 150) \u2502 (135, 139) \u2502 \u2502 225 \u2502 (136, 138) \u2502 (208, 208) \u2502 (135, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 150) \u2502 (133, 135) \u2502 \u2502 226 \u2502 (136, 136) \u2502 (182, 182) \u2502 (135, 139) \u2502 missing \u2502 (146, 156) \u2502 (142, 142) \u2502 (133, 135) \u2502 \u2502 227 \u2502 (136, 136) \u2502 (182, 208) \u2502 (135, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 150) \u2502 (133, 141) \u2502 \u2502 228 \u2502 (130, 146) \u2502 (208, 208) \u2502 (141, 141) \u2502 missing \u2502 (148, 156) \u2502 (142, 150) \u2502 (133, 141) \u2502 \u2502 229 \u2502 (138, 138) \u2502 (208, 208) \u2502 (141, 145) \u2502 missing \u2502 (148, 156) \u2502 (142, 142) \u2502 (123, 133) \u2502 \u2502 230 \u2502 (138, 138) \u2502 (208, 208) \u2502 (139, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 142) \u2502 (123, 133) \u2502 \u2502 231 \u2502 (136, 146) \u2502 (208, 208) \u2502 (139, 139) \u2502 missing \u2502 (150, 150) \u2502 (142, 148) \u2502 (133, 141) \u2502 \u2502 232 \u2502 (130, 136) \u2502 (208, 208) \u2502 (139, 145) \u2502 missing \u2502 (152, 158) \u2502 (142, 142) \u2502 (133, 141) \u2502 \u2502 233 \u2502 (136, 146) \u2502 (208, 220) \u2502 (139, 145) \u2502 missing \u2502 (150, 158) \u2502 (142, 148) \u2502 (133, 141) \u2502 \u2502 234 \u2502 (130, 130) \u2502 (208, 208) \u2502 (135, 145) \u2502 missing \u2502 (148, 156) \u2502 (142, 142) \u2502 (133, 143) \u2502 \u2502 235 \u2502 (136, 144) \u2502 (208, 208) \u2502 (143, 143) \u2502 missing \u2502 (144, 150) \u2502 (142, 150) \u2502 (135, 141) \u2502 \u2502 236 \u2502 (130, 136) \u2502 (208, 208) \u2502 (135, 145) \u2502 missing \u2502 (150, 150) \u2502 (142, 142) \u2502 (137, 143) \u2502 \u2502 237 \u2502 (130, 146) \u2502 (208, 208) \u2502 (135, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 150) \u2502 (135, 141) \u2502","title":".loci"},{"location":"PopObj_accessing/#locus-names","text":"This will access the names of the loci as they appeared in the data. .loci julia > names ( ncats . loci ) output 9-element Array{Symbol,1}: :fca23 :fca37 :fca43 :fca45 :fca77 :fca78 :fca8 :fca90 :fca96 You'll likely immediately notice the colons, which might not be what you expected, and that the type is Array{Symbol,1} . This is because names pulls the column names from the .loci dataframe of a PopObj , which are actually Symbol and not String . You can just as easily convert them to a string by broadcasting String over names using a dot . . This conversion is only for the output and won't change anything in the PopObj (nor does it need changing!) conversion julia > String . ( names ( ncats . loci )) output 9-element Array{String,1}: \"fca23\" \"fca37\" \"fca43\" \"fca45\" \"fca77\" \"fca78\" \"fca8\" \"fca90\" \"fca96\"","title":"locus names"},{"location":"PopObj_accessing/#view-genotypes","text":"This is the core of the PopObj type. Each colum is an array of tuples that have the genotypes of each individual in the order with which they appear in samples . The convenience here is that each column of the dataframe is named for the locus, therefore you access genotypes with PopObj.loci.locusname access fca8 julia > ncats . loci . fca8 output 237-element Array{Any,1}: missing missing (135, 143) (135, 133) (135, 133) (135, 143) (135, 135) (135, 143) (143, 137) (135, 135) (137, 141) (133, 129) (133, 129) (133, 133) (135, 131) (135, 129) (133, 129) (135, 129) (135, 135) (135, 131) \u22ee (139, 139) (137, 139) (137, 139) (143, 137) (135, 139) (143, 139) (135, 139) (135, 133) (135, 133) (133, 141) (133, 141) (133, 123) (133, 123) (133, 141) (133, 141) (133, 141) (143, 133) (135, 141) (143, 137) (135, 141) access fca23 julia > ncats . loci . fca23 output 237-element Array{Any,1}: (136, 146) (146, 146) (136, 146) (138, 138) (140, 146) (136, 146) (136, 146) (136, 146) (136, 146) (132, 132) (130, 136) (130, 136) (130, 130) (130, 136) (136, 136) (136, 146) (130, 144) (138, 138) (136, 144) (130, 136) \u22ee (136, 136) (136, 140) (136, 140) (136, 136) (136, 136) (136, 140) (136, 138) (136, 136) (136, 136) (130, 146) (138, 138) (138, 138) (136, 146) (130, 136) (136, 146) (130, 130) (136, 144) (130, 136) (130, 146)","title":"view genotypes"},{"location":"PopObj_accessing/#slices","text":"","title":"Slices"},{"location":"PopObj_accessing/#general","text":"You can likewise use slices to access parts of these data. If you're migrating from R or Python, it's the simple bracket accessor you're already familiar with, used to pull out a range of values. Julia just calls them slices. Let's look at a slice of .name . slice .name julia > ncats . samples . name [ 1 : 6 ] output 6-element Array{String,1}: \"N215\" \"N216\" \"N217\" \"N218\" \"N219\" \"N220\" Here's another example: slice .loci julia > names ( ncats . loci )[ 3 : end ] output 7-element Array{Symbol,1}: :fca43 :fca45 :fca77 :fca78 :fca8 :fca90 :fca96 :end All things start at 1, so there is no need for a special word for it. On the other hand, objects can have unknown lengths or varied lengths as you work with them. In Julia, use the word end in a slice range to indicate you want it to go to the end,, regardless of length or known size. One more example withh genotypes: slice genotypes julia > ncats . loci . fca8 [ 1 : 3 ] output 3-element Array{Any,1}: missing missing (135, 143)","title":"general"},{"location":"PopObj_accessing/#operating-on-accessors","text":"These accessors follow the exact same format as the dot operator in Python, or the $ operator in R, meaning these objects can be assigned to new variables, you can operate on them, iterate over them, etc. Here's a simple example to display the unique population ID's in your PopObj unique julia > unique ( ncats . samples . population ) output 17-element Array{Union{Int64, String},1}: \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"10\" \"11\" \"12\" \"13\" \"14\" \"15\" \"16\" \"17\" Pipes Julia has native piping (much like BASH) which uses the syntax |> (pipe + greater-than). With a pipe, unique(ncats.samples.population) can also be rewritten as ncats.samples.population |> unique for the same result. It's often a matter of preference for which you consider more readable. Use the Pipe package for even more robust piping where you can specify which argument the pipe relates to!","title":"Operating on accessors"},{"location":"PopObj_accessing/#what-to-avoid","text":"Given the relationships of the ordered list of individuals ( .name ) and the order of genotypes in .loci , NEVER USE sort , sort! , or manually arrange/add/delete anything in either dataframes loci or samples !!! There are included functions remove_loci! and remove_inds! that do that kind of thing. That being said, you can rename individuals and their popid's without issue. Just no manual moving or deleting!","title":"\ud83d\uded1\u274c What to avoid! \u274c\ud83d\uded1"},{"location":"commands/","text":"These are the included PopObj viewing and manipulating commands. Using standard Julia conventions, only commands ending with a bang ! are mutable, meaning they alter the input data. So, commands like populations will show you population ID's, whereas populations! will change them in your PopObj . The mutable commands here alter the data in your PopObj , but not the source data (i.e. the files used to create the PopObj ). Read over Accessing parts of a PopObj to become familiar with the components of a PopObj . To follow along like a tutorial, use the gulfsharks data. Load the data in if you haven't already: julia > using PopGen julia > sharks = gulfsharks () ; Individuals / Samples view individuals' names samples ( data :: PopObj ) View individual/sample names in a PopObj . This is equivalent to PopObj.samples.name indnames samples ( sharks ) output 212-element Array{String,1}: \"cc_001\" \"cc_002\" \"cc_003\" \"cc_005\" \"cc_007\" \"cc_008\" \"cc_009\" \"cc_010\" \"cc_012\" \"cc_013\" \u22ee \"seg_023\" \"seg_024\" \"seg_025\" \"seg_026\" \"seg_027\" \"seg_028\" \"seg_029\" \"seg_030\" \"seg_031\" remove individuals remove_samples! ( data :: PopObj , samp_id :: Union { String , Array { String , 1 }}) Removes selected individuals from a PopObj . Input can be a single sample, or an array of samples. Will output entire PopObj , so it's better to use a semicolon to suppress the output. Use summary or .name if you want to confirm that the samples were removed. This command will inform you if samples were not found in the data. Examples: single individual julia > remove_samples! ( sharks , \"cc_001\" ) ; julia > summary ( sharks ) single output Object of type PopObj Marker type: SNP Ploidy: 2 Number of individuals: 211 Number of loci: 2213 Longitude: present with 0 missing Latitude: present with 0 missing Population names and counts: 7\u00d72 DataFrame \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 20 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 South Carolina \u2502 28 \u2502 \u2502 4 \u2502 Florida Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502 multiple individuals julia > remove_samples! ( sharks , [ \"cc_001\" , \"cc_002\" , \"cc_003\" ]) ; julia > summary ( sharks ) multiple output Object of type PopObj Marker type: SNP Ploidy: 2 Number of individuals: 209 Number of loci: 2213 Longitude: present with 0 missing Latitude: present with 0 missing Population names and counts: 7\u00d72 DataFrame \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 18 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 South Carolina \u2502 28 \u2502 \u2502 4 \u2502 Florida Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502 sample not found! If removing a single sample and it is not found in the PopObj, an error will be returned. However, if removing multiple samples, you will receive a notice above the PopObj summary indicating which individuals were not found, while removing the ones that were. Population ID's view population names populations ( data :: PopObj ; listall :: Bool = false ) Just as you can view population ID's with .population , you can also view them with the populations command, which by default shows you a summary of the number of individuals in each population, much like you see when using summary . populations julia > populations ( sharks ) output \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 18 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 South Carolina \u2502 28 \u2502 \u2502 4 \u2502 Florida Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502 You can use the keyword listall=true to display each individual and their associated population as a DataFrame. You'll notice the DataFrame looks remarkably like the first two columns of the one from locations , and it sort of is. Unlike locations , this will not give you an error when location data is missing. listall=true julia > populations ( sharks , listall = true ) output \u2502 Row \u2502 name \u2502 population \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_005 \u2502 Cape Canaveral \u2502 \u2502 2 \u2502 cc_007 \u2502 Cape Canaveral \u2502 \u2502 3 \u2502 cc_008 \u2502 Cape Canaveral \u2502 \u2502 4 \u2502 cc_009 \u2502 Cape Canaveral \u2502 \u2502 5 \u2502 cc_010 \u2502 Cape Canaveral \u2502 \u2502 6 \u2502 cc_012 \u2502 Cape Canaveral \u2502 \u22ee \u2502 203 \u2502 seg_025 \u2502 Southeast Gulf \u2502 \u2502 204 \u2502 seg_026 \u2502 Southeast Gulf \u2502 \u2502 205 \u2502 seg_027 \u2502 Southeast Gulf \u2502 \u2502 206 \u2502 seg_028 \u2502 Southeast Gulf \u2502 \u2502 207 \u2502 seg_029 \u2502 Southeast Gulf \u2502 \u2502 208 \u2502 seg_030 \u2502 Southeast Gulf \u2502 \u2502 209 \u2502 seg_031 \u2502 Southeast Gulf \u2502 synonymous functions You can use the command population for the same functionality. We made the commands population and populations synonymous so you wouldn't have to memorize if the name was singular or plural-- it just works! This also applies to populations! and population! rename populations populations! ( data :: PopObj ; rename :: Dict , replace :: Tuple ) Use the rename = keyword to rename the population ID's of a PopObj (the .population ). Uses a Dict of [population_name] => replacement to rename. It returns population(::PopObj,listall=true) of your renamed PopObj. rename populations # create a dictionary of name conversions julia > new_popnames = Dict ( \"Cape Canaveral\" => \"Atlantic\" , \"Georgia\" => \"Atlantic\" , \"S Carolina\" => \"Atlantic\" , \"FL Keys\" => \"Gulf\" , \"Mideast Gulf\" => \"Gulf\" , \"Northeast Gulf\" => \"Gulf\" , \"Southeast Gulf\" => \"Gulf\" ) julia > populations! ( sharks , rename = new_popnames ) output \u2502 Row \u2502 name \u2502 population \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_005 \u2502 Atlantic \u2502 \u2502 2 \u2502 cc_007 \u2502 Atlantic \u2502 \u2502 3 \u2502 cc_008 \u2502 Atlantic \u2502 \u2502 4 \u2502 cc_009 \u2502 Atlantic \u2502 \u2502 5 \u2502 cc_010 \u2502 Atlantic \u2502 \u2502 6 \u2502 cc_012 \u2502 Atlantic \u2502 \u22ee \u2502 203 \u2502 seg_025 \u2502 Gulf \u2502 \u2502 204 \u2502 seg_026 \u2502 Gulf \u2502 \u2502 205 \u2502 seg_027 \u2502 Gulf \u2502 \u2502 206 \u2502 seg_028 \u2502 Gulf \u2502 \u2502 207 \u2502 seg_029 \u2502 Gulf \u2502 \u2502 208 \u2502 seg_030 \u2502 Gulf \u2502 \u2502 209 \u2502 seg_031 \u2502 Gulf \u2502 replace population names You may also use the replace keyword in populations! to outright replace all the population names or fill in new ones. This is particularly useful when importing from VCF format when population information is not provided. This method will completely replace the population names of a PopObj regardless of what they currently are. Internally, it will generate an vector of population names from a tuple of (counts, names) where counts is a vector of the number of samples per population and names is a vector of the names of the populations. You can also use a named tuple (counts = , names = ) if you prefer. Since we know our number of samples per population from earlier, we can create a vector of those counts as so: counts = [18, 30, 28, 65, 28, 20, 20] and we can also create the vector of the names in the order in which they appeared: popnames = [\"Cape Canaveral\", \"Georgia\", \"S Carolina\", \"FL Keys\", \"Mideast Gulf\", \"Northeast Gulf\", \"Southeast Gulf\"] And now we can combine them with populations! to restore the population names to how they were originally: replace populations julia > populations! ( sharks , replace = ( popnames , counts )) # Tuple julia > populations! ( sharks , replace = ( counts = counts , names = popnames )) # NamedTuple output \u2502 Row \u2502 name \u2502 population \u2502 \u2502 \u2502 String \u2502 String \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_005 \u2502 Cape Canaveral \u2502 \u2502 2 \u2502 cc_007 \u2502 Cape Canaveral \u2502 \u2502 3 \u2502 cc_008 \u2502 Cape Canaveral \u2502 \u2502 4 \u2502 cc_009 \u2502 Cape Canaveral \u2502 \u2502 5 \u2502 cc_010 \u2502 Cape Canaveral \u2502 \u2502 6 \u2502 cc_012 \u2502 Cape Canaveral \u2502 \u22ee \u2502 203 \u2502 seg_025 \u2502 Southeast Gulf \u2502 \u2502 204 \u2502 seg_026 \u2502 Southeast Gulf \u2502 \u2502 205 \u2502 seg_027 \u2502 Southeast Gulf \u2502 \u2502 206 \u2502 seg_028 \u2502 Southeast Gulf \u2502 \u2502 207 \u2502 seg_029 \u2502 Southeast Gulf \u2502 Display Specific Loci and/or Samples These are the \"public\" functions to retrieve sample genotype information in an easy-on-the-eyes format, whereas calculations in other parts of PopGen.jl use much more barebones functions under the hood suitable for high-throughput programming. get loci names loci(data::PopObj) Returns a vector of strings of the loci names in a PopObj example julia > loci ( sharks ) output 2213-element Array{String,1}: \"contig_35208\" \"contig_23109\" \"contig_4493\" \"contig_10742\" \"contig_14898\" \"contig_8483\" \"contig_8065\" \"contig_14708\" \"contig_2307\" \u22ee \"contig_24711\" \"contig_18959\" \"contig_43517\" \"contig_27356\" \"contig_475\" \"contig_19384\" \"contig_22368\" \"contig_2784\" view loci view_genotypes ( data :: PopObj ; samples = nothing , loci = nothing ) Default shows all genotypes for all individuals. Returns a DataFrame. all loci julia > view_genotypes ( sharks ) output 212\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 2) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 Add the argument loci= specify a single locus (string) or multiple loci (array of strings) to display single locus julia > view_genotypes ( sharks , loci = \"contig_10001\" ) single output 212\u00d73 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 multiple loci julia > view_genotypes ( sharks , loci = [ \"contig_10001\" , \"contig_10028\" ]) multiple output 212\u00d74 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10028 \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 view samples Add the argument samples= specify a single sample (string) or multiple samples (array of strings) to display single sample julia > view_genotypes ( sharks , samples = \"cc_001\" ) single output 1\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 name \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 multiple samples 2 \u00d72215 DataFrames . DataFrame . Omitted printing of 2209 columns \u2502 Row \u2502 name \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 \u2502 2 \u2502 seg_028 \u2502 7 \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 ( 1 , 2 ) \u2502 ( 2 , 2 ) \u2502 It also means that you can combine the keywords samples= and loci= to further specify your output: both keywords view_genotypes ( sharks , samples = [ \"cc_001\" , \"seg_028\" ], loci = \"contig_10013\" ) output 2\u00d73 DataFrames.DataFrame \u2502 Row \u2502 name \u2502 population \u2502 contig_10013 \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 \u2502 2 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 Remove Loci remove_loci! ( data :: PopObj , loci :: String ) remove_loci! ( data :: PopObj , loci :: Vector { String }) Removes selected loci from a PopObj . Input can be a single locus, or an array of loci. Examples: single locus julia > remove_loci! ( sharks , \"contig_35208\" ) ; summary ( sharks ) single output Object of type PopObj Marker type: SNP Ploidy: 2 Number of individuals: 209 Number of loci: 2212 Longitude: present with 0 missing Latitude: present with 0 missing Population names and counts: 7\u00d72 DataFrame \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 String \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 18 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 S Carolina \u2502 28 \u2502 \u2502 4 \u2502 FL Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502 multiple loci julia > remove_loci! ( sharks , [ \"contig_35208\" , \"contig_23109\" , \"contig_4493\" ]) ; summary ( sharks ) multiple output NOTICE: locus \"contig_35208\" not found Object of type PopObj Marker type: SNP Ploidy: 2 Number of individuals: 212 Number of loci: 2210 Longitude: present with 0 missing Latitude: present with 0 missing Population names and counts: 7\u00d72 DataFrame \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 21 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 South Carolina \u2502 28 \u2502 \u2502 4 \u2502 Florida Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502 locus not found! If removing a single locus and it is not found in the PopObj, an error will be returned. However, if removing multiple loci, you will receive a notice above the PopObj summary indicating which loci were not found, while removing the ones that were. If none of the loci specified were found, it will return an error. Missing Data view missing data missing ( data :: PopObj ) Used to show missingness information-- that is, loci missing allele information. This command outputs two DataFrames, the first being a count of number of missing loci per samples, the other being the number of times a locus is missing across samples. missing julia > missing ( sharks ) output by_ind = (212\u00d74 DataFrames.DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 name \u2502 population \u2502 missing \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 2 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 2 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 0 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 0 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 0 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502, by_loci = 2213\u00d72 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 missing \u2502 \u2502 \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0 \u2502 \u22ee \u2502 2206 \u2502 contig_24711 \u2502 0 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 6 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502) missing outputs a named tuple of dataframes, which means there are two options for assignment: single assignment The first DataFrame of the named tuple is named by_sample and the second named by_loci . If you assign a single variable to this tuple, it will inherit those names as accessors like so: single assignment julia > miss = missing ( sharks ) ; by_ind julia> miss.by_sample 212\u00d74 DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 name \u2502 population \u2502 missing \u2502 \u2502 \u2502 String \u2502 String \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u22ee \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502 by_loci julia> miss.by_loci 2213\u00d72 DataFrame \u2502 Row \u2502 locus \u2502 missing \u2502 \u2502 \u2502 String \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u22ee \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502 multiple assignment Python has this feature, however, if you're migrating from R, multiple assignment probably looks weird, or like flat-out sorcery. Whenever a function returns a tuple of values, like missing does, you can assign as many variables to it at once. missing julia > df1 , df2 = missing ( sharks ) ; df1 julia> df1 212\u00d74 DataFrames.DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 name \u2502 population \u2502 missing \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 2 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 2 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 0 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 0 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 0 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502 df2 julia> df2 2213\u00d72 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0 \u2502 \u22ee \u2502 2206 \u2502 contig_24711 \u2502 0 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 6 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502 a simple example If this still looks weird to you, here is a simple example to help wrap your mind around it: a , b , c , d = ( 1 , 2 , 3 ,[ 4 , 5 , 6 , 7 ]) where a = 1 b = 2 c = 3 d = [4, 5, 6, 7] embrace the convenience! plot missing data plot_missing ( data :: PopObj ; color = false ) Return an interactive plot of the number of missing loci in individuals of a PopObj , along with the number of missing individuals per locus. Use color = [color1, color2, ...] to set a custom color palette for the boxplots. Example: julia > plot_missing ( sharks ) saving interactive plots To save the interactive plots, you can use the savehtml function from the PlotlyJS.jl package: PlotlyJS . savehtml ( plot , \"filename.html\" ) If you don't specify a full path in the filename, it will save it in your current working directory. #example julia > using PlotlyJS ; julia> PlotlyJS.savehtml(plot_missing(sharks), \"/home/pdimens/missingness.html\") use a third argument :embed to make the plots fully viewable offline. The output files are much larger (relatively) because it embeds the Plotly javeascript into the file. For context, the gulfsharks plot file is ~3.5mb when using :embed Location Data view location data locations ( data :: PopObj ) View location data ( .longitude and .latitude ) in a PopObj If you want to do your own plotting, or just to look at the spatial data of your PopObj, this function is handy. It takes no additional arguments and outputs a DataFrame of individual names, population ID's, and their latitude/longitude information. locations julia > locations ( sharks ) output 212\u00d74 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 longitude \u2502 latitude \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 Union\u2026 \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 -80.5993 \u2502 28.3062 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 -80.5995 \u2502 28.3079 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 -80.5996 \u2502 28.3023 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 -80.4225 \u2502 28.6123 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 -80.3578 \u2502 27.8666 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 -80.3579 \u2502 27.8666 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 -80.3482 \u2502 27.8682 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 -87.4403 \u2502 29.6966 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 -86.5374 \u2502 30.064 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 -86.5376 \u2502 30.0696 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 -86.0905 \u2502 29.9065 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 -87.3661 \u2502 30.0532 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 -87.3662 \u2502 30.0522 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 -85.7143 \u2502 29.8234 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 -85.7143 \u2502 29.8234 \u2502 add location data Location data can be added by directly accessing the fields .longitude and .latitude in your PopObj , such as this example: julia > sharks . samples . longitude = rand ( 1 : 50 , 212 ) ; # creates 212 unique random numbers between 1 and 50 julia > sharks . samples . latitdue = rand ( 20 : 30 , 212 ) ; # creates 212 unique random numbers between 20 and 30 However, if your data is in decimal minutes rather than decimal degrees, use the locations! function to add it to the fields. This function will do a conversion from decimal minutes to decimal degrees for you. To import those data into Julia, you'll likely want to use the wonderful CSV.jl package first. decimal minutes data locations! ( data :: PopObj ; xloc :: Vector { String }, yloc :: Vector { String }) Adds location data (longitude, latitude) to PopObj . Takes decimal degrees or decimal minutes format. Must use minus-sign instead of cardinal directions (i.e. 14 32.11W is not vaild). Location data must be in order of individuals ( ind ). Replaces existing PopObj location data. Decimal Degrees : -11.431 Decimal Minutes : \"-11 43.11\" (must use space and double-quotes) If conversion is not necessary, can directly assign PopObj.longitude and PopObj.latitude as shown above. If you still wanted to use locations! but don't need a conversion, it still works: julia > long = a . longitude = rand ( 1 : 50 , 212 ) ; julia > lat = a . latitdue = rand ( 20 : 30 , 212 ) ; julia > locations! ( a , long , lat ) ; plot location data plot_locations ( data :: PopObj , region = \"world\" , projection = \"orthogonal\" ) You're encouraged to plot locations how you see fit. For convenience and speed, we provide this command to make a decent, albeit simple interactive plot (Plotly) and save some time. There is a sizeable list of available map projections and regions if you look this function up in the help?> REPL prompt. julia > plot_locations ( sharks )","title":"Manipulating a PopObj"},{"location":"commands/#individuals-samples","text":"","title":"Individuals / Samples"},{"location":"commands/#view-individuals-names","text":"samples ( data :: PopObj ) View individual/sample names in a PopObj . This is equivalent to PopObj.samples.name indnames samples ( sharks ) output 212-element Array{String,1}: \"cc_001\" \"cc_002\" \"cc_003\" \"cc_005\" \"cc_007\" \"cc_008\" \"cc_009\" \"cc_010\" \"cc_012\" \"cc_013\" \u22ee \"seg_023\" \"seg_024\" \"seg_025\" \"seg_026\" \"seg_027\" \"seg_028\" \"seg_029\" \"seg_030\" \"seg_031\"","title":"view individuals' names"},{"location":"commands/#remove-individuals","text":"remove_samples! ( data :: PopObj , samp_id :: Union { String , Array { String , 1 }}) Removes selected individuals from a PopObj . Input can be a single sample, or an array of samples. Will output entire PopObj , so it's better to use a semicolon to suppress the output. Use summary or .name if you want to confirm that the samples were removed. This command will inform you if samples were not found in the data. Examples: single individual julia > remove_samples! ( sharks , \"cc_001\" ) ; julia > summary ( sharks ) single output Object of type PopObj Marker type: SNP Ploidy: 2 Number of individuals: 211 Number of loci: 2213 Longitude: present with 0 missing Latitude: present with 0 missing Population names and counts: 7\u00d72 DataFrame \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 20 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 South Carolina \u2502 28 \u2502 \u2502 4 \u2502 Florida Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502 multiple individuals julia > remove_samples! ( sharks , [ \"cc_001\" , \"cc_002\" , \"cc_003\" ]) ; julia > summary ( sharks ) multiple output Object of type PopObj Marker type: SNP Ploidy: 2 Number of individuals: 209 Number of loci: 2213 Longitude: present with 0 missing Latitude: present with 0 missing Population names and counts: 7\u00d72 DataFrame \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 18 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 South Carolina \u2502 28 \u2502 \u2502 4 \u2502 Florida Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502 sample not found! If removing a single sample and it is not found in the PopObj, an error will be returned. However, if removing multiple samples, you will receive a notice above the PopObj summary indicating which individuals were not found, while removing the ones that were.","title":"remove individuals"},{"location":"commands/#population-ids","text":"","title":"Population ID's"},{"location":"commands/#view-population-names","text":"populations ( data :: PopObj ; listall :: Bool = false ) Just as you can view population ID's with .population , you can also view them with the populations command, which by default shows you a summary of the number of individuals in each population, much like you see when using summary . populations julia > populations ( sharks ) output \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 18 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 South Carolina \u2502 28 \u2502 \u2502 4 \u2502 Florida Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502 You can use the keyword listall=true to display each individual and their associated population as a DataFrame. You'll notice the DataFrame looks remarkably like the first two columns of the one from locations , and it sort of is. Unlike locations , this will not give you an error when location data is missing. listall=true julia > populations ( sharks , listall = true ) output \u2502 Row \u2502 name \u2502 population \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_005 \u2502 Cape Canaveral \u2502 \u2502 2 \u2502 cc_007 \u2502 Cape Canaveral \u2502 \u2502 3 \u2502 cc_008 \u2502 Cape Canaveral \u2502 \u2502 4 \u2502 cc_009 \u2502 Cape Canaveral \u2502 \u2502 5 \u2502 cc_010 \u2502 Cape Canaveral \u2502 \u2502 6 \u2502 cc_012 \u2502 Cape Canaveral \u2502 \u22ee \u2502 203 \u2502 seg_025 \u2502 Southeast Gulf \u2502 \u2502 204 \u2502 seg_026 \u2502 Southeast Gulf \u2502 \u2502 205 \u2502 seg_027 \u2502 Southeast Gulf \u2502 \u2502 206 \u2502 seg_028 \u2502 Southeast Gulf \u2502 \u2502 207 \u2502 seg_029 \u2502 Southeast Gulf \u2502 \u2502 208 \u2502 seg_030 \u2502 Southeast Gulf \u2502 \u2502 209 \u2502 seg_031 \u2502 Southeast Gulf \u2502 synonymous functions You can use the command population for the same functionality. We made the commands population and populations synonymous so you wouldn't have to memorize if the name was singular or plural-- it just works! This also applies to populations! and population!","title":"view population names"},{"location":"commands/#rename-populations","text":"populations! ( data :: PopObj ; rename :: Dict , replace :: Tuple ) Use the rename = keyword to rename the population ID's of a PopObj (the .population ). Uses a Dict of [population_name] => replacement to rename. It returns population(::PopObj,listall=true) of your renamed PopObj. rename populations # create a dictionary of name conversions julia > new_popnames = Dict ( \"Cape Canaveral\" => \"Atlantic\" , \"Georgia\" => \"Atlantic\" , \"S Carolina\" => \"Atlantic\" , \"FL Keys\" => \"Gulf\" , \"Mideast Gulf\" => \"Gulf\" , \"Northeast Gulf\" => \"Gulf\" , \"Southeast Gulf\" => \"Gulf\" ) julia > populations! ( sharks , rename = new_popnames ) output \u2502 Row \u2502 name \u2502 population \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_005 \u2502 Atlantic \u2502 \u2502 2 \u2502 cc_007 \u2502 Atlantic \u2502 \u2502 3 \u2502 cc_008 \u2502 Atlantic \u2502 \u2502 4 \u2502 cc_009 \u2502 Atlantic \u2502 \u2502 5 \u2502 cc_010 \u2502 Atlantic \u2502 \u2502 6 \u2502 cc_012 \u2502 Atlantic \u2502 \u22ee \u2502 203 \u2502 seg_025 \u2502 Gulf \u2502 \u2502 204 \u2502 seg_026 \u2502 Gulf \u2502 \u2502 205 \u2502 seg_027 \u2502 Gulf \u2502 \u2502 206 \u2502 seg_028 \u2502 Gulf \u2502 \u2502 207 \u2502 seg_029 \u2502 Gulf \u2502 \u2502 208 \u2502 seg_030 \u2502 Gulf \u2502 \u2502 209 \u2502 seg_031 \u2502 Gulf \u2502","title":"rename populations"},{"location":"commands/#replace-population-names","text":"You may also use the replace keyword in populations! to outright replace all the population names or fill in new ones. This is particularly useful when importing from VCF format when population information is not provided. This method will completely replace the population names of a PopObj regardless of what they currently are. Internally, it will generate an vector of population names from a tuple of (counts, names) where counts is a vector of the number of samples per population and names is a vector of the names of the populations. You can also use a named tuple (counts = , names = ) if you prefer. Since we know our number of samples per population from earlier, we can create a vector of those counts as so: counts = [18, 30, 28, 65, 28, 20, 20] and we can also create the vector of the names in the order in which they appeared: popnames = [\"Cape Canaveral\", \"Georgia\", \"S Carolina\", \"FL Keys\", \"Mideast Gulf\", \"Northeast Gulf\", \"Southeast Gulf\"] And now we can combine them with populations! to restore the population names to how they were originally: replace populations julia > populations! ( sharks , replace = ( popnames , counts )) # Tuple julia > populations! ( sharks , replace = ( counts = counts , names = popnames )) # NamedTuple output \u2502 Row \u2502 name \u2502 population \u2502 \u2502 \u2502 String \u2502 String \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_005 \u2502 Cape Canaveral \u2502 \u2502 2 \u2502 cc_007 \u2502 Cape Canaveral \u2502 \u2502 3 \u2502 cc_008 \u2502 Cape Canaveral \u2502 \u2502 4 \u2502 cc_009 \u2502 Cape Canaveral \u2502 \u2502 5 \u2502 cc_010 \u2502 Cape Canaveral \u2502 \u2502 6 \u2502 cc_012 \u2502 Cape Canaveral \u2502 \u22ee \u2502 203 \u2502 seg_025 \u2502 Southeast Gulf \u2502 \u2502 204 \u2502 seg_026 \u2502 Southeast Gulf \u2502 \u2502 205 \u2502 seg_027 \u2502 Southeast Gulf \u2502 \u2502 206 \u2502 seg_028 \u2502 Southeast Gulf \u2502 \u2502 207 \u2502 seg_029 \u2502 Southeast Gulf \u2502","title":"replace population names"},{"location":"commands/#display-specific-loci-andor-samples","text":"These are the \"public\" functions to retrieve sample genotype information in an easy-on-the-eyes format, whereas calculations in other parts of PopGen.jl use much more barebones functions under the hood suitable for high-throughput programming.","title":"Display Specific Loci and/or Samples"},{"location":"commands/#get-loci-names","text":"loci(data::PopObj) Returns a vector of strings of the loci names in a PopObj example julia > loci ( sharks ) output 2213-element Array{String,1}: \"contig_35208\" \"contig_23109\" \"contig_4493\" \"contig_10742\" \"contig_14898\" \"contig_8483\" \"contig_8065\" \"contig_14708\" \"contig_2307\" \u22ee \"contig_24711\" \"contig_18959\" \"contig_43517\" \"contig_27356\" \"contig_475\" \"contig_19384\" \"contig_22368\" \"contig_2784\"","title":"get loci names"},{"location":"commands/#view-loci","text":"view_genotypes ( data :: PopObj ; samples = nothing , loci = nothing ) Default shows all genotypes for all individuals. Returns a DataFrame. all loci julia > view_genotypes ( sharks ) output 212\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 2) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 Add the argument loci= specify a single locus (string) or multiple loci (array of strings) to display single locus julia > view_genotypes ( sharks , loci = \"contig_10001\" ) single output 212\u00d73 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 multiple loci julia > view_genotypes ( sharks , loci = [ \"contig_10001\" , \"contig_10028\" ]) multiple output 212\u00d74 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10028 \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502","title":"view loci"},{"location":"commands/#view-samples","text":"Add the argument samples= specify a single sample (string) or multiple samples (array of strings) to display single sample julia > view_genotypes ( sharks , samples = \"cc_001\" ) single output 1\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 name \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 multiple samples 2 \u00d72215 DataFrames . DataFrame . Omitted printing of 2209 columns \u2502 Row \u2502 name \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 \u2502 2 \u2502 seg_028 \u2502 7 \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 ( 1 , 2 ) \u2502 ( 2 , 2 ) \u2502 It also means that you can combine the keywords samples= and loci= to further specify your output: both keywords view_genotypes ( sharks , samples = [ \"cc_001\" , \"seg_028\" ], loci = \"contig_10013\" ) output 2\u00d73 DataFrames.DataFrame \u2502 Row \u2502 name \u2502 population \u2502 contig_10013 \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 \u2502 2 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502","title":"view samples"},{"location":"commands/#remove-loci","text":"remove_loci! ( data :: PopObj , loci :: String ) remove_loci! ( data :: PopObj , loci :: Vector { String }) Removes selected loci from a PopObj . Input can be a single locus, or an array of loci. Examples: single locus julia > remove_loci! ( sharks , \"contig_35208\" ) ; summary ( sharks ) single output Object of type PopObj Marker type: SNP Ploidy: 2 Number of individuals: 209 Number of loci: 2212 Longitude: present with 0 missing Latitude: present with 0 missing Population names and counts: 7\u00d72 DataFrame \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 String \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 18 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 S Carolina \u2502 28 \u2502 \u2502 4 \u2502 FL Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502 multiple loci julia > remove_loci! ( sharks , [ \"contig_35208\" , \"contig_23109\" , \"contig_4493\" ]) ; summary ( sharks ) multiple output NOTICE: locus \"contig_35208\" not found Object of type PopObj Marker type: SNP Ploidy: 2 Number of individuals: 212 Number of loci: 2210 Longitude: present with 0 missing Latitude: present with 0 missing Population names and counts: 7\u00d72 DataFrame \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 21 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 South Carolina \u2502 28 \u2502 \u2502 4 \u2502 Florida Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502 locus not found! If removing a single locus and it is not found in the PopObj, an error will be returned. However, if removing multiple loci, you will receive a notice above the PopObj summary indicating which loci were not found, while removing the ones that were. If none of the loci specified were found, it will return an error.","title":"Remove Loci"},{"location":"commands/#missing-data","text":"","title":"Missing Data"},{"location":"commands/#view-missing-data","text":"missing ( data :: PopObj ) Used to show missingness information-- that is, loci missing allele information. This command outputs two DataFrames, the first being a count of number of missing loci per samples, the other being the number of times a locus is missing across samples. missing julia > missing ( sharks ) output by_ind = (212\u00d74 DataFrames.DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 name \u2502 population \u2502 missing \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 2 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 2 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 0 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 0 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 0 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502, by_loci = 2213\u00d72 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 missing \u2502 \u2502 \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0 \u2502 \u22ee \u2502 2206 \u2502 contig_24711 \u2502 0 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 6 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502) missing outputs a named tuple of dataframes, which means there are two options for assignment:","title":"view missing data"},{"location":"commands/#single-assignment","text":"The first DataFrame of the named tuple is named by_sample and the second named by_loci . If you assign a single variable to this tuple, it will inherit those names as accessors like so: single assignment julia > miss = missing ( sharks ) ; by_ind julia> miss.by_sample 212\u00d74 DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 name \u2502 population \u2502 missing \u2502 \u2502 \u2502 String \u2502 String \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u22ee \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502 by_loci julia> miss.by_loci 2213\u00d72 DataFrame \u2502 Row \u2502 locus \u2502 missing \u2502 \u2502 \u2502 String \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u22ee \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502","title":"single assignment"},{"location":"commands/#multiple-assignment","text":"Python has this feature, however, if you're migrating from R, multiple assignment probably looks weird, or like flat-out sorcery. Whenever a function returns a tuple of values, like missing does, you can assign as many variables to it at once. missing julia > df1 , df2 = missing ( sharks ) ; df1 julia> df1 212\u00d74 DataFrames.DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 name \u2502 population \u2502 missing \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 2 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 2 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 0 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 0 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 0 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502 df2 julia> df2 2213\u00d72 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0 \u2502 \u22ee \u2502 2206 \u2502 contig_24711 \u2502 0 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 6 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502 a simple example If this still looks weird to you, here is a simple example to help wrap your mind around it: a , b , c , d = ( 1 , 2 , 3 ,[ 4 , 5 , 6 , 7 ]) where a = 1 b = 2 c = 3 d = [4, 5, 6, 7] embrace the convenience!","title":"multiple assignment"},{"location":"commands/#plot-missing-data","text":"plot_missing ( data :: PopObj ; color = false ) Return an interactive plot of the number of missing loci in individuals of a PopObj , along with the number of missing individuals per locus. Use color = [color1, color2, ...] to set a custom color palette for the boxplots. Example: julia > plot_missing ( sharks ) saving interactive plots To save the interactive plots, you can use the savehtml function from the PlotlyJS.jl package: PlotlyJS . savehtml ( plot , \"filename.html\" ) If you don't specify a full path in the filename, it will save it in your current working directory. #example julia > using PlotlyJS ; julia> PlotlyJS.savehtml(plot_missing(sharks), \"/home/pdimens/missingness.html\") use a third argument :embed to make the plots fully viewable offline. The output files are much larger (relatively) because it embeds the Plotly javeascript into the file. For context, the gulfsharks plot file is ~3.5mb when using :embed","title":"plot missing data"},{"location":"commands/#location-data","text":"","title":"Location Data"},{"location":"commands/#view-location-data","text":"locations ( data :: PopObj ) View location data ( .longitude and .latitude ) in a PopObj If you want to do your own plotting, or just to look at the spatial data of your PopObj, this function is handy. It takes no additional arguments and outputs a DataFrame of individual names, population ID's, and their latitude/longitude information. locations julia > locations ( sharks ) output 212\u00d74 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 longitude \u2502 latitude \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 Union\u2026 \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 -80.5993 \u2502 28.3062 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 -80.5995 \u2502 28.3079 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 -80.5996 \u2502 28.3023 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 -80.4225 \u2502 28.6123 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 -80.3578 \u2502 27.8666 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 -80.3579 \u2502 27.8666 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 -80.3482 \u2502 27.8682 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 -87.4403 \u2502 29.6966 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 -86.5374 \u2502 30.064 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 -86.5376 \u2502 30.0696 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 -86.0905 \u2502 29.9065 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 -87.3661 \u2502 30.0532 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 -87.3662 \u2502 30.0522 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 -85.7143 \u2502 29.8234 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 -85.7143 \u2502 29.8234 \u2502","title":"view location data"},{"location":"commands/#add-location-data","text":"Location data can be added by directly accessing the fields .longitude and .latitude in your PopObj , such as this example: julia > sharks . samples . longitude = rand ( 1 : 50 , 212 ) ; # creates 212 unique random numbers between 1 and 50 julia > sharks . samples . latitdue = rand ( 20 : 30 , 212 ) ; # creates 212 unique random numbers between 20 and 30 However, if your data is in decimal minutes rather than decimal degrees, use the locations! function to add it to the fields. This function will do a conversion from decimal minutes to decimal degrees for you. To import those data into Julia, you'll likely want to use the wonderful CSV.jl package first.","title":"add location data"},{"location":"commands/#decimal-minutes-data","text":"locations! ( data :: PopObj ; xloc :: Vector { String }, yloc :: Vector { String }) Adds location data (longitude, latitude) to PopObj . Takes decimal degrees or decimal minutes format. Must use minus-sign instead of cardinal directions (i.e. 14 32.11W is not vaild). Location data must be in order of individuals ( ind ). Replaces existing PopObj location data. Decimal Degrees : -11.431 Decimal Minutes : \"-11 43.11\" (must use space and double-quotes) If conversion is not necessary, can directly assign PopObj.longitude and PopObj.latitude as shown above. If you still wanted to use locations! but don't need a conversion, it still works: julia > long = a . longitude = rand ( 1 : 50 , 212 ) ; julia > lat = a . latitdue = rand ( 20 : 30 , 212 ) ; julia > locations! ( a , long , lat ) ;","title":"decimal minutes data"},{"location":"commands/#plot-location-data","text":"plot_locations ( data :: PopObj , region = \"world\" , projection = \"orthogonal\" ) You're encouraged to plot locations how you see fit. For convenience and speed, we provide this command to make a decent, albeit simple interactive plot (Plotly) and save some time. There is a sizeable list of available map projections and regions if you look this function up in the help?> REPL prompt. julia > plot_locations ( sharks )","title":"plot location data"},{"location":"community/","text":"Join the Slack channel! Have questions, want to talk population genetics, or have ideas? Join the PopGen.jl Slack channel! \u2003 window.CommunityInviterAsyncInit = function () { \u2003 \u2003 CommunityInviter.init({ \u2003 \u2003 \u2003 app_url:'join', \u2003 \u2003 \u2003 team_id:'popgenjl' \u2003 \u2003}) \u2003 }; \u2003 (function(d, s, id){ \u2003 \u2003 var js, fjs = d.getElementsByTagName(s)[0]; \u2003 \u2003 if (d.getElementById(id)) {return;} \u2003 \u2003 js = d.createElement(s); js.id = id; \u2003 \u2003 js.src = \"https://communityinviter.com/js/communityinviter.js\"; \u2003 \u2003 fjs.parentNode.insertBefore(js, fjs); \u2003 }(document, 'script', 'Community_Inviter')); Contributing We absolutely welcome contributors to this package/project! Contributing can take the form of: Optimizing available code Pointing out bugs (and troubleshooting them if possible!) Testing your data against the available code Writing new functions or methods for existing functions Writing or editing the docs Spreading the word on social media Words of encouragement","title":"Community"},{"location":"community/#join-the-slack-channel","text":"Have questions, want to talk population genetics, or have ideas? Join the PopGen.jl Slack channel! \u2003 window.CommunityInviterAsyncInit = function () { \u2003 \u2003 CommunityInviter.init({ \u2003 \u2003 \u2003 app_url:'join', \u2003 \u2003 \u2003 team_id:'popgenjl' \u2003 \u2003}) \u2003 }; \u2003 (function(d, s, id){ \u2003 \u2003 var js, fjs = d.getElementsByTagName(s)[0]; \u2003 \u2003 if (d.getElementById(id)) {return;} \u2003 \u2003 js = d.createElement(s); js.id = id; \u2003 \u2003 js.src = \"https://communityinviter.com/js/communityinviter.js\"; \u2003 \u2003 fjs.parentNode.insertBefore(js, fjs); \u2003 }(document, 'script', 'Community_Inviter'));","title":"Join the Slack channel!"},{"location":"community/#contributing","text":"We absolutely welcome contributors to this package/project! Contributing can take the form of: Optimizing available code Pointing out bugs (and troubleshooting them if possible!) Testing your data against the available code Writing new functions or methods for existing functions Writing or editing the docs Spreading the word on social media Words of encouragement","title":"Contributing"},{"location":"comparison/","text":"Comparison to adegenet / pegas There's a reason we started investing so many hours and so many new grey hairs into writing PopGen.jl when there was an existing ecosystem in R to perform these same tasks. Like we explain in the home page of these docs, we want a platform that is: fast(er) written in a single language easy to use So, we'd like to prove that Julia and PopGen.jl actually achieves that by showing a few benchmarks comparing PopGen.jl to adegenet and pegas , which along with ape are arguably the most commonly used and robust population genetic packages available. It's worth mentioning that we ourselves use and have published with these packages, and are tremendously grateful for the work invested in those packages. We love those folks and have tremendous respect and envy for the work they continue to do! Here are links to adegenet , pegas , and ape . Benchmarks To make this a practical comparison, we're going to use the gulfsharks data because it is considerably larger (212 samples x 2213 loci) than nancycats (237 x 9) and a bit more of a \"stress test\". All benchmarks in R are performed using the microbenchmark package, and BenchmarkTools are used for Julia. loading R packages library ( adegenet ) library ( pegas ) library ( microbenchmark ) loading julia packages using BenchmarkTools , PopGen As a note, the reported benchmarks are being performed on a 64-bit Manjaro Linux system on a nothing-special Lenovo Thinkbook 14S with 8gigs of RAM and a 8 th gen Intel i5 mobile processor. Note: all of the Julia benchmarks, unless explicitly stated, are performed single-threaded (i.e. not parallel, distributed, or GPU). Loading in data Since gulfsharks is shamelessly provided in PopGen.jl, we simply invoke the gulfsharks() command in Julia. If you would like to try this yourself in R, find the gulfsharks.gen file in the package repository under /data/data/gulfsharks.gen . It will print out the input filename several times, which is omitted below for clarity. Julia julia > @btime x = gulfsharks () ; # hide the output 1.157 s ( 12697454 allocations : 673.02 MiB ) This R benchmark will take a few minutes. Consider making some tea while you wait. R > microbenchmark ( read.genepop ( file = \"/home/pdimens/gulfsharks.gen\" , ncode = 3L , quiet = TRUE )) Unit : seconds read.genepop ( file = \"/home/pdimens/gulfsharks.gen\" , ncode = 3L , quiet = FALSE ) min lq mean median uq max neval 5.670637 6.218719 6.745065 6.387936 7.019667 9.173005 100 Comparing averages, PopGen.jl clocks in at 1.157s versus adegenet's 6.745s , so ~5.8x faster. Julia | R PopObj vs genind size It was pretty tricky to come up with a sensible/efficient/convenient data structure for PopGen.jl, and the original attempt was a Julian variant to a genind , which itself is something known as an S4 class object . While the two-dataframes design might not seem like it took a lot of effort, we ultimately decided that the column-major style and available tools, combined with careful genotype Typing was a decent \"middle-ground\" of ease-of-use vs performance. We may one day change this when IndexedTables facilitates so many columns. Plus, we are suckers for consistent syntax, which genind 's don't have compared to standard R syntax (looking at you too, Tidyverse/ggplot!). Anyway , it's important to understand how much space your data will take up in memory (your RAM) when you load it in, especially since data's only getting bigger! Keep in mind that gulfsharks() in PopGen.jl also provides lat/long data, which should inflate the size of the object somewhat compared to the genind , which we won't add any location data to. Julia julia > Base . summarysize ( x ) 1612428 #bytes versus R > object.size ( gen ) 5331536 bytes What sorcery is this?! Well, it's all in the Typing of the genotypes. Each genotype for each locus is encoded as a Tuple of either Int8 (if SNPs) or Int16 (if msats) to absolutely minimize their footprint without further going into byte-level encoding (so you can still see human-readable alleles). An Int8 is a signed integer that occupies 8bits of memory, whereas an Int16 occupies 16bits (as compared to a standard Int64 ). The original file is 3.2mb , and our PopObj takes up ~ 1.6mb in memory (half as big as the source file!) versus the ~ 5.3mb of a genind , which is ~1.5x larger than the source file and ~3.3x larger than our PopObj . That's quite a big difference! Julia \u200b | R Chi-squared test for HWE This is a classic population genetics test and a relatively simple one. Julia julia > @btime hwe_test ( x , correction = \"bh\" ) ; 392.527 ms ( 1599668 allocations : 57.20 MiB ) The R benchmark will take a while again, so if you're following along, this would be a good time to reconnect with an old friend. R > microbenchmark ( hw.test ( gen , B = 0 )) Unit : seconds expr min lq mean median uq max neval hw.test ( gen , B = 0 ) 5.100298 5.564807 6.265948 5.878842 6.917006 8.815179 100 Comparing averages, PopGen.jl clocks in at ~ 400ms versus adegenet's 6.3s , so ~15x faster. Julia | R","title":"Benchmarks"},{"location":"comparison/#comparison-to-adegenet-pegas","text":"There's a reason we started investing so many hours and so many new grey hairs into writing PopGen.jl when there was an existing ecosystem in R to perform these same tasks. Like we explain in the home page of these docs, we want a platform that is: fast(er) written in a single language easy to use So, we'd like to prove that Julia and PopGen.jl actually achieves that by showing a few benchmarks comparing PopGen.jl to adegenet and pegas , which along with ape are arguably the most commonly used and robust population genetic packages available. It's worth mentioning that we ourselves use and have published with these packages, and are tremendously grateful for the work invested in those packages. We love those folks and have tremendous respect and envy for the work they continue to do! Here are links to adegenet , pegas , and ape .","title":"Comparison to adegenet / pegas"},{"location":"comparison/#benchmarks","text":"To make this a practical comparison, we're going to use the gulfsharks data because it is considerably larger (212 samples x 2213 loci) than nancycats (237 x 9) and a bit more of a \"stress test\". All benchmarks in R are performed using the microbenchmark package, and BenchmarkTools are used for Julia. loading R packages library ( adegenet ) library ( pegas ) library ( microbenchmark ) loading julia packages using BenchmarkTools , PopGen As a note, the reported benchmarks are being performed on a 64-bit Manjaro Linux system on a nothing-special Lenovo Thinkbook 14S with 8gigs of RAM and a 8 th gen Intel i5 mobile processor. Note: all of the Julia benchmarks, unless explicitly stated, are performed single-threaded (i.e. not parallel, distributed, or GPU).","title":"Benchmarks"},{"location":"comparison/#loading-in-data","text":"Since gulfsharks is shamelessly provided in PopGen.jl, we simply invoke the gulfsharks() command in Julia. If you would like to try this yourself in R, find the gulfsharks.gen file in the package repository under /data/data/gulfsharks.gen . It will print out the input filename several times, which is omitted below for clarity. Julia julia > @btime x = gulfsharks () ; # hide the output 1.157 s ( 12697454 allocations : 673.02 MiB ) This R benchmark will take a few minutes. Consider making some tea while you wait. R > microbenchmark ( read.genepop ( file = \"/home/pdimens/gulfsharks.gen\" , ncode = 3L , quiet = TRUE )) Unit : seconds read.genepop ( file = \"/home/pdimens/gulfsharks.gen\" , ncode = 3L , quiet = FALSE ) min lq mean median uq max neval 5.670637 6.218719 6.745065 6.387936 7.019667 9.173005 100 Comparing averages, PopGen.jl clocks in at 1.157s versus adegenet's 6.745s , so ~5.8x faster. Julia | R","title":"Loading in data"},{"location":"comparison/#popobj-vs-genind-size","text":"It was pretty tricky to come up with a sensible/efficient/convenient data structure for PopGen.jl, and the original attempt was a Julian variant to a genind , which itself is something known as an S4 class object . While the two-dataframes design might not seem like it took a lot of effort, we ultimately decided that the column-major style and available tools, combined with careful genotype Typing was a decent \"middle-ground\" of ease-of-use vs performance. We may one day change this when IndexedTables facilitates so many columns. Plus, we are suckers for consistent syntax, which genind 's don't have compared to standard R syntax (looking at you too, Tidyverse/ggplot!). Anyway , it's important to understand how much space your data will take up in memory (your RAM) when you load it in, especially since data's only getting bigger! Keep in mind that gulfsharks() in PopGen.jl also provides lat/long data, which should inflate the size of the object somewhat compared to the genind , which we won't add any location data to. Julia julia > Base . summarysize ( x ) 1612428 #bytes versus R > object.size ( gen ) 5331536 bytes What sorcery is this?! Well, it's all in the Typing of the genotypes. Each genotype for each locus is encoded as a Tuple of either Int8 (if SNPs) or Int16 (if msats) to absolutely minimize their footprint without further going into byte-level encoding (so you can still see human-readable alleles). An Int8 is a signed integer that occupies 8bits of memory, whereas an Int16 occupies 16bits (as compared to a standard Int64 ). The original file is 3.2mb , and our PopObj takes up ~ 1.6mb in memory (half as big as the source file!) versus the ~ 5.3mb of a genind , which is ~1.5x larger than the source file and ~3.3x larger than our PopObj . That's quite a big difference! Julia \u200b | R","title":"PopObj vs genind size"},{"location":"comparison/#chi-squared-test-for-hwe","text":"This is a classic population genetics test and a relatively simple one. Julia julia > @btime hwe_test ( x , correction = \"bh\" ) ; 392.527 ms ( 1599668 allocations : 57.20 MiB ) The R benchmark will take a while again, so if you're following along, this would be a good time to reconnect with an old friend. R > microbenchmark ( hw.test ( gen , B = 0 )) Unit : seconds expr min lq mean median uq max neval hw.test ( gen , B = 0 ) 5.100298 5.564807 6.265948 5.878842 6.917006 8.815179 100 Comparing averages, PopGen.jl clocks in at ~ 400ms versus adegenet's 6.3s , so ~15x faster. Julia | R","title":"Chi-squared test for HWE"},{"location":"delimited/","text":"Import a delimited file as a PopObj delimited ( infile ; delim , digits = 3 , marker = \"snp\" ) # Example julia > a = delimited ( \"/data/cali_poppy.csv\" , digits = 2 ) Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" Arguments infile :: String : path to the input file, in quotes Keyword Arguments delim :: Union { Char , String , Regex } : delimiter of the file, can be a string, character, or regex by default, it recognizes any of the basic three delimiters (comma, tab, space), so likely no input will be required digits :: Int64 : the number of digits used to denote an allele (default = 3) marker::String : \"snp\" (default) or \"msat\" for microsatellites Formatting Loci names must be first row Individuals names must be first value in row Population ID's must be second value in row Optional: longitude (x) values third value in row, latitude (y) fourth value in row example name,population,long,lat,Locus1,Locus2,Locus3 \\n sierra_01,mountain,11.11,-22.22,001001,002002,001001 \\n sierra_02,mountain,11.12,-22.21,001001,001001,001002 \\n snbarb_03,coast,0,0,001001,001001,001002 \\n snbarb_02,coast,11.14,-22.24,001001,001001,001001 \\n snbarb_03,coast,11.15,0,001002,001001,001001 \\n Fun fact You can also use the command csv() synonymously with delimited() .","title":"Delimited"},{"location":"delimited/#import-a-delimited-file-as-a-popobj","text":"delimited ( infile ; delim , digits = 3 , marker = \"snp\" ) # Example julia > a = delimited ( \"/data/cali_poppy.csv\" , digits = 2 ) Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\"","title":"Import a delimited file as a PopObj"},{"location":"delimited/#arguments","text":"infile :: String : path to the input file, in quotes","title":"Arguments"},{"location":"delimited/#keyword-arguments","text":"delim :: Union { Char , String , Regex } : delimiter of the file, can be a string, character, or regex by default, it recognizes any of the basic three delimiters (comma, tab, space), so likely no input will be required digits :: Int64 : the number of digits used to denote an allele (default = 3) marker::String : \"snp\" (default) or \"msat\" for microsatellites","title":"Keyword Arguments"},{"location":"delimited/#formatting","text":"Loci names must be first row Individuals names must be first value in row Population ID's must be second value in row Optional: longitude (x) values third value in row, latitude (y) fourth value in row","title":"Formatting"},{"location":"delimited/#example","text":"name,population,long,lat,Locus1,Locus2,Locus3 \\n sierra_01,mountain,11.11,-22.22,001001,002002,001001 \\n sierra_02,mountain,11.12,-22.21,001001,001001,001002 \\n snbarb_03,coast,0,0,001001,001001,001002 \\n snbarb_02,coast,11.14,-22.24,001001,001001,001001 \\n snbarb_03,coast,11.15,0,001002,001001,001001 \\n Fun fact You can also use the command csv() synonymously with delimited() .","title":"example"},{"location":"example_data/","text":"PopGen.jl provides two datasets as examples, each with their own easy-to-remember function for retrieving those data. nancycats We include the familiar nancycats microsatellite data, as featured in adegenet , for easy importing into PopGen.jl as a PopObj . To use those data, simply invoke nancycats() without any arguments. julia> ncats = nancycats() ; summary(ncats) Object of type PopObj Marker type: Microsatellite Ploidy: 2 Number of individuals: 237 Number of loci: 9 Longitude: absent Latitude: absent Population names and counts: \u2502 num \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 P01 \u2502 10 \u2502 \u2502 2 \u2502 P02 \u2502 22 \u2502 \u2502 3 \u2502 P03 \u2502 12 \u2502 \u2502 4 \u2502 P04 \u2502 23 \u2502 \u2502 5 \u2502 P05 \u2502 15 \u2502 \u2502 6 \u2502 P06 \u2502 11 \u2502 \u2502 7 \u2502 P07 \u2502 14 \u2502 \u2502 8 \u2502 P08 \u2502 10 \u2502 \u2502 9 \u2502 P09 \u2502 9 \u2502 \u2502 10 \u2502 P10 \u2502 11 \u2502 \u2502 11 \u2502 P11 \u2502 20 \u2502 \u2502 12 \u2502 P12 \u2502 14 \u2502 \u2502 13 \u2502 P13 \u2502 13 \u2502 \u2502 14 \u2502 P14 \u2502 17 \u2502 \u2502 15 \u2502 P15 \u2502 11 \u2502 \u2502 16 \u2502 P16 \u2502 12 \u2502 \u2502 17 \u2502 P17 \u2502 13 \u2502 The spatial coordinates provided for the dataset in adegenet are completely unfamiliar to us (and some geospatial folks we spoke to), so they have been omitted. If you recognize what coordinate system has 485.111 appear in Nancy, France, please let us know! gulfsharks We also include the SNP dataset used in Dimens et al. 2019 \" A genomic assessment of movement and gene flow around the South Florida vicariance zone in the migratory coastal blacknose shark, Carcharhinus acronotus \" since it was already on hand. Like nancycats , we provide a convenient function to load these data into PopGen.jl as a PopObj . To use those data, simply invoke gulfsharks() without any arguments. julia> sharks = gulfsharks() ; summary(sharks) Object of type PopObj Marker type: SNP Ploidy: 2 Number of individuals: 212 Number of loci: 2213 Longitude: present with 0 missing Latitude: present with 0 missing Population names and counts: \u2502 num \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 21 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 South Carolina \u2502 28 \u2502 \u2502 4 \u2502 Florida Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502","title":"Example Data"},{"location":"example_data/#nancycats","text":"We include the familiar nancycats microsatellite data, as featured in adegenet , for easy importing into PopGen.jl as a PopObj . To use those data, simply invoke nancycats() without any arguments. julia> ncats = nancycats() ; summary(ncats) Object of type PopObj Marker type: Microsatellite Ploidy: 2 Number of individuals: 237 Number of loci: 9 Longitude: absent Latitude: absent Population names and counts: \u2502 num \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 P01 \u2502 10 \u2502 \u2502 2 \u2502 P02 \u2502 22 \u2502 \u2502 3 \u2502 P03 \u2502 12 \u2502 \u2502 4 \u2502 P04 \u2502 23 \u2502 \u2502 5 \u2502 P05 \u2502 15 \u2502 \u2502 6 \u2502 P06 \u2502 11 \u2502 \u2502 7 \u2502 P07 \u2502 14 \u2502 \u2502 8 \u2502 P08 \u2502 10 \u2502 \u2502 9 \u2502 P09 \u2502 9 \u2502 \u2502 10 \u2502 P10 \u2502 11 \u2502 \u2502 11 \u2502 P11 \u2502 20 \u2502 \u2502 12 \u2502 P12 \u2502 14 \u2502 \u2502 13 \u2502 P13 \u2502 13 \u2502 \u2502 14 \u2502 P14 \u2502 17 \u2502 \u2502 15 \u2502 P15 \u2502 11 \u2502 \u2502 16 \u2502 P16 \u2502 12 \u2502 \u2502 17 \u2502 P17 \u2502 13 \u2502 The spatial coordinates provided for the dataset in adegenet are completely unfamiliar to us (and some geospatial folks we spoke to), so they have been omitted. If you recognize what coordinate system has 485.111 appear in Nancy, France, please let us know!","title":"nancycats"},{"location":"example_data/#gulfsharks","text":"We also include the SNP dataset used in Dimens et al. 2019 \" A genomic assessment of movement and gene flow around the South Florida vicariance zone in the migratory coastal blacknose shark, Carcharhinus acronotus \" since it was already on hand. Like nancycats , we provide a convenient function to load these data into PopGen.jl as a PopObj . To use those data, simply invoke gulfsharks() without any arguments. julia> sharks = gulfsharks() ; summary(sharks) Object of type PopObj Marker type: SNP Ploidy: 2 Number of individuals: 212 Number of loci: 2213 Longitude: present with 0 missing Latitude: present with 0 missing Population names and counts: \u2502 num \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 21 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 South Carolina \u2502 28 \u2502 \u2502 4 \u2502 Florida Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502","title":"gulfsharks"},{"location":"file_import/","text":"Reading in Data Currently, PopGen.jl provides three different file parsers with which to create a PopObj : Delimited files Genepop files Variant Call Format files Each of the filetypes have their own file importer denoted simply by the file type: delimited() , genepop() , bcf() , and vcf() . You're encouraged to use functions, but PopGen.jl also provides you with an all-encompassing wrapper for all three called read() . Since read() already exists in Base Julia, this function was not exported, and must be called formally as PopGen.read() to avoid any unintentional dispatch errors. PopGen.read() uses all the same keyword arguments as do the commands specific to their filetypes, therefore you should have a look at those commands (usually the defaults suffice). PopGen.read() infers the file type from the file extension, so for it to work properly your file must end with the extensions permitted below. If you're feeling particularly rebellious and your file does not conform to these extensions (such as a genepop file with a .gen.final.v2.seriously extension), then feel free to use the specific file importers, since they use the same exact syntax, there is zero difference in performance, and ignore file extensions. Ultimately, what crazy extensions you give your files is your business, and we love that about you. Specifying marker = \"msat\" and OverflowError For genepop and delimited files, you must specify if your markers are microsatellites ( marker = \"msat\" ) because the default is for snps. Why this matters: SNPs are Typed as 8-bit integers, whereas microsatellites are Typed as 16-bit integers. By the nature of those Types, Int8 cannot exceed the value 127, while Int16 is capped at 37767. Since SNP alleles will only ever be coded as values between 1 and 4 , we never have to worry about the genotype exceeding 127. Microsatellites can of course exceed 127, so we use the next-smallest Integer type for them, naively hoping no one will ever have a microsatellite allele exceeding 37767 repeats. If you have microsatellite data but don't specify marker = \"msat\" , you will receive an OverflowError as soon as the file reader tries to parse an allele greater than 127 as an Int8 . Supported File Types Delimited files Accepted extensions: .csv , .tsv , .txt files in which values are separated using a consistent delimiter, such as commas, spaces, or tabs first rows are column names each line represents a row Genepop Files Accepted extensions: .gen , .genepop first row is a comment and skipped then comes list of all loci, usually 1-per-line sometimes horizontally arranged and separated by commas populations separated by word \"POP\" sample names followed by comma and space genotypes separated by tabs genotypes represented as a combination of ploidy x 3-digits e.g. for genotype 001002 allele 1 = 001 allele 2 = 002 Variant Call Format Accepted extensions: .vcf , .bcf This format is much more abstract and can vary somewhat depending on which variant caller produced the file. If you're super duper interested in the specifications of BCF/VCF files, have a look at the official specification documentation .","title":"Reading in Data"},{"location":"file_import/#reading-in-data","text":"Currently, PopGen.jl provides three different file parsers with which to create a PopObj : Delimited files Genepop files Variant Call Format files Each of the filetypes have their own file importer denoted simply by the file type: delimited() , genepop() , bcf() , and vcf() . You're encouraged to use functions, but PopGen.jl also provides you with an all-encompassing wrapper for all three called read() . Since read() already exists in Base Julia, this function was not exported, and must be called formally as PopGen.read() to avoid any unintentional dispatch errors. PopGen.read() uses all the same keyword arguments as do the commands specific to their filetypes, therefore you should have a look at those commands (usually the defaults suffice). PopGen.read() infers the file type from the file extension, so for it to work properly your file must end with the extensions permitted below. If you're feeling particularly rebellious and your file does not conform to these extensions (such as a genepop file with a .gen.final.v2.seriously extension), then feel free to use the specific file importers, since they use the same exact syntax, there is zero difference in performance, and ignore file extensions. Ultimately, what crazy extensions you give your files is your business, and we love that about you.","title":"Reading in Data"},{"location":"file_import/#specifying-marker-msat-and-overflowerror","text":"For genepop and delimited files, you must specify if your markers are microsatellites ( marker = \"msat\" ) because the default is for snps. Why this matters: SNPs are Typed as 8-bit integers, whereas microsatellites are Typed as 16-bit integers. By the nature of those Types, Int8 cannot exceed the value 127, while Int16 is capped at 37767. Since SNP alleles will only ever be coded as values between 1 and 4 , we never have to worry about the genotype exceeding 127. Microsatellites can of course exceed 127, so we use the next-smallest Integer type for them, naively hoping no one will ever have a microsatellite allele exceeding 37767 repeats. If you have microsatellite data but don't specify marker = \"msat\" , you will receive an OverflowError as soon as the file reader tries to parse an allele greater than 127 as an Int8 .","title":"Specifying marker = \"msat\" and OverflowError"},{"location":"file_import/#supported-file-types","text":"","title":"Supported File Types"},{"location":"file_import/#delimited-files","text":"Accepted extensions: .csv , .tsv , .txt files in which values are separated using a consistent delimiter, such as commas, spaces, or tabs first rows are column names each line represents a row","title":"Delimited files"},{"location":"file_import/#genepop-files","text":"Accepted extensions: .gen , .genepop first row is a comment and skipped then comes list of all loci, usually 1-per-line sometimes horizontally arranged and separated by commas populations separated by word \"POP\" sample names followed by comma and space genotypes separated by tabs genotypes represented as a combination of ploidy x 3-digits e.g. for genotype 001002 allele 1 = 001 allele 2 = 002","title":"Genepop Files"},{"location":"file_import/#variant-call-format","text":"Accepted extensions: .vcf , .bcf This format is much more abstract and can vary somewhat depending on which variant caller produced the file. If you're super duper interested in the specifications of BCF/VCF files, have a look at the official specification documentation .","title":"Variant Call Format"},{"location":"genepop/","text":"Import a genepop file as a PopObj genepop ( infile ; digits = 3 , popsep = \"POP\" , marker = \"snp\" ) # Example julia > b = genepop ( \"/data/wasp_hive.gen\" , digits = 3 , popsep = \"POP\" ) Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" arguments infile::String : path to genepop file, in quotes keyword Arguments digits::Int64 : the number of digits used to denote an allele (default = 3) popsep::String : word that separates populations in infile (default: \"POP\") marker::String : \"snp\" (default) or \"msat\" for microsatellites By default, the file reader will assign numbers as population ID's in order of appearance in the genepop file. Use the populations! function to rename these with your own population ID's. Format Files must follow standard Genepop formatting: First line is a comment (and skipped) Loci are listed after first line as one-per-line without commas or in single comma-separated row A line with a particular keyword must delimit populations Must be the same word each time and not a unique population name File is tab or space delimited formatting examples loci stacked vertically Wasp populations in New York Locus1 Locus2 Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 loci stacked horizontally Wasp populations in New York Locus1,Locus2,Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120","title":"Genepop"},{"location":"genepop/#import-a-genepop-file-as-a-popobj","text":"genepop ( infile ; digits = 3 , popsep = \"POP\" , marker = \"snp\" ) # Example julia > b = genepop ( \"/data/wasp_hive.gen\" , digits = 3 , popsep = \"POP\" ) Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\"","title":"Import a genepop file as a PopObj"},{"location":"genepop/#arguments","text":"infile::String : path to genepop file, in quotes","title":"arguments"},{"location":"genepop/#keyword-arguments","text":"digits::Int64 : the number of digits used to denote an allele (default = 3) popsep::String : word that separates populations in infile (default: \"POP\") marker::String : \"snp\" (default) or \"msat\" for microsatellites By default, the file reader will assign numbers as population ID's in order of appearance in the genepop file. Use the populations! function to rename these with your own population ID's.","title":"keyword Arguments"},{"location":"genepop/#format","text":"Files must follow standard Genepop formatting: First line is a comment (and skipped) Loci are listed after first line as one-per-line without commas or in single comma-separated row A line with a particular keyword must delimit populations Must be the same word each time and not a unique population name File is tab or space delimited","title":"Format"},{"location":"genepop/#formatting-examples","text":"loci stacked vertically Wasp populations in New York Locus1 Locus2 Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 loci stacked horizontally Wasp populations in New York Locus1,Locus2,Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120","title":"formatting examples"},{"location":"hardyweinberg/","text":"Testing for Hardy-Weinberg Equilibrium (often abbreviated to \"HW\" or \"HWE\") is a fairly common practice in population genetics. In a two-allele system (alleles p and q ), the HWE equation is defined as p 2 + 2pq + q 2 = 1 . Testing for deviation from HWE is usually done with a Chi-Squared test, where one compares the observed genotype frequencies to the expected genotype frequencies given the observed allele frequencies at a locus. Test for Hardy-Weinberg equilibrium hwe_test ( x :: PopObj , by_pop :: Bool = false , correction :: String = \"none\" ) Calculate chi-squared test of HWE for each locus and returns observed and expected heterozygosity with chi-squared, degrees of freedom and p-values for each locus. Use by_pop = true to perform this separately for each population (default: by_pop = false) and return a NamedTuple with the names corresponding to the population names. Use correction = to specify a P-value correction method for multiple testing. arguments x : the input PopObj by_pop = : false (default) or true for hwe-by-population correction = : a string specifying a P-value adjustment type (default: \"none\") correction methods \"bonferroni\" : Bonferroni adjustment \"holm\" : Holm adjustment \"hochberg\" : Hochberg adjustment \"bh\" or \"b-h\" : Benjamini-Hochberg adjustment \"by\" or \"b-y\" : Benjamini-Yekutieli adjustment \"bl\" or \"b-l\" : Benjamini-Liu adjustment \"hommel\" : Hommel adjustment \"sidak\" : \u0160id\u00e1k adjustment \"forward stop\" or \"fs\" : Forward-Stop adjustment \"bc\" or \"b-c\" : Barber-Cande\u0300s adjustment For more information on multiple testing adjustments, see MultipleTesting.jl example example hwe_test ( gulfsharks (), correction = \"bh\" ) output 2213\u00d77 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64 \u2502 Float64 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.419811 \u2502 0.398051 \u2502 0.690981 \u2502 3.0 \u2502 0.875323 \u2502 0.948912 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.262136 \u2502 0.288434 \u2502 1.71251 \u2502 1.0 \u2502 0.19066 \u2502 0.295543 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.205742 \u2502 0.228532 \u2502 2.0785 \u2502 1.0 \u2502 0.149387 \u2502 0.234857 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0666667 \u2502 0.0644444 \u2502 0.249703 \u2502 1.0 \u2502 0.617284 \u2502 0.807471 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.240566 \u2502 0.21875 \u2502 2.10859 \u2502 1.0 \u2502 0.146475 \u2502 0.230442 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0188679 \u2502 0.0186899 \u2502 0.019229 \u2502 1.0 \u2502 0.889712 \u2502 0.948912 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0.0801887 \u2502 0.0769736 \u2502 0.369866 \u2502 1.0 \u2502 0.543077 \u2502 0.732045 \u2502 \u2502 8 \u2502 contig_14708 \u2502 0.0616114 \u2502 0.0597134 \u2502 0.213168 \u2502 1.0 \u2502 0.644295 \u2502 0.828219 \u2502 \u2502 9 \u2502 contig_2307 \u2502 0.0289855 \u2502 0.0285654 \u2502 0.0447664 \u2502 1.0 \u2502 0.832434 \u2502 0.938862 \u2502 \u2502 10 \u2502 contig_14564 \u2502 0.2 \u2502 0.209751 \u2502 0.453809 \u2502 1.0 \u2502 0.500532 \u2502 0.6894 \u2502 \u2502 11 \u2502 contig_15269 \u2502 0.15566 \u2502 0.146505 \u2502 1.51012 \u2502 3.0 \u2502 0.679938 \u2502 0.857489 \u2502 \u2502 12 \u2502 contig_24796 \u2502 0.161137 \u2502 0.201613 \u2502 8.50406 \u2502 1.0 \u2502 0.00354355 \u2502 0.00596524 \u2502 \u2502 13 \u2502 contig_14251 \u2502 0.490566 \u2502 0.49782 \u2502 0.0450074 \u2502 1.0 \u2502 0.83199 \u2502 0.938862 \u2502 \u2502 14 \u2502 contig_44797 \u2502 0.0240385 \u2502 0.0237495 \u2502 0.0307836 \u2502 1.0 \u2502 0.860724 \u2502 0.944468 \u2502 \u2502 15 \u2502 contig_43681 \u2502 0.42381 \u2502 0.472778 \u2502 2.25286 \u2502 1.0 \u2502 0.133368 \u2502 0.211628 \u2502 \u2502 16 \u2502 contig_24115 \u2502 0.0333333 \u2502 0.0327778 \u2502 0.0603275 \u2502 1.0 \u2502 0.805979 \u2502 0.931567 \u2502 \u2502 17 \u2502 contig_5456 \u2502 0.0471698 \u2502 0.0460573 \u2502 0.12369 \u2502 1.0 \u2502 0.725066 \u2502 0.892017 \u2502 \u2502 18 \u2502 contig_21698 \u2502 0.0758294 \u2502 0.0729543 \u2502 0.327695 \u2502 1.0 \u2502 0.567019 \u2502 0.758715 \u2502 \u22ee \u2502 2195 \u2502 contig_8479 \u2502 0.0235849 \u2502 0.0598856 \u2502 212.031 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2196 \u2502 contig_47462 \u2502 0.45283 \u2502 0.502803 \u2502 213.589 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2197 \u2502 contig_4095 \u2502 0.259434 \u2502 0.275398 \u2502 212.0 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2198 \u2502 contig_7239 \u2502 0.0660377 \u2502 0.0729352 \u2502 212.25 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2199 \u2502 contig_40507 \u2502 0.0330189 \u2502 0.0688746 \u2502 212.062 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2200 \u2502 contig_42145 \u2502 0.358491 \u2502 0.31754 \u2502 5.95351 \u2502 3.0 \u2502 0.113894 \u2502 0.182428 \u2502 \u2502 2201 \u2502 contig_1033 \u2502 0.363208 \u2502 0.352872 \u2502 0.181856 \u2502 1.0 \u2502 0.669783 \u2502 0.85219 \u2502 \u2502 2202 \u2502 contig_2798 \u2502 0.122642 \u2502 0.140219 \u2502 212.952 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2203 \u2502 contig_12991 \u2502 0.0518868 \u2502 0.112685 \u2502 212.161 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2204 \u2502 contig_22981 \u2502 0.188679 \u2502 0.200783 \u2502 0.770434 \u2502 1.0 \u2502 0.380083 \u2502 0.551307 \u2502 \u2502 2205 \u2502 contig_15342 \u2502 0.268868 \u2502 0.29084 \u2502 212.328 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2206 \u2502 contig_24711 \u2502 0.273585 \u2502 0.288136 \u2502 0.540694 \u2502 1.0 \u2502 0.462145 \u2502 0.645777 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0.466981 \u2502 0.437422 \u2502 0.968086 \u2502 1.0 \u2502 0.325158 \u2502 0.482394 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.103774 \u2502 0.150454 \u2502 212.675 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0660377 \u2502 0.0906016 \u2502 213.73 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.367925 \u2502 0.375 \u2502 0.0754717 \u2502 1.0 \u2502 0.78353 \u2502 0.926932 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0613208 \u2502 0.11264 \u2502 214.152 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.0896226 \u2502 0.11224 \u2502 212.481 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0283019 \u2502 0.0908241 \u2502 212.047 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 by_pop = true julia> hwe_test(gulfsharks(), by_pop = true, correction = \"bh\") (Cape Canaveral = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.333333 \u2502 0.427438 \u2502 1.01787 \u2502 1.0 \u2502 0.313025 \u2502 0.872143 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.263158 \u2502 0.228532 \u2502 0.43618 \u2502 1.0 \u2502 0.508972 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.142857 \u2502 0.209751 \u2502 2.13589 \u2502 1.0 \u2502 0.143886 \u2502 0.51061 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.0952381 \u2502 0.0907029 \u2502 0.0525 \u2502 1.0 \u2502 0.818769 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.52381 \u2502 0.427438 \u2502 1.06752 \u2502 1.0 \u2502 0.301507 \u2502 0.856472 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.0952381 \u2502 0.0907029 \u2502 0.0525 \u2502 1.0 \u2502 0.818769 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.047619 \u2502 0.0464853 \u2502 0.0124926 \u2502 1.0 \u2502 0.911006 \u2502 0.987085 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.285714 \u2502 0.30839 \u2502 0.113538 \u2502 1.0 \u2502 0.736152 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0952381 \u2502 0.176871 \u2502 21.0582 \u2502 3.0 \u2502 0.000102388 \u2502 0.000625326 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.047619 \u2502 0.0464853 \u2502 0.0124926 \u2502 1.0 \u2502 0.911006 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502, Georgia = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.4 \u2502 0.389467 \u2502 0.276208 \u2502 3.0 \u2502 0.964439 \u2502 1.0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.28125 \u2502 0.304688 \u2502 0.378698 \u2502 1.0 \u2502 0.538301 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.234375 \u2502 0.230347 \u2502 0.0195733 \u2502 1.0 \u2502 0.888735 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.046875 \u2502 0.0457764 \u2502 0.036864 \u2502 1.0 \u2502 0.847742 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.292308 \u2502 0.249586 \u2502 1.90447 \u2502 1.0 \u2502 0.167579 \u2502 0.57153 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0153846 \u2502 0.0152663 \u2502 0.00390602 \u2502 1.0 \u2502 0.950166 \u2502 0.996029 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.538462 \u2502 0.461657 \u2502 1.79908 \u2502 1.0 \u2502 0.179824 \u2502 0.59782 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.123077 \u2502 0.223432 \u2502 65.3201 \u2502 3.0 \u2502 4.28546e-14 \u2502 1.01329e-12 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0307692 \u2502 0.0601183 \u2502 65.0164 \u2502 3.0 \u2502 4.9738e-14 \u2502 1.01329e-12 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.369231 \u2502 0.400473 \u2502 0.395604 \u2502 1.0 \u2502 0.529368 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0769231 \u2502 0.130533 \u2502 68.8823 \u2502 3.0 \u2502 7.43849e-15 \u2502 1.01329e-12 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.0923077 \u2502 0.116923 \u2502 65.1572 \u2502 3.0 \u2502 4.64073e-14 \u2502 1.01329e-12 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0461538 \u2502 0.103314 \u2502 65.0387 \u2502 3.0 \u2502 4.91829e-14 \u2502 1.01329e-12 \u2502, South Carolina = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.4 \u2502 0.375 \u2502 0.0888889 \u2502 1.0 \u2502 0.765594 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.117647 \u2502 0.110727 \u2502 0.0664063 \u2502 1.0 \u2502 0.796643 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.277778 \u2502 0.313272 \u2502 0.231066 \u2502 1.0 \u2502 0.630735 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0526316 \u2502 0.0512465 \u2502 0.0138787 \u2502 1.0 \u2502 0.90622 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.1 \u2502 0.095 \u2502 0.0554017 \u2502 1.0 \u2502 0.813917 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.35 \u2502 0.43875 \u2502 0.818338 \u2502 1.0 \u2502 0.365667 \u2502 0.948296 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.0 \u2502 0.18 \u2502 20.0 \u2502 1.0 \u2502 7.74422e-6 \u2502 5.90346e-5 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.1 \u2502 0.185 \u2502 20.0617 \u2502 3.0 \u2502 0.000164815 \u2502 0.00078662 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.3 \u2502 0.255 \u2502 0.622837 \u2502 1.0 \u2502 0.429995 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0 \u2502 0.255 \u2502 20.0 \u2502 1.0 \u2502 7.74422e-6 \u2502 5.90346e-5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.05 \u2502 0.22375 \u2502 20.0163 \u2502 3.0 \u2502 0.000168425 \u2502 0.00078662 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.05 \u2502 0.14125 \u2502 20.0146 \u2502 3.0 \u2502 0.000168563 \u2502 0.00078662 \u2502, Florida Keys = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.45 \u2502 0.41125 \u2502 0.519382 \u2502 3.0 \u2502 0.914613 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.4 \u2502 0.42 \u2502 0.0453515 \u2502 1.0 \u2502 0.831359 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.25 \u2502 0.28875 \u2502 0.360188 \u2502 1.0 \u2502 0.548402 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.2 \u2502 0.18 \u2502 0.246914 \u2502 1.0 \u2502 0.619257 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.25 \u2502 0.21875 \u2502 0.408163 \u2502 1.0 \u2502 0.522903 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.05 \u2502 0.04875 \u2502 0.0131492 \u2502 1.0 \u2502 0.908707 \u2502 0.987085 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.45 \u2502 0.39875 \u2502 0.330382 \u2502 1.0 \u2502 0.565434 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.05 \u2502 0.04875 \u2502 0.0131492 \u2502 1.0 \u2502 0.908707 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.4 \u2502 0.375 \u2502 0.0888889 \u2502 1.0 \u2502 0.765594 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.15 \u2502 0.13875 \u2502 0.131483 \u2502 1.0 \u2502 0.7169 \u2502 0.987085 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.15 \u2502 0.13875 \u2502 0.131483 \u2502 1.0 \u2502 0.7169 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502, Mideast Gulf = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.5 \u2502 0.436224 \u2502 0.598475 \u2502 1.0 \u2502 0.439161 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.214286 \u2502 0.191327 \u2502 0.4032 \u2502 1.0 \u2502 0.525441 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.178571 \u2502 0.21875 \u2502 0.944606 \u2502 1.0 \u2502 0.331096 \u2502 0.898252 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.107143 \u2502 0.101403 \u2502 0.0897116 \u2502 1.0 \u2502 0.764544 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.357143 \u2502 0.336735 \u2502 0.102847 \u2502 1.0 \u2502 0.74844 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.535714 \u2502 0.484056 \u2502 0.318893 \u2502 1.0 \u2502 0.572274 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.178571 \u2502 0.162628 \u2502 0.269127 \u2502 1.0 \u2502 0.603918 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0357143 \u2502 0.101403 \u2502 11.75 \u2502 1.0 \u2502 0.000608429 \u2502 0.00278639 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.285714 \u2502 0.336735 \u2502 0.642792 \u2502 1.0 \u2502 0.422702 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.107143 \u2502 0.101403 \u2502 0.0897116 \u2502 1.0 \u2502 0.764544 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0714286 \u2502 0.135204 \u2502 28.0414 \u2502 3.0 \u2502 3.56005e-6 \u2502 3.64412e-5 \u2502, Northeast Gulf = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.428571 \u2502 0.375 \u2502 0.571429 \u2502 1.0 \u2502 0.449692 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.321429 \u2502 0.392219 \u2502 0.912124 \u2502 1.0 \u2502 0.339552 \u2502 0.903179 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.214286 \u2502 0.191327 \u2502 0.4032 \u2502 1.0 \u2502 0.525441 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.25 \u2502 0.21875 \u2502 0.571429 \u2502 1.0 \u2502 0.449692 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.285714 \u2502 0.336735 \u2502 0.642792 \u2502 1.0 \u2502 0.422702 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.107143 \u2502 0.101403 \u2502 0.0897116 \u2502 1.0 \u2502 0.764544 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.142857 \u2502 0.132653 \u2502 0.16568 \u2502 1.0 \u2502 0.68398 \u2502 0.987085 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.464286 \u2502 0.448342 \u2502 0.0354101 \u2502 1.0 \u2502 0.850739 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.0688776 \u2502 28.0 \u2502 1.0 \u2502 1.21315e-7 \u2502 1.87007e-6 \u2502, Southeast Gulf = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.433333 \u2502 0.375 \u2502 0.725926 \u2502 1.0 \u2502 0.394207 \u2502 0.980648 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.2 \u2502 0.231111 \u2502 0.543639 \u2502 1.0 \u2502 0.460928 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.133333 \u2502 0.18 \u2502 2.01646 \u2502 1.0 \u2502 0.155601 \u2502 0.540012 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0666667 \u2502 0.0644444 \u2502 0.0356718 \u2502 1.0 \u2502 0.850195 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.2 \u2502 0.18 \u2502 0.37037 \u2502 1.0 \u2502 0.542802 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0333333 \u2502 0.0327778 \u2502 0.00861821 \u2502 1.0 \u2502 0.926035 \u2502 0.987085 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.466667 \u2502 0.42 \u2502 0.37037 \u2502 1.0 \u2502 0.542802 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.1 \u2502 0.095 \u2502 0.0831025 \u2502 1.0 \u2502 0.773136 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.133333 \u2502 0.124444 \u2502 0.153061 \u2502 1.0 \u2502 0.695627 \u2502 0.987085 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.433333 \u2502 0.375 \u2502 0.725926 \u2502 1.0 \u2502 0.394207 \u2502 0.980648 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0666667 \u2502 0.0644444 \u2502 0.0356718 \u2502 1.0 \u2502 0.850195 \u2502 0.987085 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.133333 \u2502 0.124444 \u2502 0.153061 \u2502 1.0 \u2502 0.695627 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.124444 \u2502 30.0 \u2502 1.0 \u2502 4.32046e-8 \u2502 7.21496e-7 \u2502) pro tip If using by_pop = true , there may be a very long output which you may want to suppress by ending the command with a semicolon ; . The function returns a NamedTuple of DataFrames, meaning you can index it with a dot . operator. If you assign the command's output to a variable, such as hardy = hwe_test(gulfsharks(), by_pop = true) ; , then you can index the output with the population names, such as hardy.CapeCanaveral or hardy.Georgia . And since those objects are DataFrames, you can continue using the dot . operator to index them further by column, such as hardy.Georgia.Pcorr to see only the corrected P values. Convenience! indexing the Chiq-sq column The Fast(er) Way : you can just index the column using the DataFrames numerical index like so: df[!, 4] The Fun Way: to index the chi-squared column from the dataframe using the dot operator (i.e. df.\u03c7\u00b2 ), you will need to use the unicode characters in Julia, b/c the column is literally named \u03c7\u00b2. To generate those characters, type in \\Chi + press TAB + type in \\^2 + press TAB without spaces and it will magically appear (in the REPL and Juno, at least). Written out in more explicit English (we really want you to get it!), it's a backslash \\ , the word Chi with a capital C, the TAB key on your keyboard (and you'll notice it's already changed it to the letter \u03c7), another backslash \\ , a caret ^ , the number 2 , then the TAB key again. All in all, you'll be doing this: \\ChiTAB\\^2TAB . It's actually a lot easier than it looks.","title":"Hardy-Weinberg Equilibrium"},{"location":"hardyweinberg/#test-for-hardy-weinberg-equilibrium","text":"hwe_test ( x :: PopObj , by_pop :: Bool = false , correction :: String = \"none\" ) Calculate chi-squared test of HWE for each locus and returns observed and expected heterozygosity with chi-squared, degrees of freedom and p-values for each locus. Use by_pop = true to perform this separately for each population (default: by_pop = false) and return a NamedTuple with the names corresponding to the population names. Use correction = to specify a P-value correction method for multiple testing.","title":"Test for Hardy-Weinberg equilibrium"},{"location":"hardyweinberg/#arguments","text":"x : the input PopObj by_pop = : false (default) or true for hwe-by-population correction = : a string specifying a P-value adjustment type (default: \"none\")","title":"arguments"},{"location":"hardyweinberg/#correction-methods","text":"\"bonferroni\" : Bonferroni adjustment \"holm\" : Holm adjustment \"hochberg\" : Hochberg adjustment \"bh\" or \"b-h\" : Benjamini-Hochberg adjustment \"by\" or \"b-y\" : Benjamini-Yekutieli adjustment \"bl\" or \"b-l\" : Benjamini-Liu adjustment \"hommel\" : Hommel adjustment \"sidak\" : \u0160id\u00e1k adjustment \"forward stop\" or \"fs\" : Forward-Stop adjustment \"bc\" or \"b-c\" : Barber-Cande\u0300s adjustment For more information on multiple testing adjustments, see MultipleTesting.jl","title":"correction methods"},{"location":"hardyweinberg/#example","text":"example hwe_test ( gulfsharks (), correction = \"bh\" ) output 2213\u00d77 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64 \u2502 Float64 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.419811 \u2502 0.398051 \u2502 0.690981 \u2502 3.0 \u2502 0.875323 \u2502 0.948912 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.262136 \u2502 0.288434 \u2502 1.71251 \u2502 1.0 \u2502 0.19066 \u2502 0.295543 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.205742 \u2502 0.228532 \u2502 2.0785 \u2502 1.0 \u2502 0.149387 \u2502 0.234857 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0666667 \u2502 0.0644444 \u2502 0.249703 \u2502 1.0 \u2502 0.617284 \u2502 0.807471 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.240566 \u2502 0.21875 \u2502 2.10859 \u2502 1.0 \u2502 0.146475 \u2502 0.230442 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0188679 \u2502 0.0186899 \u2502 0.019229 \u2502 1.0 \u2502 0.889712 \u2502 0.948912 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0.0801887 \u2502 0.0769736 \u2502 0.369866 \u2502 1.0 \u2502 0.543077 \u2502 0.732045 \u2502 \u2502 8 \u2502 contig_14708 \u2502 0.0616114 \u2502 0.0597134 \u2502 0.213168 \u2502 1.0 \u2502 0.644295 \u2502 0.828219 \u2502 \u2502 9 \u2502 contig_2307 \u2502 0.0289855 \u2502 0.0285654 \u2502 0.0447664 \u2502 1.0 \u2502 0.832434 \u2502 0.938862 \u2502 \u2502 10 \u2502 contig_14564 \u2502 0.2 \u2502 0.209751 \u2502 0.453809 \u2502 1.0 \u2502 0.500532 \u2502 0.6894 \u2502 \u2502 11 \u2502 contig_15269 \u2502 0.15566 \u2502 0.146505 \u2502 1.51012 \u2502 3.0 \u2502 0.679938 \u2502 0.857489 \u2502 \u2502 12 \u2502 contig_24796 \u2502 0.161137 \u2502 0.201613 \u2502 8.50406 \u2502 1.0 \u2502 0.00354355 \u2502 0.00596524 \u2502 \u2502 13 \u2502 contig_14251 \u2502 0.490566 \u2502 0.49782 \u2502 0.0450074 \u2502 1.0 \u2502 0.83199 \u2502 0.938862 \u2502 \u2502 14 \u2502 contig_44797 \u2502 0.0240385 \u2502 0.0237495 \u2502 0.0307836 \u2502 1.0 \u2502 0.860724 \u2502 0.944468 \u2502 \u2502 15 \u2502 contig_43681 \u2502 0.42381 \u2502 0.472778 \u2502 2.25286 \u2502 1.0 \u2502 0.133368 \u2502 0.211628 \u2502 \u2502 16 \u2502 contig_24115 \u2502 0.0333333 \u2502 0.0327778 \u2502 0.0603275 \u2502 1.0 \u2502 0.805979 \u2502 0.931567 \u2502 \u2502 17 \u2502 contig_5456 \u2502 0.0471698 \u2502 0.0460573 \u2502 0.12369 \u2502 1.0 \u2502 0.725066 \u2502 0.892017 \u2502 \u2502 18 \u2502 contig_21698 \u2502 0.0758294 \u2502 0.0729543 \u2502 0.327695 \u2502 1.0 \u2502 0.567019 \u2502 0.758715 \u2502 \u22ee \u2502 2195 \u2502 contig_8479 \u2502 0.0235849 \u2502 0.0598856 \u2502 212.031 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2196 \u2502 contig_47462 \u2502 0.45283 \u2502 0.502803 \u2502 213.589 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2197 \u2502 contig_4095 \u2502 0.259434 \u2502 0.275398 \u2502 212.0 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2198 \u2502 contig_7239 \u2502 0.0660377 \u2502 0.0729352 \u2502 212.25 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2199 \u2502 contig_40507 \u2502 0.0330189 \u2502 0.0688746 \u2502 212.062 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2200 \u2502 contig_42145 \u2502 0.358491 \u2502 0.31754 \u2502 5.95351 \u2502 3.0 \u2502 0.113894 \u2502 0.182428 \u2502 \u2502 2201 \u2502 contig_1033 \u2502 0.363208 \u2502 0.352872 \u2502 0.181856 \u2502 1.0 \u2502 0.669783 \u2502 0.85219 \u2502 \u2502 2202 \u2502 contig_2798 \u2502 0.122642 \u2502 0.140219 \u2502 212.952 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2203 \u2502 contig_12991 \u2502 0.0518868 \u2502 0.112685 \u2502 212.161 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2204 \u2502 contig_22981 \u2502 0.188679 \u2502 0.200783 \u2502 0.770434 \u2502 1.0 \u2502 0.380083 \u2502 0.551307 \u2502 \u2502 2205 \u2502 contig_15342 \u2502 0.268868 \u2502 0.29084 \u2502 212.328 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2206 \u2502 contig_24711 \u2502 0.273585 \u2502 0.288136 \u2502 0.540694 \u2502 1.0 \u2502 0.462145 \u2502 0.645777 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0.466981 \u2502 0.437422 \u2502 0.968086 \u2502 1.0 \u2502 0.325158 \u2502 0.482394 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.103774 \u2502 0.150454 \u2502 212.675 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0660377 \u2502 0.0906016 \u2502 213.73 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.367925 \u2502 0.375 \u2502 0.0754717 \u2502 1.0 \u2502 0.78353 \u2502 0.926932 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0613208 \u2502 0.11264 \u2502 214.152 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.0896226 \u2502 0.11224 \u2502 212.481 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0283019 \u2502 0.0908241 \u2502 212.047 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 by_pop = true julia> hwe_test(gulfsharks(), by_pop = true, correction = \"bh\") (Cape Canaveral = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.333333 \u2502 0.427438 \u2502 1.01787 \u2502 1.0 \u2502 0.313025 \u2502 0.872143 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.263158 \u2502 0.228532 \u2502 0.43618 \u2502 1.0 \u2502 0.508972 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.142857 \u2502 0.209751 \u2502 2.13589 \u2502 1.0 \u2502 0.143886 \u2502 0.51061 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.0952381 \u2502 0.0907029 \u2502 0.0525 \u2502 1.0 \u2502 0.818769 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.52381 \u2502 0.427438 \u2502 1.06752 \u2502 1.0 \u2502 0.301507 \u2502 0.856472 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.0952381 \u2502 0.0907029 \u2502 0.0525 \u2502 1.0 \u2502 0.818769 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.047619 \u2502 0.0464853 \u2502 0.0124926 \u2502 1.0 \u2502 0.911006 \u2502 0.987085 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.285714 \u2502 0.30839 \u2502 0.113538 \u2502 1.0 \u2502 0.736152 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0952381 \u2502 0.176871 \u2502 21.0582 \u2502 3.0 \u2502 0.000102388 \u2502 0.000625326 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.047619 \u2502 0.0464853 \u2502 0.0124926 \u2502 1.0 \u2502 0.911006 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502, Georgia = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.4 \u2502 0.389467 \u2502 0.276208 \u2502 3.0 \u2502 0.964439 \u2502 1.0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.28125 \u2502 0.304688 \u2502 0.378698 \u2502 1.0 \u2502 0.538301 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.234375 \u2502 0.230347 \u2502 0.0195733 \u2502 1.0 \u2502 0.888735 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.046875 \u2502 0.0457764 \u2502 0.036864 \u2502 1.0 \u2502 0.847742 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.292308 \u2502 0.249586 \u2502 1.90447 \u2502 1.0 \u2502 0.167579 \u2502 0.57153 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0153846 \u2502 0.0152663 \u2502 0.00390602 \u2502 1.0 \u2502 0.950166 \u2502 0.996029 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.538462 \u2502 0.461657 \u2502 1.79908 \u2502 1.0 \u2502 0.179824 \u2502 0.59782 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.123077 \u2502 0.223432 \u2502 65.3201 \u2502 3.0 \u2502 4.28546e-14 \u2502 1.01329e-12 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0307692 \u2502 0.0601183 \u2502 65.0164 \u2502 3.0 \u2502 4.9738e-14 \u2502 1.01329e-12 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.369231 \u2502 0.400473 \u2502 0.395604 \u2502 1.0 \u2502 0.529368 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0769231 \u2502 0.130533 \u2502 68.8823 \u2502 3.0 \u2502 7.43849e-15 \u2502 1.01329e-12 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.0923077 \u2502 0.116923 \u2502 65.1572 \u2502 3.0 \u2502 4.64073e-14 \u2502 1.01329e-12 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0461538 \u2502 0.103314 \u2502 65.0387 \u2502 3.0 \u2502 4.91829e-14 \u2502 1.01329e-12 \u2502, South Carolina = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.4 \u2502 0.375 \u2502 0.0888889 \u2502 1.0 \u2502 0.765594 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.117647 \u2502 0.110727 \u2502 0.0664063 \u2502 1.0 \u2502 0.796643 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.277778 \u2502 0.313272 \u2502 0.231066 \u2502 1.0 \u2502 0.630735 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0526316 \u2502 0.0512465 \u2502 0.0138787 \u2502 1.0 \u2502 0.90622 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.1 \u2502 0.095 \u2502 0.0554017 \u2502 1.0 \u2502 0.813917 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.35 \u2502 0.43875 \u2502 0.818338 \u2502 1.0 \u2502 0.365667 \u2502 0.948296 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.0 \u2502 0.18 \u2502 20.0 \u2502 1.0 \u2502 7.74422e-6 \u2502 5.90346e-5 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.1 \u2502 0.185 \u2502 20.0617 \u2502 3.0 \u2502 0.000164815 \u2502 0.00078662 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.3 \u2502 0.255 \u2502 0.622837 \u2502 1.0 \u2502 0.429995 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0 \u2502 0.255 \u2502 20.0 \u2502 1.0 \u2502 7.74422e-6 \u2502 5.90346e-5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.05 \u2502 0.22375 \u2502 20.0163 \u2502 3.0 \u2502 0.000168425 \u2502 0.00078662 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.05 \u2502 0.14125 \u2502 20.0146 \u2502 3.0 \u2502 0.000168563 \u2502 0.00078662 \u2502, Florida Keys = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.45 \u2502 0.41125 \u2502 0.519382 \u2502 3.0 \u2502 0.914613 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.4 \u2502 0.42 \u2502 0.0453515 \u2502 1.0 \u2502 0.831359 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.25 \u2502 0.28875 \u2502 0.360188 \u2502 1.0 \u2502 0.548402 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.2 \u2502 0.18 \u2502 0.246914 \u2502 1.0 \u2502 0.619257 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.25 \u2502 0.21875 \u2502 0.408163 \u2502 1.0 \u2502 0.522903 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.05 \u2502 0.04875 \u2502 0.0131492 \u2502 1.0 \u2502 0.908707 \u2502 0.987085 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.45 \u2502 0.39875 \u2502 0.330382 \u2502 1.0 \u2502 0.565434 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.05 \u2502 0.04875 \u2502 0.0131492 \u2502 1.0 \u2502 0.908707 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.4 \u2502 0.375 \u2502 0.0888889 \u2502 1.0 \u2502 0.765594 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.15 \u2502 0.13875 \u2502 0.131483 \u2502 1.0 \u2502 0.7169 \u2502 0.987085 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.15 \u2502 0.13875 \u2502 0.131483 \u2502 1.0 \u2502 0.7169 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502, Mideast Gulf = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.5 \u2502 0.436224 \u2502 0.598475 \u2502 1.0 \u2502 0.439161 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.214286 \u2502 0.191327 \u2502 0.4032 \u2502 1.0 \u2502 0.525441 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.178571 \u2502 0.21875 \u2502 0.944606 \u2502 1.0 \u2502 0.331096 \u2502 0.898252 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.107143 \u2502 0.101403 \u2502 0.0897116 \u2502 1.0 \u2502 0.764544 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.357143 \u2502 0.336735 \u2502 0.102847 \u2502 1.0 \u2502 0.74844 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.535714 \u2502 0.484056 \u2502 0.318893 \u2502 1.0 \u2502 0.572274 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.178571 \u2502 0.162628 \u2502 0.269127 \u2502 1.0 \u2502 0.603918 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0357143 \u2502 0.101403 \u2502 11.75 \u2502 1.0 \u2502 0.000608429 \u2502 0.00278639 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.285714 \u2502 0.336735 \u2502 0.642792 \u2502 1.0 \u2502 0.422702 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.107143 \u2502 0.101403 \u2502 0.0897116 \u2502 1.0 \u2502 0.764544 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0714286 \u2502 0.135204 \u2502 28.0414 \u2502 3.0 \u2502 3.56005e-6 \u2502 3.64412e-5 \u2502, Northeast Gulf = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.428571 \u2502 0.375 \u2502 0.571429 \u2502 1.0 \u2502 0.449692 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.321429 \u2502 0.392219 \u2502 0.912124 \u2502 1.0 \u2502 0.339552 \u2502 0.903179 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.214286 \u2502 0.191327 \u2502 0.4032 \u2502 1.0 \u2502 0.525441 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.25 \u2502 0.21875 \u2502 0.571429 \u2502 1.0 \u2502 0.449692 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.285714 \u2502 0.336735 \u2502 0.642792 \u2502 1.0 \u2502 0.422702 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.107143 \u2502 0.101403 \u2502 0.0897116 \u2502 1.0 \u2502 0.764544 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.142857 \u2502 0.132653 \u2502 0.16568 \u2502 1.0 \u2502 0.68398 \u2502 0.987085 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.464286 \u2502 0.448342 \u2502 0.0354101 \u2502 1.0 \u2502 0.850739 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.0688776 \u2502 28.0 \u2502 1.0 \u2502 1.21315e-7 \u2502 1.87007e-6 \u2502, Southeast Gulf = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.433333 \u2502 0.375 \u2502 0.725926 \u2502 1.0 \u2502 0.394207 \u2502 0.980648 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.2 \u2502 0.231111 \u2502 0.543639 \u2502 1.0 \u2502 0.460928 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.133333 \u2502 0.18 \u2502 2.01646 \u2502 1.0 \u2502 0.155601 \u2502 0.540012 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0666667 \u2502 0.0644444 \u2502 0.0356718 \u2502 1.0 \u2502 0.850195 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.2 \u2502 0.18 \u2502 0.37037 \u2502 1.0 \u2502 0.542802 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0333333 \u2502 0.0327778 \u2502 0.00861821 \u2502 1.0 \u2502 0.926035 \u2502 0.987085 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.466667 \u2502 0.42 \u2502 0.37037 \u2502 1.0 \u2502 0.542802 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.1 \u2502 0.095 \u2502 0.0831025 \u2502 1.0 \u2502 0.773136 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.133333 \u2502 0.124444 \u2502 0.153061 \u2502 1.0 \u2502 0.695627 \u2502 0.987085 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.433333 \u2502 0.375 \u2502 0.725926 \u2502 1.0 \u2502 0.394207 \u2502 0.980648 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0666667 \u2502 0.0644444 \u2502 0.0356718 \u2502 1.0 \u2502 0.850195 \u2502 0.987085 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.133333 \u2502 0.124444 \u2502 0.153061 \u2502 1.0 \u2502 0.695627 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.124444 \u2502 30.0 \u2502 1.0 \u2502 4.32046e-8 \u2502 7.21496e-7 \u2502)","title":"example"},{"location":"hardyweinberg/#pro-tip","text":"If using by_pop = true , there may be a very long output which you may want to suppress by ending the command with a semicolon ; . The function returns a NamedTuple of DataFrames, meaning you can index it with a dot . operator. If you assign the command's output to a variable, such as hardy = hwe_test(gulfsharks(), by_pop = true) ; , then you can index the output with the population names, such as hardy.CapeCanaveral or hardy.Georgia . And since those objects are DataFrames, you can continue using the dot . operator to index them further by column, such as hardy.Georgia.Pcorr to see only the corrected P values. Convenience! indexing the Chiq-sq column The Fast(er) Way : you can just index the column using the DataFrames numerical index like so: df[!, 4] The Fun Way: to index the chi-squared column from the dataframe using the dot operator (i.e. df.\u03c7\u00b2 ), you will need to use the unicode characters in Julia, b/c the column is literally named \u03c7\u00b2. To generate those characters, type in \\Chi + press TAB + type in \\^2 + press TAB without spaces and it will magically appear (in the REPL and Juno, at least). Written out in more explicit English (we really want you to get it!), it's a backslash \\ , the word Chi with a capital C, the TAB key on your keyboard (and you'll notice it's already changed it to the letter \u03c7), another backslash \\ , a caret ^ , the number 2 , then the TAB key again. All in all, you'll be doing this: \\ChiTAB\\^2TAB . It's actually a lot easier than it looks.","title":"pro tip"},{"location":"hidden_api/","text":"Like most Julia packages, there are a lot of functions in PopGen.jl, but only a number of them are exported , which are the ones you the user can casually use after calling using PopGen . You'll often see other Julia packages refer to these as API's, or \"Application Programming Interface\". If you want to contribute to PopGen.jl, then it will be super useful to know what API's are already available and save you the trouble of reinventing the wheel. If you would like to use any of these functions by themselves (outside the scope of development), then you will need to use the Package.function() syntax, which looks like PopGen.het_sample in practice. Genotype Value Found in Manipulate.jl get_genotype ( x :: PopObj ; sample :: String , locus :: String ) Return the genotype of a specific sample for specific locus in a PopObj . This is a barebones variant to isolate_genotypes that is ~ 1,000 - 10,000x faster depending on the size of the data. Example get_genotype ( nancycats , sample = \"N115\" , locus = \"fca8\" ) ` Allele Frequencies These are found in AlleleFreq.jl allele_freq allele_freq ( x :: Array { Union { Missing , Tuple }, 1 }) Calculate allele counts for a single locus of a PopObj . Returns a Dict of allele's and their frequencies. allele_freq ( x :: SubArray { Union { Missing , Tuple }, 1 }) Calculate allele counts for a single locus of a PopObj split by population using group() . Returns a Dict of allele's and their frequencies. Genotype Frequencies These are found in AlleleFreq.jl geno_freq geno_freq ( x :: Array { Union { Missing , Tuple }, 1 }) Calculate genotype frequencies of all loci in a PopObj . Returns a Dict of genotypes and their frequencies. geno_freq ( x :: SubArray { Union { Missing , Tuple }, 1 }) Calculate genotype frequencies of all loci in PopObj split by population using group() . Returns a Dict of genotypes and their frequencies. Observed Heterozygosity These are found in HardyWeinberg.jl het_observed het_observed ( x :: PopObj ) Calculate the observed heterozygosity for each locus in a PopObj . Returns an array of heterozygosity values. het_population_obs het_population_obs ( x :: PopObj ) Return a Dict of the observed heterozygosity per population for each locus in a PopObj het_sample het_sample ( x :: PopObj ) Calculate the observed heterozygosity for each individual in a PopObj . Returns an array of heterozygosity values. Expected Heterozygosity These are found in HardyWeinberg.jl het_expected het_expected ( x :: PopObj ) Calculate the expected heterozygosity for each locus in a PopObj . Returns an array of heterozygosity values. het_population_exp het_population_exp ( x :: PopObj ) Return a Dict of the expected heterozygosity per population for each locus in a PopObj . Chi Squared Found in HardyWeinberg.jl locus_chi_sq locus_chi_sq ( locus :: Array { Union { Missing , Tuple }, 1 }) Calculate the chi square statistic and p-value for a locus. Returns a tuple with chi-square statistic, degrees of freedom, and p-value. Multiple Testing Found in HardyWeinberg.jl multitest_missing multitest_missing ( pvals :: Array { Float64 , 1 }, correction :: String ) Modification to MultipleTesting.adjust to include missing values. Missing values are first removed from the array, the appropriate correction made, then missing values are re-added to the array at their original positions. See MultipleTesting.jl docs for full more detailed information. Example: multitest_missing([0.1, 0.01, 0.005, 0.3], \"bh\") correction methods (case insensitive): \"bonferroni\" : Bonferroni adjustment \"holm\" : Holm adjustment \"hochberg\" : Hochberg adjustment \"bh\" or \"b-h\" : Benjamini-Hochberg adjustment \"by\" or \"b-y\" : Benjamini-Yekutieli adjustment \"bl\" or \"b-l\" : Benjamini-Liu adjustment \"hommel\" : Hommel adjustment \"sidak\" : \u0160id\u00e1k adjustment \"forward stop\" or \"fs\" : Forward-Stop adjustment \"bc\" or \"b-c\" : Barber-Cande\u0300s adjustment","title":"Under the hood functions"},{"location":"hidden_api/#genotype-value","text":"Found in Manipulate.jl get_genotype ( x :: PopObj ; sample :: String , locus :: String ) Return the genotype of a specific sample for specific locus in a PopObj . This is a barebones variant to isolate_genotypes that is ~ 1,000 - 10,000x faster depending on the size of the data. Example get_genotype ( nancycats , sample = \"N115\" , locus = \"fca8\" ) `","title":"Genotype Value"},{"location":"hidden_api/#allele-frequencies","text":"These are found in AlleleFreq.jl","title":"Allele Frequencies"},{"location":"hidden_api/#allele_freq","text":"allele_freq ( x :: Array { Union { Missing , Tuple }, 1 }) Calculate allele counts for a single locus of a PopObj . Returns a Dict of allele's and their frequencies. allele_freq ( x :: SubArray { Union { Missing , Tuple }, 1 }) Calculate allele counts for a single locus of a PopObj split by population using group() . Returns a Dict of allele's and their frequencies.","title":"allele_freq"},{"location":"hidden_api/#genotype-frequencies","text":"These are found in AlleleFreq.jl","title":"Genotype Frequencies"},{"location":"hidden_api/#geno_freq","text":"geno_freq ( x :: Array { Union { Missing , Tuple }, 1 }) Calculate genotype frequencies of all loci in a PopObj . Returns a Dict of genotypes and their frequencies. geno_freq ( x :: SubArray { Union { Missing , Tuple }, 1 }) Calculate genotype frequencies of all loci in PopObj split by population using group() . Returns a Dict of genotypes and their frequencies.","title":"geno_freq"},{"location":"hidden_api/#observed-heterozygosity","text":"These are found in HardyWeinberg.jl","title":"Observed Heterozygosity"},{"location":"hidden_api/#het_observed","text":"het_observed ( x :: PopObj ) Calculate the observed heterozygosity for each locus in a PopObj . Returns an array of heterozygosity values.","title":"het_observed"},{"location":"hidden_api/#het_population_obs","text":"het_population_obs ( x :: PopObj ) Return a Dict of the observed heterozygosity per population for each locus in a PopObj","title":"het_population_obs"},{"location":"hidden_api/#het_sample","text":"het_sample ( x :: PopObj ) Calculate the observed heterozygosity for each individual in a PopObj . Returns an array of heterozygosity values.","title":"het_sample"},{"location":"hidden_api/#expected-heterozygosity","text":"These are found in HardyWeinberg.jl","title":"Expected Heterozygosity"},{"location":"hidden_api/#het_expected","text":"het_expected ( x :: PopObj ) Calculate the expected heterozygosity for each locus in a PopObj . Returns an array of heterozygosity values.","title":"het_expected"},{"location":"hidden_api/#het_population_exp","text":"het_population_exp ( x :: PopObj ) Return a Dict of the expected heterozygosity per population for each locus in a PopObj .","title":"het_population_exp"},{"location":"hidden_api/#chi-squared","text":"Found in HardyWeinberg.jl","title":"Chi Squared"},{"location":"hidden_api/#locus_chi_sq","text":"locus_chi_sq ( locus :: Array { Union { Missing , Tuple }, 1 }) Calculate the chi square statistic and p-value for a locus. Returns a tuple with chi-square statistic, degrees of freedom, and p-value.","title":"locus_chi_sq"},{"location":"hidden_api/#multiple-testing","text":"Found in HardyWeinberg.jl","title":"Multiple Testing"},{"location":"hidden_api/#multitest_missing","text":"multitest_missing ( pvals :: Array { Float64 , 1 }, correction :: String ) Modification to MultipleTesting.adjust to include missing values. Missing values are first removed from the array, the appropriate correction made, then missing values are re-added to the array at their original positions. See MultipleTesting.jl docs for full more detailed information. Example: multitest_missing([0.1, 0.01, 0.005, 0.3], \"bh\") correction methods (case insensitive): \"bonferroni\" : Bonferroni adjustment \"holm\" : Holm adjustment \"hochberg\" : Hochberg adjustment \"bh\" or \"b-h\" : Benjamini-Hochberg adjustment \"by\" or \"b-y\" : Benjamini-Yekutieli adjustment \"bl\" or \"b-l\" : Benjamini-Liu adjustment \"hommel\" : Hommel adjustment \"sidak\" : \u0160id\u00e1k adjustment \"forward stop\" or \"fs\" : Forward-Stop adjustment \"bc\" or \"b-c\" : Barber-Cande\u0300s adjustment","title":"multitest_missing"},{"location":"install/","text":"Installation Installing PopGen.jl The package is currently unregistered while it's under active early development. However, installation is still simple! In REPL or Juno Invoke the package manager with ] in the REPL and use add \"https://github.com/pdimens/PopGen.jl\" With Jupyter Notebooks or nteract using Pkg Pkg . add ( \"https://github.com/pdimens/PopGen.jl\" ) Using PopGen Like all Julia packages, to activate PopGen.jl, simply run: julia > using PopGen Feel free to play around with the test data in /data/data/ or add it to your workspace with the nancycats and gulfsharks commands. Arch Linux users If you compiled Julia from source, your PopGen.jl installation may fail due to incorrectly building Arpack , which is expected to be in one place, but the compilation puts in another. Solutions: recommended to install official Julia binaries from the AUR ( julia-bin ), which includes a correctly bundled Arpack if Julia was compiled from source: install julia-arpack from the AUR and make sure to delete ~/.julia/packages/Arpack if it exists. That should fix things, but sometimes it still acts up.","title":"How to Install"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#installing-popgenjl","text":"The package is currently unregistered while it's under active early development. However, installation is still simple!","title":"Installing PopGen.jl"},{"location":"install/#in-repl-or-juno","text":"Invoke the package manager with ] in the REPL and use add \"https://github.com/pdimens/PopGen.jl\"","title":"In REPL or Juno"},{"location":"install/#with-jupyter-notebooks-or-nteract","text":"using Pkg Pkg . add ( \"https://github.com/pdimens/PopGen.jl\" )","title":"With Jupyter Notebooks or nteract"},{"location":"install/#using-popgen","text":"Like all Julia packages, to activate PopGen.jl, simply run: julia > using PopGen Feel free to play around with the test data in /data/data/ or add it to your workspace with the nancycats and gulfsharks commands.","title":"Using PopGen"},{"location":"install/#arch-linux-users","text":"If you compiled Julia from source, your PopGen.jl installation may fail due to incorrectly building Arpack , which is expected to be in one place, but the compilation puts in another. Solutions: recommended to install official Julia binaries from the AUR ( julia-bin ), which includes a correctly bundled Arpack if Julia was compiled from source: install julia-arpack from the AUR and make sure to delete ~/.julia/packages/Arpack if it exists. That should fix things, but sometimes it still acts up.","title":"Arch Linux users"},{"location":"juliaprimer/","text":"A quick Julia primer for getting the most out of this documentation There is nothing inherently special about this documentation relative to other documentation, other than we really really want you to get the most out of what's written here. This means that we need to embrace the fact that both novice and experienced Julia users may be reading these docs and using this package. So let's cover some Julia basics that will really help in navigating this package before we even get into the complicated genetics stuff. This primer is by no means \"everything you need to get started in Julia\", and is a poor substitute for actually learning the language. In general, we recommend Think Julia: How to Think Like a Data Scientist by Ben Lauwens to establish some solid Julia foundations. It's free online! Using Julia Everyone has their own particular workflows, and if you're new to Julia, you might not have established one yet. Julia can be used rather comfortably using its built-in interpreter, but you can also use it via Atom (the officially supported uber-juno add-on) for an RStudio-like experience. If you're already a fan of Jupyter notebooks (or nteract ), then all you need is to install the IJulia package in Julia and you have full Jupyter support for Julia! Other popular options are VScode (julia add-on), or Emacs. If you didn't already know, the name \"Jupyter\" is actually a concatenation of Ju (julia) Pyt (python) and R (...R). First-time Performance If you're migrating to Julia from Python or R (or Matlab, etc.), you'll think Julia is slow and laggy because loading packages and running stuff has a noticeable wait time (10-40sec). It's worth mentioning that this lag is \"compilation overhead\". What this means is, Julia tries to pre-compile as much code as possible (into optimized machine code) when running something or loading a package. This lag exists only the first time you run something. Every subsequent run of a function, even with different parameters, will be substantially faster, and in most cases instant. If you want to test this yourself, try to run a line of code twice with @time before the function and compare the results. Here's an example: julia> @time using PopGen 17.415902 seconds (19.88 M allocations: 1.022 GiB, 2.79% gc time) julia> @time using PopGen 0.100233 seconds (64.07 k allocations: 3.123 MiB, 6.02% gc time) Semicolons Semicolons will come up a lot in Julia, probably more than you would expect if you are migrating from another language. They mean different things depending on where they are. At the end of a command When you see a semicolon after invoking a function, what that means is \"don't show me the output in the terminal window\". Example: julia > x = 2 + 2 4 julia > x = 10 + 2 ; julia > x 12 Julia will still process the command and assign 10 + 2 to x , but it won't show you the output in the terminal. We sometimes include a semicolon after commands in these docs to mimic what the REPL output would look like without spitting back out an array of over 200 values. These semicolons are optional In between assignment commands If you see a semicolon in between two variable assignments, like so: julia > x = [ 1 , 2 ] ; y = [ 3 , 4 ] that's a Julia short-hand for making two short lines of code appear on a single line. It's the equivalent of doing: julia > x = [ 1 , 2 ] ; julia > y = [ 3 , 4 ] We sometimes choose this writing format for very quick and small assignments hoping to save some visual space. Use whichever method is most comfortable and sensible for you! Help mode To enter help mode in the REPL, simply press the question mark key ? (shift + key) and you will notice a different prompt help?> for you to type in a function. help ?> population search: population populations population! populations! population(x::PopObj; listall::Bool = false) View unique population ID's in a PopObj. listall = true, displays ind and their population instead (default = false). Type information Julia encourages strong typing of variables, and the functions in PopGen are no exception to this. However, to reduce the barrier of entry required to understand this documentation and the subsequent package, we have chosen to omit some of the type information from functions to reduce visual clutter for newer users. As experienced users already know, if you would like to see the explicit type information, you can look at the code on github, invoke the help system in the REPL (above), or search for a function in the Documentation pane in Juno. You'll notice types follow a specific format, which is object::type . This format is a type declaration, so in the function population , which looks like: population(x::PopObj; listall::Bool = false) : x is a variable of type PopObj listall is a variable of type Bool (boolean) meaning it only takes true or false without quotes, and the default value is set to false . Type Unions You might see the type Union appear occasionally throughout this documentation, and you can consider it a list of allowable types. For example, if something was of type ::Union{String,Integer} , that means that either a String or Integer works. Functions vs. Methods As part of Julia's type-safe paradigm and multiple dispatch (see \"ERROR: MethodError: no method matching\" below), type specifications in functions often reduce runtime of functions, but also establish function identity. Multiple dispatch refers to several different functions having the same name, but employing different methods depending on the input. In Julia, it's easier to write a single function with multiple type-safe methods, rather than one mega-function that accepts any type and have a bunch of if statements that determines what the program does depending on the input. In practice, this looks like: # combine two numbers julia> function add(x::Integer, y::Integer) x+y end add (generic function with 1 method) # combine two strings julia> function add(x::String, y::String) x*y end add (generic function with 2 methods) julia> add(1,2) 3 julia> add(\"water\", \"melon\") \"watermelon\" Multiple dispatch therefor leads to a unique type of possible error: the MethodError ERROR: MethodError: no method matching Using the function add from the example above, let's have a look at what happens when we try to add an Integer with a String : julia > add ( 1 , \"melon\" ) ERROR : MethodError : no method matching add ( :: Int64 , :: String ) Closest candidates are : add ( :: String , :: String ) at none : 2 add ( :: Integer , :: Integer ) at none : 2 Stacktrace : [ 1 ] top - level scope at none : 0 This error is telling us \"there is no such function called add , who's inputs are an Integer followed by a String \". But, it does offer us some alternatives, like the two add functions we created earlier. The functions within PopGen are almost always explicitly typed, so if you are getting the MethodError: no method matching error, then you are inputting the incorrect types into the function, or perhaps your inputs for the arguments are in the wrong order (see \"Functions with and without keywords\" below). Sometimes you might include an argument with a keyword when there isn't one, or include an argument without a keyword when there needs to be one (honestly, we make that mistake too and we wrote this stuff). To help minimize those mistakes, please read below about which arguments have keywords and which don't. MethodError's can definitely get annoying, but they are usually the result of incorrect input from the user and not buggy programming by the developers. Please double-check your inputs before assuming something is broken or bugged. Functions with and without keywords Let's talk about semicolons some more. TL;DR Reading these docs, pay attention to semicolons in the function argument lists. arguments before a semicolon have no keyword and follow an explicit order arguments after a semicolon have a keyword argument = value and their order doesn't matter MethodError: no methods matching is more likely an issue on your side and not on our side unless we accidentally forgot to export a function! or we typed a function incorrectly really, it's a coin flip who could be at fault Broadly speaking, there are two types of function declarations in Julia: ones with keywords and ones without keywords. The term \"keywords\" refers to an input argument that has the format argument = value . This format is present in many of the functions in this and other packages, however there are some specifics to understand when functions use keywords and when they don't. Format 1: Strict argument order and no keywords - No semicolon in argument list function function_name ( var1 :: type , var2 :: type , var3 :: type ) do stuff with vars end If a function is declared with only commas in the argument list, like shown above, then the arguments to that function must have no keywords and follow the exact order they appear in. If the generic example above had the typing: function function_name ( var1 :: String , var2 :: Float64 , var3 :: Array { String , 1 }) do stuff with vars end then the only acceptable way to run this function without getting a MethodError would be with arguments in the order of function_name(String, Float64, Array{String,1}) . Even if some of the arguments have a default values, like var2::Float64 = 6.66 , the order of arguments/types has to be respected as declared. Format 2 - semicolon in argument list function function_name ( var1 :: type ; var2 :: type , var3 :: type ) do stuff with vars end In this format, everything that comes before the semicolon follows the strict rules from Format 1 , and everything that comes after the semicolon is a keyword argument. Keyword arguments have the flexibility to not require any particular input order. However, you must use the keywords to declare those arguments, or you will receive another MethodError: no method matching , which is, as we've mentioned, annoying.","title":"A Julia primer"},{"location":"juliaprimer/#a-quick-julia-primer-for-getting-the-most-out-of-this-documentation","text":"There is nothing inherently special about this documentation relative to other documentation, other than we really really want you to get the most out of what's written here. This means that we need to embrace the fact that both novice and experienced Julia users may be reading these docs and using this package. So let's cover some Julia basics that will really help in navigating this package before we even get into the complicated genetics stuff. This primer is by no means \"everything you need to get started in Julia\", and is a poor substitute for actually learning the language. In general, we recommend Think Julia: How to Think Like a Data Scientist by Ben Lauwens to establish some solid Julia foundations. It's free online!","title":"A quick Julia primer for getting the most out of this documentation"},{"location":"juliaprimer/#using-julia","text":"Everyone has their own particular workflows, and if you're new to Julia, you might not have established one yet. Julia can be used rather comfortably using its built-in interpreter, but you can also use it via Atom (the officially supported uber-juno add-on) for an RStudio-like experience. If you're already a fan of Jupyter notebooks (or nteract ), then all you need is to install the IJulia package in Julia and you have full Jupyter support for Julia! Other popular options are VScode (julia add-on), or Emacs. If you didn't already know, the name \"Jupyter\" is actually a concatenation of Ju (julia) Pyt (python) and R (...R).","title":"Using Julia"},{"location":"juliaprimer/#first-time-performance","text":"If you're migrating to Julia from Python or R (or Matlab, etc.), you'll think Julia is slow and laggy because loading packages and running stuff has a noticeable wait time (10-40sec). It's worth mentioning that this lag is \"compilation overhead\". What this means is, Julia tries to pre-compile as much code as possible (into optimized machine code) when running something or loading a package. This lag exists only the first time you run something. Every subsequent run of a function, even with different parameters, will be substantially faster, and in most cases instant. If you want to test this yourself, try to run a line of code twice with @time before the function and compare the results. Here's an example: julia> @time using PopGen 17.415902 seconds (19.88 M allocations: 1.022 GiB, 2.79% gc time) julia> @time using PopGen 0.100233 seconds (64.07 k allocations: 3.123 MiB, 6.02% gc time)","title":"First-time Performance"},{"location":"juliaprimer/#semicolons","text":"Semicolons will come up a lot in Julia, probably more than you would expect if you are migrating from another language. They mean different things depending on where they are.","title":"Semicolons"},{"location":"juliaprimer/#at-the-end-of-a-command","text":"When you see a semicolon after invoking a function, what that means is \"don't show me the output in the terminal window\". Example: julia > x = 2 + 2 4 julia > x = 10 + 2 ; julia > x 12 Julia will still process the command and assign 10 + 2 to x , but it won't show you the output in the terminal. We sometimes include a semicolon after commands in these docs to mimic what the REPL output would look like without spitting back out an array of over 200 values. These semicolons are optional","title":"At the end of a command"},{"location":"juliaprimer/#in-between-assignment-commands","text":"If you see a semicolon in between two variable assignments, like so: julia > x = [ 1 , 2 ] ; y = [ 3 , 4 ] that's a Julia short-hand for making two short lines of code appear on a single line. It's the equivalent of doing: julia > x = [ 1 , 2 ] ; julia > y = [ 3 , 4 ] We sometimes choose this writing format for very quick and small assignments hoping to save some visual space. Use whichever method is most comfortable and sensible for you!","title":"In between assignment commands"},{"location":"juliaprimer/#help-mode","text":"To enter help mode in the REPL, simply press the question mark key ? (shift + key) and you will notice a different prompt help?> for you to type in a function. help ?> population search: population populations population! populations! population(x::PopObj; listall::Bool = false) View unique population ID's in a PopObj. listall = true, displays ind and their population instead (default = false).","title":"Help mode"},{"location":"juliaprimer/#type-information","text":"Julia encourages strong typing of variables, and the functions in PopGen are no exception to this. However, to reduce the barrier of entry required to understand this documentation and the subsequent package, we have chosen to omit some of the type information from functions to reduce visual clutter for newer users. As experienced users already know, if you would like to see the explicit type information, you can look at the code on github, invoke the help system in the REPL (above), or search for a function in the Documentation pane in Juno. You'll notice types follow a specific format, which is object::type . This format is a type declaration, so in the function population , which looks like: population(x::PopObj; listall::Bool = false) : x is a variable of type PopObj listall is a variable of type Bool (boolean) meaning it only takes true or false without quotes, and the default value is set to false .","title":"Type information"},{"location":"juliaprimer/#type-unions","text":"You might see the type Union appear occasionally throughout this documentation, and you can consider it a list of allowable types. For example, if something was of type ::Union{String,Integer} , that means that either a String or Integer works.","title":"Type Unions"},{"location":"juliaprimer/#functions-vs-methods","text":"As part of Julia's type-safe paradigm and multiple dispatch (see \"ERROR: MethodError: no method matching\" below), type specifications in functions often reduce runtime of functions, but also establish function identity. Multiple dispatch refers to several different functions having the same name, but employing different methods depending on the input. In Julia, it's easier to write a single function with multiple type-safe methods, rather than one mega-function that accepts any type and have a bunch of if statements that determines what the program does depending on the input. In practice, this looks like: # combine two numbers julia> function add(x::Integer, y::Integer) x+y end add (generic function with 1 method) # combine two strings julia> function add(x::String, y::String) x*y end add (generic function with 2 methods) julia> add(1,2) 3 julia> add(\"water\", \"melon\") \"watermelon\" Multiple dispatch therefor leads to a unique type of possible error: the MethodError","title":"Functions vs. Methods"},{"location":"juliaprimer/#error-methoderror-no-method-matching","text":"Using the function add from the example above, let's have a look at what happens when we try to add an Integer with a String : julia > add ( 1 , \"melon\" ) ERROR : MethodError : no method matching add ( :: Int64 , :: String ) Closest candidates are : add ( :: String , :: String ) at none : 2 add ( :: Integer , :: Integer ) at none : 2 Stacktrace : [ 1 ] top - level scope at none : 0 This error is telling us \"there is no such function called add , who's inputs are an Integer followed by a String \". But, it does offer us some alternatives, like the two add functions we created earlier. The functions within PopGen are almost always explicitly typed, so if you are getting the MethodError: no method matching error, then you are inputting the incorrect types into the function, or perhaps your inputs for the arguments are in the wrong order (see \"Functions with and without keywords\" below). Sometimes you might include an argument with a keyword when there isn't one, or include an argument without a keyword when there needs to be one (honestly, we make that mistake too and we wrote this stuff). To help minimize those mistakes, please read below about which arguments have keywords and which don't. MethodError's can definitely get annoying, but they are usually the result of incorrect input from the user and not buggy programming by the developers. Please double-check your inputs before assuming something is broken or bugged.","title":"ERROR: MethodError: no method matching"},{"location":"juliaprimer/#functions-with-and-without-keywords","text":"Let's talk about semicolons some more. TL;DR Reading these docs, pay attention to semicolons in the function argument lists. arguments before a semicolon have no keyword and follow an explicit order arguments after a semicolon have a keyword argument = value and their order doesn't matter MethodError: no methods matching is more likely an issue on your side and not on our side unless we accidentally forgot to export a function! or we typed a function incorrectly really, it's a coin flip who could be at fault Broadly speaking, there are two types of function declarations in Julia: ones with keywords and ones without keywords. The term \"keywords\" refers to an input argument that has the format argument = value . This format is present in many of the functions in this and other packages, however there are some specifics to understand when functions use keywords and when they don't.","title":"Functions with and without keywords"},{"location":"juliaprimer/#format-1-strict-argument-order-and-no-keywords-no-semicolon-in-argument-list","text":"function function_name ( var1 :: type , var2 :: type , var3 :: type ) do stuff with vars end If a function is declared with only commas in the argument list, like shown above, then the arguments to that function must have no keywords and follow the exact order they appear in. If the generic example above had the typing: function function_name ( var1 :: String , var2 :: Float64 , var3 :: Array { String , 1 }) do stuff with vars end then the only acceptable way to run this function without getting a MethodError would be with arguments in the order of function_name(String, Float64, Array{String,1}) . Even if some of the arguments have a default values, like var2::Float64 = 6.66 , the order of arguments/types has to be respected as declared.","title":"Format 1: Strict argument order and no keywords - No semicolon in argument list"},{"location":"juliaprimer/#format-2-semicolon-in-argument-list","text":"function function_name ( var1 :: type ; var2 :: type , var3 :: type ) do stuff with vars end In this format, everything that comes before the semicolon follows the strict rules from Format 1 , and everything that comes after the semicolon is a keyword argument. Keyword arguments have the flexibility to not require any particular input order. However, you must use the keywords to declare those arguments, or you will receive another MethodError: no method matching , which is, as we've mentioned, annoying.","title":"Format 2 - semicolon in argument list"},{"location":"logo_graveyard/","text":"What exactly that logo? If you haven't guessed already, it's the beloved Punnett Square! Nothing screams genetics like everyone's first entry-level genetic diagram! The Logo Graveyard While this is completely unrelated to anything important about population genetics or Julia, I (Pavel) want you all to understand the logo-development process that led us to our logo so you can feel my struggle. The process is as follows: Jason and Pavel spitball ideas Pavel procrastinates real work and opens up Inkscape to draft some ideas Pavel composes 1-3 versions of an idea and sends it to Jason if Jason != veto for i in 1:5 Jason critiques and suggests changes Pavel makes the changes end end Pavel and Jason finalize the idea! Weeks pass and Pavel isn't quite satisfied and we start at 1 again I'm happy to say that we love the Punnett Square and it's for keeps, but have a look at the scrapped ideas as a little walk down memory lane:","title":"Logo Graveyard"},{"location":"logo_graveyard/#what-exactly-that-logo","text":"If you haven't guessed already, it's the beloved Punnett Square! Nothing screams genetics like everyone's first entry-level genetic diagram!","title":"What exactly that logo?"},{"location":"logo_graveyard/#the-logo-graveyard","text":"While this is completely unrelated to anything important about population genetics or Julia, I (Pavel) want you all to understand the logo-development process that led us to our logo so you can feel my struggle. The process is as follows: Jason and Pavel spitball ideas Pavel procrastinates real work and opens up Inkscape to draft some ideas Pavel composes 1-3 versions of an idea and sends it to Jason if Jason != veto for i in 1:5 Jason critiques and suggests changes Pavel makes the changes end end Pavel and Jason finalize the idea! Weeks pass and Pavel isn't quite satisfied and we start at 1 again I'm happy to say that we love the Punnett Square and it's for keeps, but have a look at the scrapped ideas as a little walk down memory lane:","title":"The Logo Graveyard"},{"location":"popobj_type/","text":"For the PopGen.jl package to be consistent, a standard flexible data structure needs to be defined. The solution is a custom type called a PopObj . The struct is defined as: struct PopObj samples :: DataFrame loci :: DataFrame end pronouncing \"PopObj\" If you haven't already guessed, PopObj is a combination of the words PopGen and Object. PopObj is pronounced \"pop ob\" with a silent j because it rolls of the tongue better, but writing it as PopOb looks weird. Yes, I have lost sleep over this detail. - Pavel As you can see, a PopObj is made up of two dataframes, one for sample information, the other for genotype information. This structure allows for easy and convenient access to the fields using dot . accessors. avoid manual creation While it may seem simple enough to create two dataframes and make a PopObj out of them, the structure of samples and loci are specific, so small mistakes in creating them can create many errors and prevent PopGen from working correctly on your data. Please use the included csv , genepop , and vcf file importers instead. samples The samples dataframe has 5 specific categories: name, population, ploidy, latitude, longitude. samples.name ::Vector{String} The individual/sample names [ \"ind_001\" , \"ind_002\" , \"ind_003\" ] samples.population ::Vector{String} The individual/sample population ID's [ \"borneo\" , \"borneo\" , \"new jersey\" ] samples.ploidy ::Vector{Int8} The ploidy of the samples [ 2 , 2 , 2 ] samples.latitude ::Vector{Union{Missing,Float32}} latitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4] samples.longitude ::Vector{Union{Missing,Float64}} longitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4] loci The genotype information is stored in a separate dataframe called loci , where each column is named for the locus it represents. This makes for easy and obvious accessing by calling PopObj.loci.locusname . To view the loci names, use the convenient loci_names command. genotypes ::Vector{Tuple{Int16,...}} The genotypes of the loci are an array of tuples, with each value corresponding to an allele. The length of the tuple will vary based on the ploidy of the sample, and the type will vary whether the markers are snps or microsatellites, therefor the type shown above is conceptually accurate, but computationally incorrect. [(0,1),(0,0),(1,2)] We use the tuple type for genotypes of individuals because they are immutable (cannot be changed). By the time you're using PopGen.jl , your data should already be filtered and screened. Hand-editing of genotype values is strongly discouraged, so we outlawed it outright. viewing a PopObj Given the volume of information that can be present in a PopObj , we recommend summary() to summarize/overview the data rather than regurgitate everything on the screen. julia> a = gulfsharks() ; julia> summary(a) Object of type PopObj Marker type: SNP Ploidy: 2 Number of individuals: 212 Number of loci: 2213 Longitude: present with 0 missing Latitude: present with 0 missing Population names and counts: 7\u00d72 DataFrame \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 21 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 South Carolina \u2502 28 \u2502 \u2502 4 \u2502 Florida Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502 location data Location data is optional for a PopObj . There are functions that use location information (e.g. locations and plot_locations ), but most don't, so it's not a dealbreaker.","title":"What's a PopObj"},{"location":"popobj_type/#samples","text":"The samples dataframe has 5 specific categories: name, population, ploidy, latitude, longitude.","title":"samples"},{"location":"popobj_type/#samplesname","text":"::Vector{String} The individual/sample names [ \"ind_001\" , \"ind_002\" , \"ind_003\" ]","title":"samples.name"},{"location":"popobj_type/#samplespopulation","text":"::Vector{String} The individual/sample population ID's [ \"borneo\" , \"borneo\" , \"new jersey\" ]","title":"samples.population"},{"location":"popobj_type/#samplesploidy","text":"::Vector{Int8} The ploidy of the samples [ 2 , 2 , 2 ]","title":"samples.ploidy"},{"location":"popobj_type/#sampleslatitude","text":"::Vector{Union{Missing,Float32}} latitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4]","title":"samples.latitude"},{"location":"popobj_type/#sampleslongitude","text":"::Vector{Union{Missing,Float64}} longitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4]","title":"samples.longitude"},{"location":"popobj_type/#loci","text":"The genotype information is stored in a separate dataframe called loci , where each column is named for the locus it represents. This makes for easy and obvious accessing by calling PopObj.loci.locusname . To view the loci names, use the convenient loci_names command.","title":"loci"},{"location":"popobj_type/#genotypes","text":"::Vector{Tuple{Int16,...}} The genotypes of the loci are an array of tuples, with each value corresponding to an allele. The length of the tuple will vary based on the ploidy of the sample, and the type will vary whether the markers are snps or microsatellites, therefor the type shown above is conceptually accurate, but computationally incorrect. [(0,1),(0,0),(1,2)] We use the tuple type for genotypes of individuals because they are immutable (cannot be changed). By the time you're using PopGen.jl , your data should already be filtered and screened. Hand-editing of genotype values is strongly discouraged, so we outlawed it outright.","title":"genotypes"},{"location":"popobj_type/#viewing-a-popobj","text":"Given the volume of information that can be present in a PopObj , we recommend summary() to summarize/overview the data rather than regurgitate everything on the screen. julia> a = gulfsharks() ; julia> summary(a) Object of type PopObj Marker type: SNP Ploidy: 2 Number of individuals: 212 Number of loci: 2213 Longitude: present with 0 missing Latitude: present with 0 missing Population names and counts: 7\u00d72 DataFrame \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 21 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 South Carolina \u2502 28 \u2502 \u2502 4 \u2502 Florida Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502","title":"viewing a PopObj"},{"location":"popobj_type/#location-data","text":"Location data is optional for a PopObj . There are functions that use location information (e.g. locations and plot_locations ), but most don't, so it's not a dealbreaker.","title":"location data"},{"location":"relatedness/","text":"Background Sometimes you want or need to know the relatedness of individuals in a sample. Relatedness is exactly what its name implies: how related individuals are given some provided genetic information. Relatedness can be used in quantitative genetics to estimate heritability, additive genetic variances, and covariances. It can also be used in population genetics to study isolation-by-distance or population structure. The goal of calculating relatedness from molecular markers is to accurately estimate the proportion of the genome which is identical by descent between two individuals. With a pedigree this is \"relatively\" straightforward. However, for large, natural, populations pedigrees tend not to exist and so many brilliant minds have developed various equations and algorithms to estimate the relatedness from a set of molecular markers. Given two diploid individuals, there are 9 \"identity by descent\" models available between them ( Jacquard 1975 , paywall), as shown below (from Milligan 2003 ): Broadly speaking there are two different ways of estimating genetic relatedness using molecular markers, methods of moments, and likelihood estimators. Generally moments estimators will be faster but aren't constrained to being between the theoretical minimum and maximum values of 0 and 1. The likelihood estimators use likelihood functions derived from the set of Jacquard Identity States (above) to determine the most likely inheritance pattern. One difference between the two classes is [generally] moments estimators require an assumption of no inbreeding, while that assumption isn't necessarily required for likelihood estimators (though it does simplify the math). It is increasingly common to use multiple estimators on pairs, simulated from your molecular marker, with a known relationships to determine the most appropriate estimator to use with your given data. PopGen.jl currently implements one of each class of estimator. The moments based estimator developed by Queller & Goodnight 1989 using the variant defined by Lynch & Ritland 1999 and the likelihood estimator created by Milligan 2003 . You can imagine there's a lot that happens under the hood to perform this for all loci across all individuals-- all of which dutifully written by Jason Selwyn . About removing kin There are reasons for removing kin in population genetics datasets. For one, there are no siblings/kin or mixed-generations in a Hardy-Weinberg Equilibrium population, and the inclusion of siblings/kin in analyses that rely on HWE assumptions [technically] violate those assumptions. However, there are also arguments to keep kin/siblings in your data, those data are important for effective population size, linkage disequilibrium, etc. Waples and Anderson (2017) published a great perspective on the matter. Calculate Relatedness Calculate the relatedness of all pairs of individuals in the dataframe using either Milligan's Dyadic Maximum Likelihood estimator or Queller & Goodnight's estimator. pairwise_relatedness ( data :: PopObj ; method :: String , inbreeding :: Bool = true , verbose :: Bool = true ) arguments data : the input PopObj keyword arguments method : Method of relatedness estimation (see below) inbreeding : Include the possibility of inbreeding (true) or not (false) - Only used with method = \"dyadml\" verbose : If false only progress bar will be shown. If true extra output will be shown depending on the method chosen method methods \"dyadml\" : Milligan (2003) Dyadic Likelihood Relatedness \"qg\" : Queller & Goodnight (1989) Relatedness example relatedness cats = nancycats () ; pairwise_relatedness ( cats , method = \"qg\" , verbose = false ) output See Development for all of the APIs associated with relatedness() Speed Depending on the number samples and loci in your data, the maximum-likelihood approach to relatedness can be quite time consuming. We include a progress bar thanks to ProgressMeter.jl to provide some indication of how long it will take. As a point of reference, it takes approximately 13 hours to perform this relatedness calculation on the gulfsharks data (212 samples x 2213 loci). Currently, relatedness calculations run single-threaded, and we hope to parallelize it with the stable release of Julia 1.3 to make it even faster. Many hands make light work! Acknowledgements Both Convex.jl and ECOS.jl are pivotal for these calculations, and we thank the authors for their time developing and maintaining them, along with the members of the Julia Slack channel for pointing us towards those packages.","title":"Relatedness"},{"location":"relatedness/#background","text":"Sometimes you want or need to know the relatedness of individuals in a sample. Relatedness is exactly what its name implies: how related individuals are given some provided genetic information. Relatedness can be used in quantitative genetics to estimate heritability, additive genetic variances, and covariances. It can also be used in population genetics to study isolation-by-distance or population structure. The goal of calculating relatedness from molecular markers is to accurately estimate the proportion of the genome which is identical by descent between two individuals. With a pedigree this is \"relatively\" straightforward. However, for large, natural, populations pedigrees tend not to exist and so many brilliant minds have developed various equations and algorithms to estimate the relatedness from a set of molecular markers. Given two diploid individuals, there are 9 \"identity by descent\" models available between them ( Jacquard 1975 , paywall), as shown below (from Milligan 2003 ): Broadly speaking there are two different ways of estimating genetic relatedness using molecular markers, methods of moments, and likelihood estimators. Generally moments estimators will be faster but aren't constrained to being between the theoretical minimum and maximum values of 0 and 1. The likelihood estimators use likelihood functions derived from the set of Jacquard Identity States (above) to determine the most likely inheritance pattern. One difference between the two classes is [generally] moments estimators require an assumption of no inbreeding, while that assumption isn't necessarily required for likelihood estimators (though it does simplify the math). It is increasingly common to use multiple estimators on pairs, simulated from your molecular marker, with a known relationships to determine the most appropriate estimator to use with your given data. PopGen.jl currently implements one of each class of estimator. The moments based estimator developed by Queller & Goodnight 1989 using the variant defined by Lynch & Ritland 1999 and the likelihood estimator created by Milligan 2003 . You can imagine there's a lot that happens under the hood to perform this for all loci across all individuals-- all of which dutifully written by Jason Selwyn .","title":"Background"},{"location":"relatedness/#about-removing-kin","text":"There are reasons for removing kin in population genetics datasets. For one, there are no siblings/kin or mixed-generations in a Hardy-Weinberg Equilibrium population, and the inclusion of siblings/kin in analyses that rely on HWE assumptions [technically] violate those assumptions. However, there are also arguments to keep kin/siblings in your data, those data are important for effective population size, linkage disequilibrium, etc. Waples and Anderson (2017) published a great perspective on the matter.","title":"About removing kin"},{"location":"relatedness/#calculate-relatedness","text":"Calculate the relatedness of all pairs of individuals in the dataframe using either Milligan's Dyadic Maximum Likelihood estimator or Queller & Goodnight's estimator. pairwise_relatedness ( data :: PopObj ; method :: String , inbreeding :: Bool = true , verbose :: Bool = true )","title":"Calculate Relatedness"},{"location":"relatedness/#arguments","text":"data : the input PopObj","title":"arguments"},{"location":"relatedness/#keyword-arguments","text":"method : Method of relatedness estimation (see below) inbreeding : Include the possibility of inbreeding (true) or not (false) - Only used with method = \"dyadml\" verbose : If false only progress bar will be shown. If true extra output will be shown depending on the method chosen","title":"keyword arguments"},{"location":"relatedness/#method-methods","text":"\"dyadml\" : Milligan (2003) Dyadic Likelihood Relatedness \"qg\" : Queller & Goodnight (1989) Relatedness","title":"method methods"},{"location":"relatedness/#example","text":"relatedness cats = nancycats () ; pairwise_relatedness ( cats , method = \"qg\" , verbose = false ) output See Development for all of the APIs associated with relatedness()","title":"example"},{"location":"relatedness/#speed","text":"Depending on the number samples and loci in your data, the maximum-likelihood approach to relatedness can be quite time consuming. We include a progress bar thanks to ProgressMeter.jl to provide some indication of how long it will take. As a point of reference, it takes approximately 13 hours to perform this relatedness calculation on the gulfsharks data (212 samples x 2213 loci). Currently, relatedness calculations run single-threaded, and we hope to parallelize it with the stable release of Julia 1.3 to make it even faster. Many hands make light work!","title":"Speed"},{"location":"relatedness/#acknowledgements","text":"Both Convex.jl and ECOS.jl are pivotal for these calculations, and we thank the authors for their time developing and maintaining them, along with the members of the Julia Slack channel for pointing us towards those packages.","title":"Acknowledgements"},{"location":"vcf/","text":"Import a BCF/VCF file as a PopObj PopGen.jl provides a simple command vcf to import a VCF file as a PopObj , which requires only the name of the file and nothing else. potato = vcf ( \"/home/data/russet_potatoes.vcf\" ) and similar for bcf formatted files: cabbage = bcf ( \"/home/data/nappa_cabbage.bcf\" ) Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" What BCF/VCF files lack Due to the nature of the file format, importing variant call files will provide: sample names ploidy of each sample locus names genotypes but they will not provide: population information latitude or longitude This means you will need to add that information separately afterwards. Location data (which is optional!) can be added to the PopObj directly to .samples.latitude or .samples.longitude or with the locations! command. Population names (mandatory!) can be added using populations!() Format Variant Call Format (or VCF ) files already follow a format standard, and while there is some wiggle-room for optional values, PopGen.jl only requires the core/mandatory components of a VCF, meaning problems should hopefully not arise regardless of which variant caller you are using (although we use Freebayes ourselves). Please open an issue if they do, or reach out to us on the community Slack. Keep in mind, BCF/VCF files need to be filtered before importing them into PopGen.jl. There is no and will be no VCF-filtering functionality to this package, as it is outside of the purpose of PopGen.jl. Refer to vcftools and vcflib to filter your sequence data. Acknowledgements The majority of the BCF/VCF reader is thanks to the tremendous efforts of Ben J. Ward and the BioJulia contributors involved in GeneticVariation.jl , which we use to parse your files into PopObj format. If you love the file importer, then give those folks your thanks. If something is wrong and/or you hate the importer, blame us (and please open up an issue ).","title":"VCF"},{"location":"vcf/#import-a-bcfvcf-file-as-a-popobj","text":"PopGen.jl provides a simple command vcf to import a VCF file as a PopObj , which requires only the name of the file and nothing else. potato = vcf ( \"/home/data/russet_potatoes.vcf\" ) and similar for bcf formatted files: cabbage = bcf ( \"/home/data/nappa_cabbage.bcf\" ) Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\"","title":"Import a BCF/VCF file as a PopObj"},{"location":"vcf/#what-bcfvcf-files-lack","text":"Due to the nature of the file format, importing variant call files will provide: sample names ploidy of each sample locus names genotypes but they will not provide: population information latitude or longitude This means you will need to add that information separately afterwards. Location data (which is optional!) can be added to the PopObj directly to .samples.latitude or .samples.longitude or with the locations! command. Population names (mandatory!) can be added using populations!()","title":"What BCF/VCF files lack"},{"location":"vcf/#format","text":"Variant Call Format (or VCF ) files already follow a format standard, and while there is some wiggle-room for optional values, PopGen.jl only requires the core/mandatory components of a VCF, meaning problems should hopefully not arise regardless of which variant caller you are using (although we use Freebayes ourselves). Please open an issue if they do, or reach out to us on the community Slack. Keep in mind, BCF/VCF files need to be filtered before importing them into PopGen.jl. There is no and will be no VCF-filtering functionality to this package, as it is outside of the purpose of PopGen.jl. Refer to vcftools and vcflib to filter your sequence data.","title":"Format"},{"location":"vcf/#acknowledgements","text":"The majority of the BCF/VCF reader is thanks to the tremendous efforts of Ben J. Ward and the BioJulia contributors involved in GeneticVariation.jl , which we use to parse your files into PopObj format. If you love the file importer, then give those folks your thanks. If something is wrong and/or you hate the importer, blame us (and please open up an issue ).","title":"Acknowledgements"}]}