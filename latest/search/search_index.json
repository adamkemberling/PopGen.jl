{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This is the documentation for the PopGen.jl package. If you're here, you're likely interested in doing some kind of population genetics analyses. Please read through the docs and try the functions out with the test data to get a feel for what PopGen.jl can do. About PopGen.jl is an attempt to shift population genetics analyses away from the patchwork of available pop-gen packages present in the R and Python languages, and combine it with the speed, power, fun(?), and community of the Julia language. We hope to implement common analyses (heterozygosity, kinship, FST, Tajima's D, etc.) in sane , user friendly ways, with syntax used within the package being consistent with the rest of the Julia ecosystem. Goal To be a comprehensive package for population genetics analyses and visualization that's fast and user friendly. This project is developed with a particular mantra: Sanity, Sensibility, Accessibility . Sanity Functions are written in a way such that their use is sane and natural. When possible (or sensible), we use full words for input variables or other components of input/output. The first argument for all functions is the input data without keywords. Always. If a function has a very obvious name, then it likely it won't need keyword arguments, such as exclude_loci , where it would be silly to have a keyword loci= since the name is explicit about what it does and the first argument is always the input data. Sensibility Functions need to be sensible, both in what they do and how they do it. This means they should include only the most relevant arguments, and the most sensible defaults. It also means the outputs need to be flexible enough to use with other Julia packages, such as Query.jl , or Plots . Accessibility Documentation is everything! Julia is a comparatively young language, and we know which languages and packages other population geneticists are using for their work. We want you to be comfortable using PopGen.jl, and that means investing a lot of time into writing thorough documentation intended for users (vs developers). We also recognize that you (the reader) might not be very familiar with Julia, which is ok(!), so we've written a section on clarifying some Julia concepts/conventions that will make reading this documentation a whole lot clearer. It is by no means a replacement for sitting down and learning the Julia language a bit ( here is a great online book on that ), but it should hopefully reduce the barrier of entry somewhat. Why Julia (and not Python or R)? Speed and syntax The speed is comparable to C when coded correctly. Also, has Python-like syntax with optional tabs. We are also fans of 1-indexing, but that's more of a perk. Not convinced? Check out our comparison benchmarks . A modern language for modern problems Julia has native support for: parallelization, distributed computing, GPU processing, and pipes! It also has robust machine learning packages (maybe for future work). Community & contribution Julia's internals solve what's know as the \"two language problem\". That is, languages that are easy to write in (e.g. Python, R, Ruby) are slow compared to languages that are more difficult to write in, which are fast (e.g. C, C++, Fortran). For languages that are easier to write in, many of the commonly used packages and functions in those languages are written in another, faster language under the hood for performance reasons. On the whole, that's not really a problem for end-users, because things work and they are easy to use. But , it does become a problem when you want to investigate the code and implementation of a function. This means that, even as an R power-user, you are kind of helpless to investigate the implementation of something you are using in R if it's actually written in C++ under the hood. In a sense, it makes the publications of those methods less reproducible, because the users of it may be familiar with the language it's deployed in (like R), but not the language it's written in, (like C++). What if there are bugs?! What if the code implementation doesn't match the formulations in the publication?! Yikes! So, if we write everything in Julia, and you use everything in Julia, users can themselves diagnose these things if they so choose. This means users can contribute to the overall health and accuracy of this package. Yes, that means that we might be getting more Issues opened up, but a bug found is a lot better than a bug overlooked! Like most Julia packages, PopGen.jl is written entirely in Julia, meaning the community using it need not learn another language if they wanted to contribute! Have you written a clever Julia function to calculate SAMOVA from a PopObj ? Send us a pull request (please!)! Or join the Slack! Package manager Which, let's be honest, is such a delight to use. Installing PopGen.jl should be simple, consistent, and effortless thanks to the brilliant built-in package manager in Julia. Authors Pavel Dimens, PhD Student @ U. Southern Mississippi Jason Selwyn, PhD Candidate @ Texas A&M University - Corpus Christi","title":"Home"},{"location":"#about","text":"PopGen.jl is an attempt to shift population genetics analyses away from the patchwork of available pop-gen packages present in the R and Python languages, and combine it with the speed, power, fun(?), and community of the Julia language. We hope to implement common analyses (heterozygosity, kinship, FST, Tajima's D, etc.) in sane , user friendly ways, with syntax used within the package being consistent with the rest of the Julia ecosystem.","title":"About"},{"location":"#goal","text":"To be a comprehensive package for population genetics analyses and visualization that's fast and user friendly. This project is developed with a particular mantra: Sanity, Sensibility, Accessibility . Sanity Functions are written in a way such that their use is sane and natural. When possible (or sensible), we use full words for input variables or other components of input/output. The first argument for all functions is the input data without keywords. Always. If a function has a very obvious name, then it likely it won't need keyword arguments, such as exclude_loci , where it would be silly to have a keyword loci= since the name is explicit about what it does and the first argument is always the input data. Sensibility Functions need to be sensible, both in what they do and how they do it. This means they should include only the most relevant arguments, and the most sensible defaults. It also means the outputs need to be flexible enough to use with other Julia packages, such as Query.jl , or Plots . Accessibility Documentation is everything! Julia is a comparatively young language, and we know which languages and packages other population geneticists are using for their work. We want you to be comfortable using PopGen.jl, and that means investing a lot of time into writing thorough documentation intended for users (vs developers). We also recognize that you (the reader) might not be very familiar with Julia, which is ok(!), so we've written a section on clarifying some Julia concepts/conventions that will make reading this documentation a whole lot clearer. It is by no means a replacement for sitting down and learning the Julia language a bit ( here is a great online book on that ), but it should hopefully reduce the barrier of entry somewhat.","title":"Goal"},{"location":"#why-julia-and-not-python-or-r","text":"","title":"Why Julia (and not Python or R)?"},{"location":"#speed-and-syntax","text":"The speed is comparable to C when coded correctly. Also, has Python-like syntax with optional tabs. We are also fans of 1-indexing, but that's more of a perk. Not convinced? Check out our comparison benchmarks .","title":"Speed and syntax"},{"location":"#a-modern-language-for-modern-problems","text":"Julia has native support for: parallelization, distributed computing, GPU processing, and pipes! It also has robust machine learning packages (maybe for future work).","title":"A modern language for modern problems"},{"location":"#community-contribution","text":"Julia's internals solve what's know as the \"two language problem\". That is, languages that are easy to write in (e.g. Python, R, Ruby) are slow compared to languages that are more difficult to write in, which are fast (e.g. C, C++, Fortran). For languages that are easier to write in, many of the commonly used packages and functions in those languages are written in another, faster language under the hood for performance reasons. On the whole, that's not really a problem for end-users, because things work and they are easy to use. But , it does become a problem when you want to investigate the code and implementation of a function. This means that, even as an R power-user, you are kind of helpless to investigate the implementation of something you are using in R if it's actually written in C++ under the hood. In a sense, it makes the publications of those methods less reproducible, because the users of it may be familiar with the language it's deployed in (like R), but not the language it's written in, (like C++). What if there are bugs?! What if the code implementation doesn't match the formulations in the publication?! Yikes! So, if we write everything in Julia, and you use everything in Julia, users can themselves diagnose these things if they so choose. This means users can contribute to the overall health and accuracy of this package. Yes, that means that we might be getting more Issues opened up, but a bug found is a lot better than a bug overlooked! Like most Julia packages, PopGen.jl is written entirely in Julia, meaning the community using it need not learn another language if they wanted to contribute! Have you written a clever Julia function to calculate SAMOVA from a PopObj ? Send us a pull request (please!)! Or join the Slack!","title":"Community &amp; contribution"},{"location":"#package-manager","text":"Which, let's be honest, is such a delight to use. Installing PopGen.jl should be simple, consistent, and effortless thanks to the brilliant built-in package manager in Julia.","title":"Package manager"},{"location":"#authors","text":"Pavel Dimens, PhD Student @ U. Southern Mississippi Jason Selwyn, PhD Candidate @ Texas A&M University - Corpus Christi","title":"Authors"},{"location":"commands/","text":"These are the included PopData inspecting and manipulating commands. Using standard Julia conventions, only commands ending with a bang ! are mutable, meaning they alter the input data. So, commands like populations will show you population information, whereas populations! will change that information in your PopData . The mutable commands here alter the data in your PopData , but not the source data (i.e. the files used to create the PopData ). Read over Accessing parts of PopDataj to become familiar with the components of PopData . To follow along like a tutorial, use the gulfsharks data. Load the data in if you haven't already: julia > using PopGen julia > sharks = gulfsharks () ; Sorting reindex ( data :: PopData , col :: Union { String , Symbol }) By default, the loci table of PopData is sorted by the name column. For performance or convenience reasons, you can sort it using any column you want. This will sort the loci table of a PopData object by column col and return new PopData object, keeping the original intact. The column names can be Strings or Symbols. Example: sorted_sharks = reindex ( sharks , : population ) Individuals / Samples view individuals' names samples ( data :: PopObj ) View individual/sample names in a PopObj . This is equivalent to PopObj.samples.name indnames samples ( sharks ) output 212-element Array{String,1}: \"cc_001\" \"cc_002\" \"cc_003\" \"cc_005\" \"cc_007\" \"cc_008\" \"cc_009\" \"cc_010\" \"cc_012\" \"cc_013\" \u22ee \"seg_023\" \"seg_024\" \"seg_025\" \"seg_026\" \"seg_027\" \"seg_028\" \"seg_029\" \"seg_030\" \"seg_031\" Population ID's view population names populations ( data :: PopData ; listall :: Bool = false ) Just as you can view population ID's with .population , you can also view them with the populations command, which by default shows you a summary of the number of individuals in each population. populations julia > populations ( sharks ) output Table with 7 rows, 2 columns: population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Cape Canaveral\" 21 \"Florida Keys\" 65 \"Georgia\" 30 \"Mideast Gulf\" 28 \"Northeast Gulf\" 20 \"South Carolina\" 28 \"Southeast Gulf\" 20 You can use the keyword listall=true to display each individual and their associated population as a table. listall=true julia > populations ( sharks , listall = true ) output Table with 212 rows, 2 columns: name population \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"cc_002\" \"Cape Canaveral\" \"cc_003\" \"Cape Canaveral\" \"cc_005\" \"Cape Canaveral\" \"cc_007\" \"Cape Canaveral\" \"cc_008\" \"Cape Canaveral\" \"cc_009\" \"Cape Canaveral\" \"cc_010\" \"Cape Canaveral\" \u22ee \"seg_026\" \"Southeast Gulf\" \"seg_027\" \"Southeast Gulf\" \"seg_028\" \"Southeast Gulf\" \"seg_029\" \"Southeast Gulf\" \"seg_030\" \"Southeast Gulf\" \"seg_031\" \"Southeast Gulf\" synonymous functions You can use the command population for the same functionality. We made the commands population and populations synonymous so you wouldn't have to memorize if the name was singular or plural-- it just works! This also applies to populations! and population! rename populations There are a handful of methods to alter PopData population names depending on what you find most convenient. Each of these methods start with populations!() and vary in their inputs. It's for that reason this function has an obnoxiously long docstring. For simplicity, the methods will be separated into categories. However, all the methods for populations! are unified in that they edit PopData in place, and print (rather than return) a table of the new population names and counts courtesy of populations() . replace by matching using a Dictionary populations! ( data :: PopData , rename :: Dict ) Rename existing population ID's of PopData using a Dict of population_name => replacement . rename populations # create a dictionary of name conversions julia > new_popnames = Dict ( \"Cape Canaveral\" => \"Atlantic\" , \"Georgia\" => \"Atlantic\" , \"South Carolina\" => \"Atlantic\" , \"Florida Keys\" => \"Gulf\" , \"Mideast Gulf\" => \"Gulf\" , \"Northeast Gulf\" => \"Gulf\" , \"Southeast Gulf\" => \"Gulf\" ); julia > populations! ( sharks , new_popnames ) Table with 2 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Atlantic\" 79 \"Gulf\" 133 using a Vector of names Vector of new unique population names in the order that they appear in the PopData.meta . julia > new_popnames = [ \"Atlantic\" , \"Atlantic\" , \"Atlantic\" , \"Gulf\" , \"Gulf\" , \"Gulf\" , \"Gulf\" ] julia > populations! ( sharks , new_popnames ) Table with 2 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Atlantic\" 79 \"Gulf\" 133 using a Vector of oldnames and new names Similar to the Dict method, except instead of creating a dictionary of \"oldname\" => \"newname\", you input a Vector{String} of oldnames followed by another of newnames . Logically, the new names will replace the old names in the same order as they appear in PopData.meta (e.g. the first newname replaces the first oldname, etc.). julia > old_pop = [ \"Cape Canaveral\" , \"Florida Keys\" , \"Georgia\" , \"Mideast Gulf\" , \"Northeast Gulf\" , \"South Carolina\" , \"Southeast Gulf\" ] ; julia > new_pop = [ \"Atlantic\" , \"Gulf\" , \"Atlantic\" , \"Gulf\" , \"Gulf\" , \"Atlantic\" , \"Gulf\" ] ; julia > populations ( sharks , old_pop , new_pop ) Table with 2 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Atlantic\" 79 \"Gulf\" 133 generate new population information You may want outright overwrite all current population information. This is particularly useful when importing from VCF format when population information is not provided. This method will completely replace the population names of PopData regardless of what they currently are. Double-check your population counts If you're playing along and getting errors that the lengths don't match, then get make sure you're using the right population counts. You can get those numbers with populations(sharks) . counts = [ 21 , 65 , 30 , 28 , 20 , 28 , 20 ] and we then also create the vector of the names in the order in which they appear: popnames = [ \"Cape Canaveral\" , \"Florida Keys\" , \"Georgia\" , \"Mideast Gulf\" , \"Northeast Gulf\" , \"South Carolina\" , \"Southeast Gulf\" ] Now we can combine them with populations! to restore the population names to how they were originally: using a NamedTuple replace populations julia > populations! ( sharks , ( counts = counts , names = popnames )) Table with 7 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Cape Canaveral\" 21 \"Florida Keys\" 65 \"Georgia\" 30 \"Mideast Gulf\" 28 \"Northeast Gulf\" 20 \"South Carolina\" 28 \"Southeast Gulf\" 20 using a Vector of names and a Vector of counts This is just about the same as using the NamedTuple , but perhaps some users will prefer this format. julia > populations! ( sharks , popnames , counts ) Table with 7 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Cape Canaveral\" 21 \"Florida Keys\" 65 \"Georgia\" 30 \"Mideast Gulf\" 28 \"Northeast Gulf\" 20 \"South Carolina\" 28 \"Southeast Gulf\" 20 Display Specific Loci and/or Samples These are the \"public\" functions to retrieve sample genotype information in an easy-on-the-eyes format, whereas calculations in other parts of PopGen.jl use much more barebones functions under the hood suitable for high-throughput programming. get loci names loci ( data :: PopData ) Returns a vector of strings of the loci names in a PopData example julia > loci ( sharks ) output 2213-element Array{String,1}: \"contig_35208\" \"contig_23109\" \"contig_4493\" \"contig_10742\" \"contig_14898\" \"contig_8483\" \"contig_8065\" \"contig_14708\" \"contig_2307\" \u22ee \"contig_24711\" \"contig_18959\" \"contig_43517\" \"contig_27356\" \"contig_475\" \"contig_19384\" \"contig_22368\" \"contig_2784\" view genotypes at a locus locus ( data :: PopData , locus :: String ) Default shows all genotypes for all individuals. Returns a Vector. all loci julia > locus ( sharks , \"contig_2784\" ) output 212-element view(::Array{Union{Missing, Tuple{Int8,Int8}},1}, [2213, 4426, 6639, 8852, 11065, 13278, 15491, 17704, 19917, 22130 \u2026 449239, 451452, 453665, 455878, 458091, 460304, 462517, 464730, 466943, 469156]) with eltype Union{Missing, Tuple{Int8,Int8}}: (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) \u22ee (1, 1) (1, 1) (1, 1) (1, 1) missing (1, 1) (1, 1) (1, 1) returning a view The locus function gives a view into the genotype section of the loci table.. The text above the output is isn't anything to be worried about-- it's indicating you are looking at a view of a column of the table and that it's not returning a new vector. view samples (or anything) This can be done fairly easily using JuliaDBMeta macro @where single sample julia> @where sharks.loci :name == \"cc_001\" Table with 2213 rows, 4 columns: name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"contig_35208\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_23109\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_4493\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_10742\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14898\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_8483\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_8065\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14708\" (1, 1) \u22ee \"cc_001\" \"Cape Canaveral\" \"contig_43517\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_27356\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_475\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_19384\" (2, 2) \"cc_001\" \"Cape Canaveral\" \"contig_22368\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_2784\" (1, 1) multiple samples julia> @where sharks.loci :name in [\"cc_001\", \"cc_002\"] Table with 4426 rows, 4 columns: name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"contig_35208\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_23109\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_4493\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_10742\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14898\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_8483\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_8065\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14708\" (1, 1) \u22ee \"cc_002\" \"Cape Canaveral\" \"contig_43517\" (1, 1) \"cc_002\" \"Cape Canaveral\" \"contig_27356\" (1, 1) \"cc_002\" \"Cape Canaveral\" \"contig_475\" (1, 2) \"cc_002\" \"Cape Canaveral\" \"contig_19384\" (2, 2) \"cc_002\" \"Cape Canaveral\" \"contig_22368\" (1, 1) \"cc_002\" \"Cape Canaveral\" \"contig_2784\" (1, 1) It also means that you can combine different queries with \"and\" && and \"or\" || both name and locus julia > @where sharks . loci : name in [ \"cc_001\" , \"cc_002\" ] && : locus == \"contig_2784\" Table with 2 rows , 4 columns : name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"contig_2784\" ( 1 , 1 ) \"cc_002\" \"Cape Canaveral\" \"contig_2784\" ( 1 , 1 ) locus not found! If removing a single locus and it is not found in the PopObj, an error will be returned. However, if removing multiple loci, you will receive a notice above the PopObj summary indicating which loci were not found, while removing the ones that were. If none of the loci specified were found, it will return an error. Missing Data view missing data missing ( data :: PopData ; mode :: String = \"sample\" ) Get missing genotype information in a PopData . Specify a mode of operation to return a DataFrame corresponding with that missing information type. mode alternative name what it does \"sample\" \"individual\" returns a count and list of missing loci per individual (default) \"pop\" \"population\" returns a count of missing genotypes per population \"locus\" \"loci\" returns a count of missing genotypes per locus \"full\" \"detailed\" returns a count of missing genotypes per locus per population sample julia> missing(sharks) Table with 212 rows, 2 columns: name missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" 124 \"cc_002\" 94 \"cc_003\" 100 \"cc_005\" 0 \"cc_007\" 2 \"cc_008\" 1 \"cc_009\" 2 \"cc_010\" 1 \u22ee \"seg_026\" 0 \"seg_027\" 2 \"seg_028\" 25 \"seg_029\" 0 \"seg_030\" 1 \"seg_031\" 1 pop julia> missing(sharks, mode = \"pop\") Table with 7 rows, 2 columns: population missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Florida Keys\" 782 \"Cape Canaveral\" 666 \"Mideast Gulf\" 379 \"Georgia\" 744 \"Northeast Gulf\" 93 \"Southeast Gulf\" 1504 \"South Carolina\" 480 locus julia> missing(sharks, mode = \"locus\") Table with 2213 rows, 2 columns: locus missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"contig_35208\" 0 \"contig_23109\" 6 \"contig_4493\" 3 \"contig_10742\" 2 \"contig_14898\" 0 \"contig_8483\" 0 \"contig_8065\" 0 \"contig_14708\" 1 \u22ee \"contig_43517\" 6 \"contig_27356\" 2 \"contig_475\" 0 \"contig_19384\" 5 \"contig_22368\" 3 \"contig_2784\" 7 full julia> missing(sharks, mode = \"full\") Table with 15491 rows, 3 columns: locus population missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"contig_35208\" \"Florida Keys\" 0 \"contig_35208\" \"Cape Canaveral\" 0 \"contig_35208\" \"Mideast Gulf\" 0 \"contig_35208\" \"Georgia\" 0 \"contig_35208\" \"Northeast Gulf\" 0 \"contig_35208\" \"Southeast Gulf\" 0 \"contig_35208\" \"South Carolina\" 0 \"contig_23109\" \"Florida Keys\" 0 \u22ee \"contig_2784\" \"Cape Canaveral\" 0 \"contig_2784\" \"Mideast Gulf\" 1 \"contig_2784\" \"Georgia\" 1 \"contig_2784\" \"Northeast Gulf\" 1 \"contig_2784\" \"Southeast Gulf\" 1 \"contig_2784\" \"South Carolina\" 0 alternative names Each mode has an extra synonymous (alternative) name just because we can and want you to have the option of more explicitly legible code. If you get the mode wrong, it will let you know with an error message and run the default \"sample\" mode anyway. Location Data view location data locations ( data :: PopData ) View location data ( .longitude and .latitude ) in a PopData , returning a table the longitude and latitude information in meta . locations julia > locations ( sharks ) output Table with 212 rows, 2 columns: longitude latitude \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 28.3062 -80.5993 28.3079 -80.5995 28.3023 -80.5996 28.6123 -80.4225 27.8666 -80.3578 27.8666 -80.3579 27.8682 -80.3482 27.8711 -80.3482 \u22ee 30.0696 -86.5376 29.9065 -86.0905 30.0532 -87.3661 30.0522 -87.3662 29.8234 -85.7143 29.8234 -85.7143 Add location data Location data can be added using one of the methods of locations! . As indicated by the bang ! , your PopData will be edited in place, and there will be no return output. If your data is in Decimal Minutes format, this function will convert your long/lat into Decimal Degrees. To import those data into Julia, you'll likely want to use the wonderful CSV.jl package first. Decimal Degrees : -11.431 Decimal Minutes : -11 43.11 (notice the space) Your data must use the minus sign - (if appropriate) instead of cardinal directions. 11 43.11W is not valid. There are three main ways of adding location data: If already in decimal degrees locations! ( data :: PopObj , long :: Vector { T }, lat :: Vector { T }) where T <: AbstractFloat This method is pretty straightforward, and it tolerates vectors with missing data. # generate some fake location data julia > long = rand ( 212 ) .* 10 ; lat = rand ( 212 ) .* - 10 julia > locations! ( sharks , long , lat ) If in decimal minutes There are two options here, the first is to input two vectors of strings, like: lat = [ \"11 44.31\" , \"-25 41.94\" ] long = [ \"-43 54.11\" , \"22 23.11\" ] For this, the method is locations! ( data :: PopData ; lat :: Vector { String }, long :: Vector { String }) which uses the lat and long keywords. This method tolerates missing values, but you will need to replace! the string \"missing\" with values of missing . Or, you can input four vectors of numbers with the associated keyword arguments: Input Type Keyword Argument Vector of longitude degrees Integer long_deg Vector of longitude minutes Float long_min Vector of latitude degrees Integer lat_deg Vector of latitude minutes Float lat_min This method is easier or more tedious depending on what you consider a more practical approach. For example, if you have decimal-minutes coordinates for two samples: Longitude Latitude Sample 1 11 43.12 15 36.53 Sample 2 -12 41.32 11 22.41 then your inputs would be: lo_deg = [11, -12] lo_min = [43.12, 41.32] la_deg = [15, 11] la_min = [36.53, 22.41] and you would then use locations! like this: locations! ( data , long_deg = lo_deg , long_min = lo_min , lat_deg = la_deg , lat_min = la_min )","title":"Commands"},{"location":"commands/#sorting","text":"reindex ( data :: PopData , col :: Union { String , Symbol }) By default, the loci table of PopData is sorted by the name column. For performance or convenience reasons, you can sort it using any column you want. This will sort the loci table of a PopData object by column col and return new PopData object, keeping the original intact. The column names can be Strings or Symbols. Example: sorted_sharks = reindex ( sharks , : population )","title":"Sorting"},{"location":"commands/#individuals-samples","text":"","title":"Individuals / Samples"},{"location":"commands/#view-individuals-names","text":"samples ( data :: PopObj ) View individual/sample names in a PopObj . This is equivalent to PopObj.samples.name indnames samples ( sharks ) output 212-element Array{String,1}: \"cc_001\" \"cc_002\" \"cc_003\" \"cc_005\" \"cc_007\" \"cc_008\" \"cc_009\" \"cc_010\" \"cc_012\" \"cc_013\" \u22ee \"seg_023\" \"seg_024\" \"seg_025\" \"seg_026\" \"seg_027\" \"seg_028\" \"seg_029\" \"seg_030\" \"seg_031\"","title":"view individuals' names"},{"location":"commands/#population-ids","text":"","title":"Population ID's"},{"location":"commands/#view-population-names","text":"populations ( data :: PopData ; listall :: Bool = false ) Just as you can view population ID's with .population , you can also view them with the populations command, which by default shows you a summary of the number of individuals in each population. populations julia > populations ( sharks ) output Table with 7 rows, 2 columns: population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Cape Canaveral\" 21 \"Florida Keys\" 65 \"Georgia\" 30 \"Mideast Gulf\" 28 \"Northeast Gulf\" 20 \"South Carolina\" 28 \"Southeast Gulf\" 20 You can use the keyword listall=true to display each individual and their associated population as a table. listall=true julia > populations ( sharks , listall = true ) output Table with 212 rows, 2 columns: name population \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"cc_002\" \"Cape Canaveral\" \"cc_003\" \"Cape Canaveral\" \"cc_005\" \"Cape Canaveral\" \"cc_007\" \"Cape Canaveral\" \"cc_008\" \"Cape Canaveral\" \"cc_009\" \"Cape Canaveral\" \"cc_010\" \"Cape Canaveral\" \u22ee \"seg_026\" \"Southeast Gulf\" \"seg_027\" \"Southeast Gulf\" \"seg_028\" \"Southeast Gulf\" \"seg_029\" \"Southeast Gulf\" \"seg_030\" \"Southeast Gulf\" \"seg_031\" \"Southeast Gulf\" synonymous functions You can use the command population for the same functionality. We made the commands population and populations synonymous so you wouldn't have to memorize if the name was singular or plural-- it just works! This also applies to populations! and population!","title":"view population names"},{"location":"commands/#rename-populations","text":"There are a handful of methods to alter PopData population names depending on what you find most convenient. Each of these methods start with populations!() and vary in their inputs. It's for that reason this function has an obnoxiously long docstring. For simplicity, the methods will be separated into categories. However, all the methods for populations! are unified in that they edit PopData in place, and print (rather than return) a table of the new population names and counts courtesy of populations() .","title":"rename populations"},{"location":"commands/#replace-by-matching","text":"","title":"replace by matching"},{"location":"commands/#using-a-dictionary","text":"populations! ( data :: PopData , rename :: Dict ) Rename existing population ID's of PopData using a Dict of population_name => replacement . rename populations # create a dictionary of name conversions julia > new_popnames = Dict ( \"Cape Canaveral\" => \"Atlantic\" , \"Georgia\" => \"Atlantic\" , \"South Carolina\" => \"Atlantic\" , \"Florida Keys\" => \"Gulf\" , \"Mideast Gulf\" => \"Gulf\" , \"Northeast Gulf\" => \"Gulf\" , \"Southeast Gulf\" => \"Gulf\" ); julia > populations! ( sharks , new_popnames ) Table with 2 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Atlantic\" 79 \"Gulf\" 133","title":"using a Dictionary"},{"location":"commands/#using-a-vector-of-names","text":"Vector of new unique population names in the order that they appear in the PopData.meta . julia > new_popnames = [ \"Atlantic\" , \"Atlantic\" , \"Atlantic\" , \"Gulf\" , \"Gulf\" , \"Gulf\" , \"Gulf\" ] julia > populations! ( sharks , new_popnames ) Table with 2 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Atlantic\" 79 \"Gulf\" 133","title":"using a Vector of names"},{"location":"commands/#using-a-vector-of-oldnames-and-new-names","text":"Similar to the Dict method, except instead of creating a dictionary of \"oldname\" => \"newname\", you input a Vector{String} of oldnames followed by another of newnames . Logically, the new names will replace the old names in the same order as they appear in PopData.meta (e.g. the first newname replaces the first oldname, etc.). julia > old_pop = [ \"Cape Canaveral\" , \"Florida Keys\" , \"Georgia\" , \"Mideast Gulf\" , \"Northeast Gulf\" , \"South Carolina\" , \"Southeast Gulf\" ] ; julia > new_pop = [ \"Atlantic\" , \"Gulf\" , \"Atlantic\" , \"Gulf\" , \"Gulf\" , \"Atlantic\" , \"Gulf\" ] ; julia > populations ( sharks , old_pop , new_pop ) Table with 2 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Atlantic\" 79 \"Gulf\" 133","title":"using a Vector of oldnames and new names"},{"location":"commands/#generate-new-population-information","text":"You may want outright overwrite all current population information. This is particularly useful when importing from VCF format when population information is not provided. This method will completely replace the population names of PopData regardless of what they currently are. Double-check your population counts If you're playing along and getting errors that the lengths don't match, then get make sure you're using the right population counts. You can get those numbers with populations(sharks) . counts = [ 21 , 65 , 30 , 28 , 20 , 28 , 20 ] and we then also create the vector of the names in the order in which they appear: popnames = [ \"Cape Canaveral\" , \"Florida Keys\" , \"Georgia\" , \"Mideast Gulf\" , \"Northeast Gulf\" , \"South Carolina\" , \"Southeast Gulf\" ] Now we can combine them with populations! to restore the population names to how they were originally:","title":"generate new population information"},{"location":"commands/#using-a-namedtuple","text":"replace populations julia > populations! ( sharks , ( counts = counts , names = popnames )) Table with 7 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Cape Canaveral\" 21 \"Florida Keys\" 65 \"Georgia\" 30 \"Mideast Gulf\" 28 \"Northeast Gulf\" 20 \"South Carolina\" 28 \"Southeast Gulf\" 20","title":"using a NamedTuple"},{"location":"commands/#using-a-vector-of-names-and-a-vector-of-counts","text":"This is just about the same as using the NamedTuple , but perhaps some users will prefer this format. julia > populations! ( sharks , popnames , counts ) Table with 7 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Cape Canaveral\" 21 \"Florida Keys\" 65 \"Georgia\" 30 \"Mideast Gulf\" 28 \"Northeast Gulf\" 20 \"South Carolina\" 28 \"Southeast Gulf\" 20","title":"using a Vector of names and a Vector of counts"},{"location":"commands/#display-specific-loci-andor-samples","text":"These are the \"public\" functions to retrieve sample genotype information in an easy-on-the-eyes format, whereas calculations in other parts of PopGen.jl use much more barebones functions under the hood suitable for high-throughput programming.","title":"Display Specific Loci and/or Samples"},{"location":"commands/#get-loci-names","text":"loci ( data :: PopData ) Returns a vector of strings of the loci names in a PopData example julia > loci ( sharks ) output 2213-element Array{String,1}: \"contig_35208\" \"contig_23109\" \"contig_4493\" \"contig_10742\" \"contig_14898\" \"contig_8483\" \"contig_8065\" \"contig_14708\" \"contig_2307\" \u22ee \"contig_24711\" \"contig_18959\" \"contig_43517\" \"contig_27356\" \"contig_475\" \"contig_19384\" \"contig_22368\" \"contig_2784\"","title":"get loci names"},{"location":"commands/#view-genotypes-at-a-locus","text":"locus ( data :: PopData , locus :: String ) Default shows all genotypes for all individuals. Returns a Vector. all loci julia > locus ( sharks , \"contig_2784\" ) output 212-element view(::Array{Union{Missing, Tuple{Int8,Int8}},1}, [2213, 4426, 6639, 8852, 11065, 13278, 15491, 17704, 19917, 22130 \u2026 449239, 451452, 453665, 455878, 458091, 460304, 462517, 464730, 466943, 469156]) with eltype Union{Missing, Tuple{Int8,Int8}}: (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) \u22ee (1, 1) (1, 1) (1, 1) (1, 1) missing (1, 1) (1, 1) (1, 1) returning a view The locus function gives a view into the genotype section of the loci table.. The text above the output is isn't anything to be worried about-- it's indicating you are looking at a view of a column of the table and that it's not returning a new vector.","title":"view genotypes at a locus"},{"location":"commands/#view-samples-or-anything","text":"This can be done fairly easily using JuliaDBMeta macro @where single sample julia> @where sharks.loci :name == \"cc_001\" Table with 2213 rows, 4 columns: name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"contig_35208\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_23109\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_4493\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_10742\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14898\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_8483\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_8065\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14708\" (1, 1) \u22ee \"cc_001\" \"Cape Canaveral\" \"contig_43517\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_27356\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_475\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_19384\" (2, 2) \"cc_001\" \"Cape Canaveral\" \"contig_22368\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_2784\" (1, 1) multiple samples julia> @where sharks.loci :name in [\"cc_001\", \"cc_002\"] Table with 4426 rows, 4 columns: name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"contig_35208\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_23109\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_4493\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_10742\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14898\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_8483\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_8065\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14708\" (1, 1) \u22ee \"cc_002\" \"Cape Canaveral\" \"contig_43517\" (1, 1) \"cc_002\" \"Cape Canaveral\" \"contig_27356\" (1, 1) \"cc_002\" \"Cape Canaveral\" \"contig_475\" (1, 2) \"cc_002\" \"Cape Canaveral\" \"contig_19384\" (2, 2) \"cc_002\" \"Cape Canaveral\" \"contig_22368\" (1, 1) \"cc_002\" \"Cape Canaveral\" \"contig_2784\" (1, 1) It also means that you can combine different queries with \"and\" && and \"or\" || both name and locus julia > @where sharks . loci : name in [ \"cc_001\" , \"cc_002\" ] && : locus == \"contig_2784\" Table with 2 rows , 4 columns : name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"contig_2784\" ( 1 , 1 ) \"cc_002\" \"Cape Canaveral\" \"contig_2784\" ( 1 , 1 ) locus not found! If removing a single locus and it is not found in the PopObj, an error will be returned. However, if removing multiple loci, you will receive a notice above the PopObj summary indicating which loci were not found, while removing the ones that were. If none of the loci specified were found, it will return an error.","title":"view samples (or anything)"},{"location":"commands/#missing-data","text":"","title":"Missing Data"},{"location":"commands/#view-missing-data","text":"missing ( data :: PopData ; mode :: String = \"sample\" ) Get missing genotype information in a PopData . Specify a mode of operation to return a DataFrame corresponding with that missing information type. mode alternative name what it does \"sample\" \"individual\" returns a count and list of missing loci per individual (default) \"pop\" \"population\" returns a count of missing genotypes per population \"locus\" \"loci\" returns a count of missing genotypes per locus \"full\" \"detailed\" returns a count of missing genotypes per locus per population sample julia> missing(sharks) Table with 212 rows, 2 columns: name missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" 124 \"cc_002\" 94 \"cc_003\" 100 \"cc_005\" 0 \"cc_007\" 2 \"cc_008\" 1 \"cc_009\" 2 \"cc_010\" 1 \u22ee \"seg_026\" 0 \"seg_027\" 2 \"seg_028\" 25 \"seg_029\" 0 \"seg_030\" 1 \"seg_031\" 1 pop julia> missing(sharks, mode = \"pop\") Table with 7 rows, 2 columns: population missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Florida Keys\" 782 \"Cape Canaveral\" 666 \"Mideast Gulf\" 379 \"Georgia\" 744 \"Northeast Gulf\" 93 \"Southeast Gulf\" 1504 \"South Carolina\" 480 locus julia> missing(sharks, mode = \"locus\") Table with 2213 rows, 2 columns: locus missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"contig_35208\" 0 \"contig_23109\" 6 \"contig_4493\" 3 \"contig_10742\" 2 \"contig_14898\" 0 \"contig_8483\" 0 \"contig_8065\" 0 \"contig_14708\" 1 \u22ee \"contig_43517\" 6 \"contig_27356\" 2 \"contig_475\" 0 \"contig_19384\" 5 \"contig_22368\" 3 \"contig_2784\" 7 full julia> missing(sharks, mode = \"full\") Table with 15491 rows, 3 columns: locus population missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"contig_35208\" \"Florida Keys\" 0 \"contig_35208\" \"Cape Canaveral\" 0 \"contig_35208\" \"Mideast Gulf\" 0 \"contig_35208\" \"Georgia\" 0 \"contig_35208\" \"Northeast Gulf\" 0 \"contig_35208\" \"Southeast Gulf\" 0 \"contig_35208\" \"South Carolina\" 0 \"contig_23109\" \"Florida Keys\" 0 \u22ee \"contig_2784\" \"Cape Canaveral\" 0 \"contig_2784\" \"Mideast Gulf\" 1 \"contig_2784\" \"Georgia\" 1 \"contig_2784\" \"Northeast Gulf\" 1 \"contig_2784\" \"Southeast Gulf\" 1 \"contig_2784\" \"South Carolina\" 0 alternative names Each mode has an extra synonymous (alternative) name just because we can and want you to have the option of more explicitly legible code. If you get the mode wrong, it will let you know with an error message and run the default \"sample\" mode anyway.","title":"view missing data"},{"location":"commands/#location-data","text":"","title":"Location Data"},{"location":"commands/#view-location-data","text":"locations ( data :: PopData ) View location data ( .longitude and .latitude ) in a PopData , returning a table the longitude and latitude information in meta . locations julia > locations ( sharks ) output Table with 212 rows, 2 columns: longitude latitude \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 28.3062 -80.5993 28.3079 -80.5995 28.3023 -80.5996 28.6123 -80.4225 27.8666 -80.3578 27.8666 -80.3579 27.8682 -80.3482 27.8711 -80.3482 \u22ee 30.0696 -86.5376 29.9065 -86.0905 30.0532 -87.3661 30.0522 -87.3662 29.8234 -85.7143 29.8234 -85.7143","title":"view location data"},{"location":"commands/#add-location-data","text":"Location data can be added using one of the methods of locations! . As indicated by the bang ! , your PopData will be edited in place, and there will be no return output. If your data is in Decimal Minutes format, this function will convert your long/lat into Decimal Degrees. To import those data into Julia, you'll likely want to use the wonderful CSV.jl package first. Decimal Degrees : -11.431 Decimal Minutes : -11 43.11 (notice the space) Your data must use the minus sign - (if appropriate) instead of cardinal directions. 11 43.11W is not valid. There are three main ways of adding location data:","title":"Add location data"},{"location":"commands/#if-already-in-decimal-degrees","text":"locations! ( data :: PopObj , long :: Vector { T }, lat :: Vector { T }) where T <: AbstractFloat This method is pretty straightforward, and it tolerates vectors with missing data. # generate some fake location data julia > long = rand ( 212 ) .* 10 ; lat = rand ( 212 ) .* - 10 julia > locations! ( sharks , long , lat )","title":"If already in decimal degrees"},{"location":"commands/#if-in-decimal-minutes","text":"There are two options here, the first is to input two vectors of strings, like: lat = [ \"11 44.31\" , \"-25 41.94\" ] long = [ \"-43 54.11\" , \"22 23.11\" ] For this, the method is locations! ( data :: PopData ; lat :: Vector { String }, long :: Vector { String }) which uses the lat and long keywords. This method tolerates missing values, but you will need to replace! the string \"missing\" with values of missing . Or, you can input four vectors of numbers with the associated keyword arguments: Input Type Keyword Argument Vector of longitude degrees Integer long_deg Vector of longitude minutes Float long_min Vector of latitude degrees Integer lat_deg Vector of latitude minutes Float lat_min This method is easier or more tedious depending on what you consider a more practical approach. For example, if you have decimal-minutes coordinates for two samples: Longitude Latitude Sample 1 11 43.12 15 36.53 Sample 2 -12 41.32 11 22.41 then your inputs would be: lo_deg = [11, -12] lo_min = [43.12, 41.32] la_deg = [15, 11] la_min = [36.53, 22.41] and you would then use locations! like this: locations! ( data , long_deg = lo_deg , long_min = lo_min , lat_deg = la_deg , lat_min = la_min )","title":"If in decimal minutes"},{"location":"community/","text":"Join the Slack channel! Have questions, want to talk population genetics, or have ideas? Join the PopGen.jl Slack channel! \u2003 window.CommunityInviterAsyncInit = function () { \u2003 \u2003 CommunityInviter.init({ \u2003 \u2003 \u2003 app_url:'join', \u2003 \u2003 \u2003 team_id:'popgenjl' \u2003 \u2003}) \u2003 }; \u2003 (function(d, s, id){ \u2003 \u2003 var js, fjs = d.getElementsByTagName(s)[0]; \u2003 \u2003 if (d.getElementById(id)) {return;} \u2003 \u2003 js = d.createElement(s); js.id = id; \u2003 \u2003 js.src = \"https://communityinviter.com/js/communityinviter.js\"; \u2003 \u2003 fjs.parentNode.insertBefore(js, fjs); \u2003 }(document, 'script', 'Community_Inviter')); Contributing We absolutely welcome contributors to this package/project! See below for ways you can help PopGen.jl grow. Optimizing available code By nature, most (if not all) users of PopGen.jl will be biologists, and will not come from a strong computational background. Heck, the co-creators of the package don't even have a strong computation background (we're very good at nodding and smiling). There are various best-practices documented in Julia that help users write code to get the best performance out of the language, and sometimes a function that gets written isn't as performant as it can be. If you come up with faster and/or more memory efficient alternatives to the functions in PopGen.jl, we wholeheartedly encourage you to open up a issue or pull request and we'll try to integrate that into the PopGen.jl ecosystem. Pointing out bugs (and troubleshooting them if possible!) No one is perfect (except maybe Betty White), so it's very possible that mistakes get made, especially as more users begin adopting and contributing to PopGen.jl (we hope). If something isn't functioning correctly, please open an issue that includes a minimum working example . We definitely want to figure out what's going on, and we need as much information as possible to try to diagnose issues as they come up. Julia's overall performance is rooted in really clever dispatch to the LLVM compiler, and the underlying system benefits most from strict typing, wherever we can enforce it, and we expect that this strictness may result in extra issues being raised from niche use-cases. Testing your data against the available code During PopGen.jl's development, we generally use nancycats and gulfsharks for just about everything. Those two datasets cover the range of what we expect are common use-cases; a smaller microsatellite dataset (nancycats) and a medium sized SNP dataset (gulfsharks). However, we know better than to put all of our faith into n = 2, so please use your own data and mess around with PopGen.jl and let us know if something doesn't jive. Writing new functions or methods for existing functions By all means, extend PopGen.jl to include all sorts of analyses! GST, Tajima's D, AMOVA, SAMOVA, porting BOTTLENECK , coalescence, etc. Yes please! Part of the intent behind PopGen.jl is to have it act as a sort of sandbox to play around in, which is why most of the package's basic calculations are modularized (see the hidden API). As a design choice, it made the most sense to have written the package in this way, because many population genetic calculations are built on top of other ones (like allele frequency or heterozygosity). Writing or editing the docs The documentation of PopGen.jl must be approachable and helpful . Helpful in the sense that if someone was tasked with \"looking for siblings\" in their data and didn't know exactly how, that the documentation for the relatedness command would provide some kind of context as to what it does and how, with figures, and with helpful in-line links to the source publications or more in-depth online resources. This package is not intended for only expert-level users, which means that the documentation needs to be accessible to entry-level users . By no means will the documentation be the ultimate compendium of all population genetics knowledge, but it will be helpful beyond simply stating a command, its arguments, and a one-liner of what it does. If you want to contribute but don't feel comfortable with the programming side of things, then we encourage you to help grow the documentation. Clarify the language in some sections, or maybe provide a useful diagram where one doesn't exist. Or typos. There are always typoes. Spreading the word The very soul of open-source projects relies on people wanting to get involved. Spread the word . If you are into social media, give us a shoutout. We can't imagine why you'd want to, but if you insisted on using a hashtag, then #PopGenjl is probably the sensible choice. Kindness and encouragement This stuff can be hard. As the package grows, we expect that we'll be dealing with a growing number of issues/complaints. A little thumbs-up or prayer-hands emoji (Pavel's personal favorite) can go a long way. Or cook up your own cactus graphic (like the one below) and send it to us. Who doesn't love adorable cactuses doing human things?","title":"Community"},{"location":"community/#join-the-slack-channel","text":"Have questions, want to talk population genetics, or have ideas? Join the PopGen.jl Slack channel! \u2003 window.CommunityInviterAsyncInit = function () { \u2003 \u2003 CommunityInviter.init({ \u2003 \u2003 \u2003 app_url:'join', \u2003 \u2003 \u2003 team_id:'popgenjl' \u2003 \u2003}) \u2003 }; \u2003 (function(d, s, id){ \u2003 \u2003 var js, fjs = d.getElementsByTagName(s)[0]; \u2003 \u2003 if (d.getElementById(id)) {return;} \u2003 \u2003 js = d.createElement(s); js.id = id; \u2003 \u2003 js.src = \"https://communityinviter.com/js/communityinviter.js\"; \u2003 \u2003 fjs.parentNode.insertBefore(js, fjs); \u2003 }(document, 'script', 'Community_Inviter'));","title":"Join the Slack channel!"},{"location":"community/#contributing","text":"We absolutely welcome contributors to this package/project! See below for ways you can help PopGen.jl grow.","title":"Contributing"},{"location":"community/#optimizing-available-code","text":"By nature, most (if not all) users of PopGen.jl will be biologists, and will not come from a strong computational background. Heck, the co-creators of the package don't even have a strong computation background (we're very good at nodding and smiling). There are various best-practices documented in Julia that help users write code to get the best performance out of the language, and sometimes a function that gets written isn't as performant as it can be. If you come up with faster and/or more memory efficient alternatives to the functions in PopGen.jl, we wholeheartedly encourage you to open up a issue or pull request and we'll try to integrate that into the PopGen.jl ecosystem.","title":"Optimizing available code"},{"location":"community/#pointing-out-bugs","text":"(and troubleshooting them if possible!) No one is perfect (except maybe Betty White), so it's very possible that mistakes get made, especially as more users begin adopting and contributing to PopGen.jl (we hope). If something isn't functioning correctly, please open an issue that includes a minimum working example . We definitely want to figure out what's going on, and we need as much information as possible to try to diagnose issues as they come up. Julia's overall performance is rooted in really clever dispatch to the LLVM compiler, and the underlying system benefits most from strict typing, wherever we can enforce it, and we expect that this strictness may result in extra issues being raised from niche use-cases.","title":"Pointing out bugs"},{"location":"community/#testing-your-data-against-the-available-code","text":"During PopGen.jl's development, we generally use nancycats and gulfsharks for just about everything. Those two datasets cover the range of what we expect are common use-cases; a smaller microsatellite dataset (nancycats) and a medium sized SNP dataset (gulfsharks). However, we know better than to put all of our faith into n = 2, so please use your own data and mess around with PopGen.jl and let us know if something doesn't jive.","title":"Testing your data against the available code"},{"location":"community/#writing-new-functions-or-methods-for-existing-functions","text":"By all means, extend PopGen.jl to include all sorts of analyses! GST, Tajima's D, AMOVA, SAMOVA, porting BOTTLENECK , coalescence, etc. Yes please! Part of the intent behind PopGen.jl is to have it act as a sort of sandbox to play around in, which is why most of the package's basic calculations are modularized (see the hidden API). As a design choice, it made the most sense to have written the package in this way, because many population genetic calculations are built on top of other ones (like allele frequency or heterozygosity).","title":"Writing new functions or methods for existing functions"},{"location":"community/#writing-or-editing-the-docs","text":"The documentation of PopGen.jl must be approachable and helpful . Helpful in the sense that if someone was tasked with \"looking for siblings\" in their data and didn't know exactly how, that the documentation for the relatedness command would provide some kind of context as to what it does and how, with figures, and with helpful in-line links to the source publications or more in-depth online resources. This package is not intended for only expert-level users, which means that the documentation needs to be accessible to entry-level users . By no means will the documentation be the ultimate compendium of all population genetics knowledge, but it will be helpful beyond simply stating a command, its arguments, and a one-liner of what it does. If you want to contribute but don't feel comfortable with the programming side of things, then we encourage you to help grow the documentation. Clarify the language in some sections, or maybe provide a useful diagram where one doesn't exist. Or typos. There are always typoes.","title":"Writing or editing the docs"},{"location":"community/#spreading-the-word","text":"The very soul of open-source projects relies on people wanting to get involved. Spread the word . If you are into social media, give us a shoutout. We can't imagine why you'd want to, but if you insisted on using a hashtag, then #PopGenjl is probably the sensible choice.","title":"Spreading the word"},{"location":"community/#kindness-and-encouragement","text":"This stuff can be hard. As the package grows, we expect that we'll be dealing with a growing number of issues/complaints. A little thumbs-up or prayer-hands emoji (Pavel's personal favorite) can go a long way. Or cook up your own cactus graphic (like the one below) and send it to us. Who doesn't love adorable cactuses doing human things?","title":"Kindness and encouragement"},{"location":"analyses/hardyweinberg/","text":"Testing for Hardy-Weinberg Equilibrium (often abbreviated to \"HW\" or \"HWE\") is a fairly common practice in population genetics. In a two-allele system (alleles p and q ), the HWE equation is defined as p 2 + 2pq + q 2 = 1 , where p is the frequency of the first allele and q is the frequency of the second allele. The formula describes the frequency of all possible genotypes where HWE variable Genotype p 2 \"pp\" q 2 \"qq\" 2pq \"pq\" Testing for deviation from HWE is usually done with a Chi-Squared test, where one compares the observed genotype frequencies to the expected genotype frequencies given the observed allele frequencies at a locus. Test for Hardy-Weinberg equilibrium hwe_test ( x :: PopObj , by_pop :: Bool = false , correction :: String = \"none\" ) Calculate chi-squared test of HWE for each locus and returns observed and expected heterozygosity with chi-squared, degrees of freedom and p-values for each locus. Use by_pop = true to perform this separately for each population (default: by_pop = false) and return a NamedTuple with the names corresponding to the population names. Use correction = to specify a P-value correction method for multiple testing. arguments x : the input PopObj by_pop = : false (default) or true for hwe-by-population correction = : a string specifying a P-value adjustment type (default: \"none\") correction methods \"bonferroni\" : Bonferroni adjustment \"holm\" : Holm adjustment \"hochberg\" : Hochberg adjustment \"bh\" or \"b-h\" : Benjamini-Hochberg adjustment \"by\" or \"b-y\" : Benjamini-Yekutieli adjustment \"bl\" or \"b-l\" : Benjamini-Liu adjustment \"hommel\" : Hommel adjustment \"sidak\" : \u0160id\u00e1k adjustment \"forward stop\" or \"fs\" : Forward-Stop adjustment \"bc\" or \"b-c\" : Barber-Cande\u0300s adjustment For more information on multiple testing adjustments, see MultipleTesting.jl example example hwe_test ( gulfsharks (), correction = \"bh\" ) output 2213\u00d77 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64 \u2502 Float64 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.419811 \u2502 0.398051 \u2502 0.690981 \u2502 3.0 \u2502 0.875323 \u2502 0.948912 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.262136 \u2502 0.288434 \u2502 1.71251 \u2502 1.0 \u2502 0.19066 \u2502 0.295543 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.205742 \u2502 0.228532 \u2502 2.0785 \u2502 1.0 \u2502 0.149387 \u2502 0.234857 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0666667 \u2502 0.0644444 \u2502 0.249703 \u2502 1.0 \u2502 0.617284 \u2502 0.807471 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.240566 \u2502 0.21875 \u2502 2.10859 \u2502 1.0 \u2502 0.146475 \u2502 0.230442 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0188679 \u2502 0.0186899 \u2502 0.019229 \u2502 1.0 \u2502 0.889712 \u2502 0.948912 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0.0801887 \u2502 0.0769736 \u2502 0.369866 \u2502 1.0 \u2502 0.543077 \u2502 0.732045 \u2502 \u2502 8 \u2502 contig_14708 \u2502 0.0616114 \u2502 0.0597134 \u2502 0.213168 \u2502 1.0 \u2502 0.644295 \u2502 0.828219 \u2502 \u2502 9 \u2502 contig_2307 \u2502 0.0289855 \u2502 0.0285654 \u2502 0.0447664 \u2502 1.0 \u2502 0.832434 \u2502 0.938862 \u2502 \u2502 10 \u2502 contig_14564 \u2502 0.2 \u2502 0.209751 \u2502 0.453809 \u2502 1.0 \u2502 0.500532 \u2502 0.6894 \u2502 \u2502 11 \u2502 contig_15269 \u2502 0.15566 \u2502 0.146505 \u2502 1.51012 \u2502 3.0 \u2502 0.679938 \u2502 0.857489 \u2502 \u2502 12 \u2502 contig_24796 \u2502 0.161137 \u2502 0.201613 \u2502 8.50406 \u2502 1.0 \u2502 0.00354355 \u2502 0.00596524 \u2502 \u2502 13 \u2502 contig_14251 \u2502 0.490566 \u2502 0.49782 \u2502 0.0450074 \u2502 1.0 \u2502 0.83199 \u2502 0.938862 \u2502 \u2502 14 \u2502 contig_44797 \u2502 0.0240385 \u2502 0.0237495 \u2502 0.0307836 \u2502 1.0 \u2502 0.860724 \u2502 0.944468 \u2502 \u2502 15 \u2502 contig_43681 \u2502 0.42381 \u2502 0.472778 \u2502 2.25286 \u2502 1.0 \u2502 0.133368 \u2502 0.211628 \u2502 \u2502 16 \u2502 contig_24115 \u2502 0.0333333 \u2502 0.0327778 \u2502 0.0603275 \u2502 1.0 \u2502 0.805979 \u2502 0.931567 \u2502 \u2502 17 \u2502 contig_5456 \u2502 0.0471698 \u2502 0.0460573 \u2502 0.12369 \u2502 1.0 \u2502 0.725066 \u2502 0.892017 \u2502 \u2502 18 \u2502 contig_21698 \u2502 0.0758294 \u2502 0.0729543 \u2502 0.327695 \u2502 1.0 \u2502 0.567019 \u2502 0.758715 \u2502 \u22ee \u2502 2195 \u2502 contig_8479 \u2502 0.0235849 \u2502 0.0598856 \u2502 212.031 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2196 \u2502 contig_47462 \u2502 0.45283 \u2502 0.502803 \u2502 213.589 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2197 \u2502 contig_4095 \u2502 0.259434 \u2502 0.275398 \u2502 212.0 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2198 \u2502 contig_7239 \u2502 0.0660377 \u2502 0.0729352 \u2502 212.25 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2199 \u2502 contig_40507 \u2502 0.0330189 \u2502 0.0688746 \u2502 212.062 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2200 \u2502 contig_42145 \u2502 0.358491 \u2502 0.31754 \u2502 5.95351 \u2502 3.0 \u2502 0.113894 \u2502 0.182428 \u2502 \u2502 2201 \u2502 contig_1033 \u2502 0.363208 \u2502 0.352872 \u2502 0.181856 \u2502 1.0 \u2502 0.669783 \u2502 0.85219 \u2502 \u2502 2202 \u2502 contig_2798 \u2502 0.122642 \u2502 0.140219 \u2502 212.952 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2203 \u2502 contig_12991 \u2502 0.0518868 \u2502 0.112685 \u2502 212.161 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2204 \u2502 contig_22981 \u2502 0.188679 \u2502 0.200783 \u2502 0.770434 \u2502 1.0 \u2502 0.380083 \u2502 0.551307 \u2502 \u2502 2205 \u2502 contig_15342 \u2502 0.268868 \u2502 0.29084 \u2502 212.328 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2206 \u2502 contig_24711 \u2502 0.273585 \u2502 0.288136 \u2502 0.540694 \u2502 1.0 \u2502 0.462145 \u2502 0.645777 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0.466981 \u2502 0.437422 \u2502 0.968086 \u2502 1.0 \u2502 0.325158 \u2502 0.482394 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.103774 \u2502 0.150454 \u2502 212.675 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0660377 \u2502 0.0906016 \u2502 213.73 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.367925 \u2502 0.375 \u2502 0.0754717 \u2502 1.0 \u2502 0.78353 \u2502 0.926932 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0613208 \u2502 0.11264 \u2502 214.152 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.0896226 \u2502 0.11224 \u2502 212.481 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0283019 \u2502 0.0908241 \u2502 212.047 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 by_pop = true julia> hwe_test(gulfsharks(), by_pop = true, correction = \"bh\") (Cape Canaveral = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.333333 \u2502 0.427438 \u2502 1.01787 \u2502 1.0 \u2502 0.313025 \u2502 0.872143 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.263158 \u2502 0.228532 \u2502 0.43618 \u2502 1.0 \u2502 0.508972 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.142857 \u2502 0.209751 \u2502 2.13589 \u2502 1.0 \u2502 0.143886 \u2502 0.51061 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.0952381 \u2502 0.0907029 \u2502 0.0525 \u2502 1.0 \u2502 0.818769 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.52381 \u2502 0.427438 \u2502 1.06752 \u2502 1.0 \u2502 0.301507 \u2502 0.856472 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.0952381 \u2502 0.0907029 \u2502 0.0525 \u2502 1.0 \u2502 0.818769 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.047619 \u2502 0.0464853 \u2502 0.0124926 \u2502 1.0 \u2502 0.911006 \u2502 0.987085 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.285714 \u2502 0.30839 \u2502 0.113538 \u2502 1.0 \u2502 0.736152 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0952381 \u2502 0.176871 \u2502 21.0582 \u2502 3.0 \u2502 0.000102388 \u2502 0.000625326 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.047619 \u2502 0.0464853 \u2502 0.0124926 \u2502 1.0 \u2502 0.911006 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502, Georgia = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.4 \u2502 0.389467 \u2502 0.276208 \u2502 3.0 \u2502 0.964439 \u2502 1.0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.28125 \u2502 0.304688 \u2502 0.378698 \u2502 1.0 \u2502 0.538301 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.234375 \u2502 0.230347 \u2502 0.0195733 \u2502 1.0 \u2502 0.888735 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.046875 \u2502 0.0457764 \u2502 0.036864 \u2502 1.0 \u2502 0.847742 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.292308 \u2502 0.249586 \u2502 1.90447 \u2502 1.0 \u2502 0.167579 \u2502 0.57153 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0153846 \u2502 0.0152663 \u2502 0.00390602 \u2502 1.0 \u2502 0.950166 \u2502 0.996029 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.538462 \u2502 0.461657 \u2502 1.79908 \u2502 1.0 \u2502 0.179824 \u2502 0.59782 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.123077 \u2502 0.223432 \u2502 65.3201 \u2502 3.0 \u2502 4.28546e-14 \u2502 1.01329e-12 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0307692 \u2502 0.0601183 \u2502 65.0164 \u2502 3.0 \u2502 4.9738e-14 \u2502 1.01329e-12 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.369231 \u2502 0.400473 \u2502 0.395604 \u2502 1.0 \u2502 0.529368 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0769231 \u2502 0.130533 \u2502 68.8823 \u2502 3.0 \u2502 7.43849e-15 \u2502 1.01329e-12 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.0923077 \u2502 0.116923 \u2502 65.1572 \u2502 3.0 \u2502 4.64073e-14 \u2502 1.01329e-12 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0461538 \u2502 0.103314 \u2502 65.0387 \u2502 3.0 \u2502 4.91829e-14 \u2502 1.01329e-12 \u2502, South Carolina = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.4 \u2502 0.375 \u2502 0.0888889 \u2502 1.0 \u2502 0.765594 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.117647 \u2502 0.110727 \u2502 0.0664063 \u2502 1.0 \u2502 0.796643 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.277778 \u2502 0.313272 \u2502 0.231066 \u2502 1.0 \u2502 0.630735 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0526316 \u2502 0.0512465 \u2502 0.0138787 \u2502 1.0 \u2502 0.90622 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.1 \u2502 0.095 \u2502 0.0554017 \u2502 1.0 \u2502 0.813917 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.35 \u2502 0.43875 \u2502 0.818338 \u2502 1.0 \u2502 0.365667 \u2502 0.948296 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.0 \u2502 0.18 \u2502 20.0 \u2502 1.0 \u2502 7.74422e-6 \u2502 5.90346e-5 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.1 \u2502 0.185 \u2502 20.0617 \u2502 3.0 \u2502 0.000164815 \u2502 0.00078662 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.3 \u2502 0.255 \u2502 0.622837 \u2502 1.0 \u2502 0.429995 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0 \u2502 0.255 \u2502 20.0 \u2502 1.0 \u2502 7.74422e-6 \u2502 5.90346e-5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.05 \u2502 0.22375 \u2502 20.0163 \u2502 3.0 \u2502 0.000168425 \u2502 0.00078662 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.05 \u2502 0.14125 \u2502 20.0146 \u2502 3.0 \u2502 0.000168563 \u2502 0.00078662 \u2502, Florida Keys = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.45 \u2502 0.41125 \u2502 0.519382 \u2502 3.0 \u2502 0.914613 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.4 \u2502 0.42 \u2502 0.0453515 \u2502 1.0 \u2502 0.831359 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.25 \u2502 0.28875 \u2502 0.360188 \u2502 1.0 \u2502 0.548402 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.2 \u2502 0.18 \u2502 0.246914 \u2502 1.0 \u2502 0.619257 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.25 \u2502 0.21875 \u2502 0.408163 \u2502 1.0 \u2502 0.522903 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.05 \u2502 0.04875 \u2502 0.0131492 \u2502 1.0 \u2502 0.908707 \u2502 0.987085 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.45 \u2502 0.39875 \u2502 0.330382 \u2502 1.0 \u2502 0.565434 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.05 \u2502 0.04875 \u2502 0.0131492 \u2502 1.0 \u2502 0.908707 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.4 \u2502 0.375 \u2502 0.0888889 \u2502 1.0 \u2502 0.765594 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.15 \u2502 0.13875 \u2502 0.131483 \u2502 1.0 \u2502 0.7169 \u2502 0.987085 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.15 \u2502 0.13875 \u2502 0.131483 \u2502 1.0 \u2502 0.7169 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502, Mideast Gulf = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.5 \u2502 0.436224 \u2502 0.598475 \u2502 1.0 \u2502 0.439161 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.214286 \u2502 0.191327 \u2502 0.4032 \u2502 1.0 \u2502 0.525441 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.178571 \u2502 0.21875 \u2502 0.944606 \u2502 1.0 \u2502 0.331096 \u2502 0.898252 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.107143 \u2502 0.101403 \u2502 0.0897116 \u2502 1.0 \u2502 0.764544 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.357143 \u2502 0.336735 \u2502 0.102847 \u2502 1.0 \u2502 0.74844 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.535714 \u2502 0.484056 \u2502 0.318893 \u2502 1.0 \u2502 0.572274 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.178571 \u2502 0.162628 \u2502 0.269127 \u2502 1.0 \u2502 0.603918 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0357143 \u2502 0.101403 \u2502 11.75 \u2502 1.0 \u2502 0.000608429 \u2502 0.00278639 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.285714 \u2502 0.336735 \u2502 0.642792 \u2502 1.0 \u2502 0.422702 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.107143 \u2502 0.101403 \u2502 0.0897116 \u2502 1.0 \u2502 0.764544 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0714286 \u2502 0.135204 \u2502 28.0414 \u2502 3.0 \u2502 3.56005e-6 \u2502 3.64412e-5 \u2502, Northeast Gulf = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.428571 \u2502 0.375 \u2502 0.571429 \u2502 1.0 \u2502 0.449692 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.321429 \u2502 0.392219 \u2502 0.912124 \u2502 1.0 \u2502 0.339552 \u2502 0.903179 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.214286 \u2502 0.191327 \u2502 0.4032 \u2502 1.0 \u2502 0.525441 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.25 \u2502 0.21875 \u2502 0.571429 \u2502 1.0 \u2502 0.449692 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.285714 \u2502 0.336735 \u2502 0.642792 \u2502 1.0 \u2502 0.422702 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.107143 \u2502 0.101403 \u2502 0.0897116 \u2502 1.0 \u2502 0.764544 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.142857 \u2502 0.132653 \u2502 0.16568 \u2502 1.0 \u2502 0.68398 \u2502 0.987085 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.464286 \u2502 0.448342 \u2502 0.0354101 \u2502 1.0 \u2502 0.850739 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.0688776 \u2502 28.0 \u2502 1.0 \u2502 1.21315e-7 \u2502 1.87007e-6 \u2502, Southeast Gulf = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.433333 \u2502 0.375 \u2502 0.725926 \u2502 1.0 \u2502 0.394207 \u2502 0.980648 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.2 \u2502 0.231111 \u2502 0.543639 \u2502 1.0 \u2502 0.460928 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.133333 \u2502 0.18 \u2502 2.01646 \u2502 1.0 \u2502 0.155601 \u2502 0.540012 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0666667 \u2502 0.0644444 \u2502 0.0356718 \u2502 1.0 \u2502 0.850195 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.2 \u2502 0.18 \u2502 0.37037 \u2502 1.0 \u2502 0.542802 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0333333 \u2502 0.0327778 \u2502 0.00861821 \u2502 1.0 \u2502 0.926035 \u2502 0.987085 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.466667 \u2502 0.42 \u2502 0.37037 \u2502 1.0 \u2502 0.542802 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.1 \u2502 0.095 \u2502 0.0831025 \u2502 1.0 \u2502 0.773136 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.133333 \u2502 0.124444 \u2502 0.153061 \u2502 1.0 \u2502 0.695627 \u2502 0.987085 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.433333 \u2502 0.375 \u2502 0.725926 \u2502 1.0 \u2502 0.394207 \u2502 0.980648 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0666667 \u2502 0.0644444 \u2502 0.0356718 \u2502 1.0 \u2502 0.850195 \u2502 0.987085 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.133333 \u2502 0.124444 \u2502 0.153061 \u2502 1.0 \u2502 0.695627 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.124444 \u2502 30.0 \u2502 1.0 \u2502 4.32046e-8 \u2502 7.21496e-7 \u2502) pro tip If using by_pop = true , there may be a very long output which you may want to suppress by ending the command with a semicolon ; . The function returns a NamedTuple of DataFrames, meaning you can index it with a dot . operator. If you assign the command's output to a variable, such as hardy = hwe_test(gulfsharks(), by_pop = true) ; , then you can index the output with the population names, such as hardy.CapeCanaveral or hardy.Georgia . And since those objects are DataFrames, you can continue using the dot . operator to index them further by column, such as hardy.Georgia.Pcorr to see only the corrected P values. Convenience! indexing the Chiq-sq column The Fast(er) Way : you can just index the column using the DataFrames numerical index like so: df[!, 4] The Fun Way: to index the chi-squared column from the dataframe using the dot operator (i.e. df.\u03c7\u00b2 ), you will need to use the unicode characters in Julia, b/c the column is literally named \u03c7\u00b2. To generate those characters, type in \\Chi + press TAB + type in \\^2 + press TAB without spaces and it will magically appear (in the REPL and Juno, at least). Written out in more explicit English (we really want you to get it!), it's a backslash \\ , the word Chi with a capital C, the TAB key on your keyboard (and you'll notice it's already changed it to the letter \u03c7), another backslash \\ , a caret ^ , the number 2 , then the TAB key again. All in all, you'll be doing this: \\ChiTAB\\^2TAB . It's actually a lot easier than it looks.","title":"Hardy-Weinberg Equilibrium"},{"location":"analyses/hardyweinberg/#test-for-hardy-weinberg-equilibrium","text":"hwe_test ( x :: PopObj , by_pop :: Bool = false , correction :: String = \"none\" ) Calculate chi-squared test of HWE for each locus and returns observed and expected heterozygosity with chi-squared, degrees of freedom and p-values for each locus. Use by_pop = true to perform this separately for each population (default: by_pop = false) and return a NamedTuple with the names corresponding to the population names. Use correction = to specify a P-value correction method for multiple testing.","title":"Test for Hardy-Weinberg equilibrium"},{"location":"analyses/hardyweinberg/#arguments","text":"x : the input PopObj by_pop = : false (default) or true for hwe-by-population correction = : a string specifying a P-value adjustment type (default: \"none\")","title":"arguments"},{"location":"analyses/hardyweinberg/#correction-methods","text":"\"bonferroni\" : Bonferroni adjustment \"holm\" : Holm adjustment \"hochberg\" : Hochberg adjustment \"bh\" or \"b-h\" : Benjamini-Hochberg adjustment \"by\" or \"b-y\" : Benjamini-Yekutieli adjustment \"bl\" or \"b-l\" : Benjamini-Liu adjustment \"hommel\" : Hommel adjustment \"sidak\" : \u0160id\u00e1k adjustment \"forward stop\" or \"fs\" : Forward-Stop adjustment \"bc\" or \"b-c\" : Barber-Cande\u0300s adjustment For more information on multiple testing adjustments, see MultipleTesting.jl","title":"correction methods"},{"location":"analyses/hardyweinberg/#example","text":"example hwe_test ( gulfsharks (), correction = \"bh\" ) output 2213\u00d77 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64 \u2502 Float64 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.419811 \u2502 0.398051 \u2502 0.690981 \u2502 3.0 \u2502 0.875323 \u2502 0.948912 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.262136 \u2502 0.288434 \u2502 1.71251 \u2502 1.0 \u2502 0.19066 \u2502 0.295543 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.205742 \u2502 0.228532 \u2502 2.0785 \u2502 1.0 \u2502 0.149387 \u2502 0.234857 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0666667 \u2502 0.0644444 \u2502 0.249703 \u2502 1.0 \u2502 0.617284 \u2502 0.807471 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.240566 \u2502 0.21875 \u2502 2.10859 \u2502 1.0 \u2502 0.146475 \u2502 0.230442 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0188679 \u2502 0.0186899 \u2502 0.019229 \u2502 1.0 \u2502 0.889712 \u2502 0.948912 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0.0801887 \u2502 0.0769736 \u2502 0.369866 \u2502 1.0 \u2502 0.543077 \u2502 0.732045 \u2502 \u2502 8 \u2502 contig_14708 \u2502 0.0616114 \u2502 0.0597134 \u2502 0.213168 \u2502 1.0 \u2502 0.644295 \u2502 0.828219 \u2502 \u2502 9 \u2502 contig_2307 \u2502 0.0289855 \u2502 0.0285654 \u2502 0.0447664 \u2502 1.0 \u2502 0.832434 \u2502 0.938862 \u2502 \u2502 10 \u2502 contig_14564 \u2502 0.2 \u2502 0.209751 \u2502 0.453809 \u2502 1.0 \u2502 0.500532 \u2502 0.6894 \u2502 \u2502 11 \u2502 contig_15269 \u2502 0.15566 \u2502 0.146505 \u2502 1.51012 \u2502 3.0 \u2502 0.679938 \u2502 0.857489 \u2502 \u2502 12 \u2502 contig_24796 \u2502 0.161137 \u2502 0.201613 \u2502 8.50406 \u2502 1.0 \u2502 0.00354355 \u2502 0.00596524 \u2502 \u2502 13 \u2502 contig_14251 \u2502 0.490566 \u2502 0.49782 \u2502 0.0450074 \u2502 1.0 \u2502 0.83199 \u2502 0.938862 \u2502 \u2502 14 \u2502 contig_44797 \u2502 0.0240385 \u2502 0.0237495 \u2502 0.0307836 \u2502 1.0 \u2502 0.860724 \u2502 0.944468 \u2502 \u2502 15 \u2502 contig_43681 \u2502 0.42381 \u2502 0.472778 \u2502 2.25286 \u2502 1.0 \u2502 0.133368 \u2502 0.211628 \u2502 \u2502 16 \u2502 contig_24115 \u2502 0.0333333 \u2502 0.0327778 \u2502 0.0603275 \u2502 1.0 \u2502 0.805979 \u2502 0.931567 \u2502 \u2502 17 \u2502 contig_5456 \u2502 0.0471698 \u2502 0.0460573 \u2502 0.12369 \u2502 1.0 \u2502 0.725066 \u2502 0.892017 \u2502 \u2502 18 \u2502 contig_21698 \u2502 0.0758294 \u2502 0.0729543 \u2502 0.327695 \u2502 1.0 \u2502 0.567019 \u2502 0.758715 \u2502 \u22ee \u2502 2195 \u2502 contig_8479 \u2502 0.0235849 \u2502 0.0598856 \u2502 212.031 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2196 \u2502 contig_47462 \u2502 0.45283 \u2502 0.502803 \u2502 213.589 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2197 \u2502 contig_4095 \u2502 0.259434 \u2502 0.275398 \u2502 212.0 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2198 \u2502 contig_7239 \u2502 0.0660377 \u2502 0.0729352 \u2502 212.25 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2199 \u2502 contig_40507 \u2502 0.0330189 \u2502 0.0688746 \u2502 212.062 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2200 \u2502 contig_42145 \u2502 0.358491 \u2502 0.31754 \u2502 5.95351 \u2502 3.0 \u2502 0.113894 \u2502 0.182428 \u2502 \u2502 2201 \u2502 contig_1033 \u2502 0.363208 \u2502 0.352872 \u2502 0.181856 \u2502 1.0 \u2502 0.669783 \u2502 0.85219 \u2502 \u2502 2202 \u2502 contig_2798 \u2502 0.122642 \u2502 0.140219 \u2502 212.952 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2203 \u2502 contig_12991 \u2502 0.0518868 \u2502 0.112685 \u2502 212.161 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2204 \u2502 contig_22981 \u2502 0.188679 \u2502 0.200783 \u2502 0.770434 \u2502 1.0 \u2502 0.380083 \u2502 0.551307 \u2502 \u2502 2205 \u2502 contig_15342 \u2502 0.268868 \u2502 0.29084 \u2502 212.328 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2206 \u2502 contig_24711 \u2502 0.273585 \u2502 0.288136 \u2502 0.540694 \u2502 1.0 \u2502 0.462145 \u2502 0.645777 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0.466981 \u2502 0.437422 \u2502 0.968086 \u2502 1.0 \u2502 0.325158 \u2502 0.482394 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.103774 \u2502 0.150454 \u2502 212.675 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0660377 \u2502 0.0906016 \u2502 213.73 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.367925 \u2502 0.375 \u2502 0.0754717 \u2502 1.0 \u2502 0.78353 \u2502 0.926932 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0613208 \u2502 0.11264 \u2502 214.152 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.0896226 \u2502 0.11224 \u2502 212.481 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0283019 \u2502 0.0908241 \u2502 212.047 \u2502 3.0 \u2502 0.0 \u2502 0.0 \u2502 by_pop = true julia> hwe_test(gulfsharks(), by_pop = true, correction = \"bh\") (Cape Canaveral = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.333333 \u2502 0.427438 \u2502 1.01787 \u2502 1.0 \u2502 0.313025 \u2502 0.872143 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.263158 \u2502 0.228532 \u2502 0.43618 \u2502 1.0 \u2502 0.508972 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.142857 \u2502 0.209751 \u2502 2.13589 \u2502 1.0 \u2502 0.143886 \u2502 0.51061 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.0952381 \u2502 0.0907029 \u2502 0.0525 \u2502 1.0 \u2502 0.818769 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.52381 \u2502 0.427438 \u2502 1.06752 \u2502 1.0 \u2502 0.301507 \u2502 0.856472 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.0952381 \u2502 0.0907029 \u2502 0.0525 \u2502 1.0 \u2502 0.818769 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.047619 \u2502 0.0464853 \u2502 0.0124926 \u2502 1.0 \u2502 0.911006 \u2502 0.987085 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.285714 \u2502 0.30839 \u2502 0.113538 \u2502 1.0 \u2502 0.736152 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0952381 \u2502 0.176871 \u2502 21.0582 \u2502 3.0 \u2502 0.000102388 \u2502 0.000625326 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.047619 \u2502 0.0464853 \u2502 0.0124926 \u2502 1.0 \u2502 0.911006 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502, Georgia = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.4 \u2502 0.389467 \u2502 0.276208 \u2502 3.0 \u2502 0.964439 \u2502 1.0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.28125 \u2502 0.304688 \u2502 0.378698 \u2502 1.0 \u2502 0.538301 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.234375 \u2502 0.230347 \u2502 0.0195733 \u2502 1.0 \u2502 0.888735 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.046875 \u2502 0.0457764 \u2502 0.036864 \u2502 1.0 \u2502 0.847742 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.292308 \u2502 0.249586 \u2502 1.90447 \u2502 1.0 \u2502 0.167579 \u2502 0.57153 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0153846 \u2502 0.0152663 \u2502 0.00390602 \u2502 1.0 \u2502 0.950166 \u2502 0.996029 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.538462 \u2502 0.461657 \u2502 1.79908 \u2502 1.0 \u2502 0.179824 \u2502 0.59782 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.123077 \u2502 0.223432 \u2502 65.3201 \u2502 3.0 \u2502 4.28546e-14 \u2502 1.01329e-12 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0307692 \u2502 0.0601183 \u2502 65.0164 \u2502 3.0 \u2502 4.9738e-14 \u2502 1.01329e-12 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.369231 \u2502 0.400473 \u2502 0.395604 \u2502 1.0 \u2502 0.529368 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0769231 \u2502 0.130533 \u2502 68.8823 \u2502 3.0 \u2502 7.43849e-15 \u2502 1.01329e-12 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.0923077 \u2502 0.116923 \u2502 65.1572 \u2502 3.0 \u2502 4.64073e-14 \u2502 1.01329e-12 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0461538 \u2502 0.103314 \u2502 65.0387 \u2502 3.0 \u2502 4.91829e-14 \u2502 1.01329e-12 \u2502, South Carolina = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.4 \u2502 0.375 \u2502 0.0888889 \u2502 1.0 \u2502 0.765594 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.117647 \u2502 0.110727 \u2502 0.0664063 \u2502 1.0 \u2502 0.796643 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.277778 \u2502 0.313272 \u2502 0.231066 \u2502 1.0 \u2502 0.630735 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0526316 \u2502 0.0512465 \u2502 0.0138787 \u2502 1.0 \u2502 0.90622 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.1 \u2502 0.095 \u2502 0.0554017 \u2502 1.0 \u2502 0.813917 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.35 \u2502 0.43875 \u2502 0.818338 \u2502 1.0 \u2502 0.365667 \u2502 0.948296 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.0 \u2502 0.18 \u2502 20.0 \u2502 1.0 \u2502 7.74422e-6 \u2502 5.90346e-5 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.1 \u2502 0.185 \u2502 20.0617 \u2502 3.0 \u2502 0.000164815 \u2502 0.00078662 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.3 \u2502 0.255 \u2502 0.622837 \u2502 1.0 \u2502 0.429995 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0 \u2502 0.255 \u2502 20.0 \u2502 1.0 \u2502 7.74422e-6 \u2502 5.90346e-5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.05 \u2502 0.22375 \u2502 20.0163 \u2502 3.0 \u2502 0.000168425 \u2502 0.00078662 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.05 \u2502 0.14125 \u2502 20.0146 \u2502 3.0 \u2502 0.000168563 \u2502 0.00078662 \u2502, Florida Keys = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.45 \u2502 0.41125 \u2502 0.519382 \u2502 3.0 \u2502 0.914613 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.4 \u2502 0.42 \u2502 0.0453515 \u2502 1.0 \u2502 0.831359 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.25 \u2502 0.28875 \u2502 0.360188 \u2502 1.0 \u2502 0.548402 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.2 \u2502 0.18 \u2502 0.246914 \u2502 1.0 \u2502 0.619257 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.25 \u2502 0.21875 \u2502 0.408163 \u2502 1.0 \u2502 0.522903 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.05 \u2502 0.04875 \u2502 0.0131492 \u2502 1.0 \u2502 0.908707 \u2502 0.987085 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.45 \u2502 0.39875 \u2502 0.330382 \u2502 1.0 \u2502 0.565434 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.05 \u2502 0.04875 \u2502 0.0131492 \u2502 1.0 \u2502 0.908707 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.4 \u2502 0.375 \u2502 0.0888889 \u2502 1.0 \u2502 0.765594 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.15 \u2502 0.13875 \u2502 0.131483 \u2502 1.0 \u2502 0.7169 \u2502 0.987085 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.15 \u2502 0.13875 \u2502 0.131483 \u2502 1.0 \u2502 0.7169 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502, Mideast Gulf = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.5 \u2502 0.436224 \u2502 0.598475 \u2502 1.0 \u2502 0.439161 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.214286 \u2502 0.191327 \u2502 0.4032 \u2502 1.0 \u2502 0.525441 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.178571 \u2502 0.21875 \u2502 0.944606 \u2502 1.0 \u2502 0.331096 \u2502 0.898252 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.107143 \u2502 0.101403 \u2502 0.0897116 \u2502 1.0 \u2502 0.764544 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.357143 \u2502 0.336735 \u2502 0.102847 \u2502 1.0 \u2502 0.74844 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.535714 \u2502 0.484056 \u2502 0.318893 \u2502 1.0 \u2502 0.572274 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.178571 \u2502 0.162628 \u2502 0.269127 \u2502 1.0 \u2502 0.603918 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.0357143 \u2502 0.101403 \u2502 11.75 \u2502 1.0 \u2502 0.000608429 \u2502 0.00278639 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.285714 \u2502 0.336735 \u2502 0.642792 \u2502 1.0 \u2502 0.422702 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 0.0 \u2502 missing \u2502 missing \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.107143 \u2502 0.101403 \u2502 0.0897116 \u2502 1.0 \u2502 0.764544 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0714286 \u2502 0.135204 \u2502 28.0414 \u2502 3.0 \u2502 3.56005e-6 \u2502 3.64412e-5 \u2502, Northeast Gulf = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.428571 \u2502 0.375 \u2502 0.571429 \u2502 1.0 \u2502 0.449692 \u2502 0.987085 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.321429 \u2502 0.392219 \u2502 0.912124 \u2502 1.0 \u2502 0.339552 \u2502 0.903179 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.214286 \u2502 0.191327 \u2502 0.4032 \u2502 1.0 \u2502 0.525441 \u2502 0.987085 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.25 \u2502 0.21875 \u2502 0.571429 \u2502 1.0 \u2502 0.449692 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.285714 \u2502 0.336735 \u2502 0.642792 \u2502 1.0 \u2502 0.422702 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.107143 \u2502 0.101403 \u2502 0.0897116 \u2502 1.0 \u2502 0.764544 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.142857 \u2502 0.132653 \u2502 0.16568 \u2502 1.0 \u2502 0.68398 \u2502 0.987085 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.464286 \u2502 0.448342 \u2502 0.0354101 \u2502 1.0 \u2502 0.850739 \u2502 0.987085 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.0357143 \u2502 0.0350765 \u2502 0.0092562 \u2502 1.0 \u2502 0.923354 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.0688776 \u2502 28.0 \u2502 1.0 \u2502 1.21315e-7 \u2502 1.87007e-6 \u2502, Southeast Gulf = 2213\u00d77 DataFrame \u2502 Row \u2502 locus \u2502 het_obs \u2502 het_exp \u2502 \u03c7\u00b2 \u2502 DF \u2502 P \u2502 Pcorr \u2502 \u2502 \u2502 String \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 Float64\u2370 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0.433333 \u2502 0.375 \u2502 0.725926 \u2502 1.0 \u2502 0.394207 \u2502 0.980648 \u2502 \u2502 2 \u2502 contig_23109 \u2502 0.2 \u2502 0.231111 \u2502 0.543639 \u2502 1.0 \u2502 0.460928 \u2502 0.987085 \u2502 \u2502 3 \u2502 contig_4493 \u2502 0.133333 \u2502 0.18 \u2502 2.01646 \u2502 1.0 \u2502 0.155601 \u2502 0.540012 \u2502 \u2502 4 \u2502 contig_10742 \u2502 0.0666667 \u2502 0.0644444 \u2502 0.0356718 \u2502 1.0 \u2502 0.850195 \u2502 0.987085 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0.2 \u2502 0.18 \u2502 0.37037 \u2502 1.0 \u2502 0.542802 \u2502 0.987085 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0.0333333 \u2502 0.0327778 \u2502 0.00861821 \u2502 1.0 \u2502 0.926035 \u2502 0.987085 \u2502 \u22ee \u2502 2207 \u2502 contig_18959 \u2502 0.466667 \u2502 0.42 \u2502 0.37037 \u2502 1.0 \u2502 0.542802 \u2502 0.987085 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 0.1 \u2502 0.095 \u2502 0.0831025 \u2502 1.0 \u2502 0.773136 \u2502 0.987085 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 0.133333 \u2502 0.124444 \u2502 0.153061 \u2502 1.0 \u2502 0.695627 \u2502 0.987085 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0.433333 \u2502 0.375 \u2502 0.725926 \u2502 1.0 \u2502 0.394207 \u2502 0.980648 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 0.0666667 \u2502 0.0644444 \u2502 0.0356718 \u2502 1.0 \u2502 0.850195 \u2502 0.987085 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 0.133333 \u2502 0.124444 \u2502 0.153061 \u2502 1.0 \u2502 0.695627 \u2502 0.987085 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 0.0 \u2502 0.124444 \u2502 30.0 \u2502 1.0 \u2502 4.32046e-8 \u2502 7.21496e-7 \u2502)","title":"example"},{"location":"analyses/hardyweinberg/#pro-tip","text":"If using by_pop = true , there may be a very long output which you may want to suppress by ending the command with a semicolon ; . The function returns a NamedTuple of DataFrames, meaning you can index it with a dot . operator. If you assign the command's output to a variable, such as hardy = hwe_test(gulfsharks(), by_pop = true) ; , then you can index the output with the population names, such as hardy.CapeCanaveral or hardy.Georgia . And since those objects are DataFrames, you can continue using the dot . operator to index them further by column, such as hardy.Georgia.Pcorr to see only the corrected P values. Convenience! indexing the Chiq-sq column The Fast(er) Way : you can just index the column using the DataFrames numerical index like so: df[!, 4] The Fun Way: to index the chi-squared column from the dataframe using the dot operator (i.e. df.\u03c7\u00b2 ), you will need to use the unicode characters in Julia, b/c the column is literally named \u03c7\u00b2. To generate those characters, type in \\Chi + press TAB + type in \\^2 + press TAB without spaces and it will magically appear (in the REPL and Juno, at least). Written out in more explicit English (we really want you to get it!), it's a backslash \\ , the word Chi with a capital C, the TAB key on your keyboard (and you'll notice it's already changed it to the letter \u03c7), another backslash \\ , a caret ^ , the number 2 , then the TAB key again. All in all, you'll be doing this: \\ChiTAB\\^2TAB . It's actually a lot easier than it looks.","title":"pro tip"},{"location":"analyses/relatedness/","text":"Background Sometimes you want or need to know the relatedness of individuals in a sample. Relatedness is exactly what its name implies: how related individuals are given some provided genetic information. Relatedness can be used in quantitative genetics to estimate heritability, additive genetic variances, and covariances. It can also be used in population genetics to study isolation-by-distance or population structure. The goal of calculating relatedness from molecular markers is to accurately estimate the proportion of the genome which is identical by descent between two individuals. With a pedigree this is \"relatively\" straightforward. However, for large, natural, populations pedigrees tend not to exist and so many brilliant minds have developed various equations and algorithms to estimate the relatedness from a set of molecular markers. Given two diploid individuals, there are 9 \"identity by descent\" models available between them ( Jacquard 1975 , paywall), as shown below (from Milligan 2003 ): Broadly speaking there are two different ways of estimating genetic relatedness using molecular markers, methods of moments, and likelihood estimators. Generally moments estimators will be faster but aren't constrained to being between the theoretical minimum and maximum values of 0 and 1. The likelihood estimators use likelihood functions derived from the set of Jacquard Identity States (above) to determine the most likely inheritance pattern. One difference between the two classes is [generally] moments estimators require an assumption of no inbreeding, while that assumption isn't necessarily required for likelihood estimators (though it does simplify the math). It is increasingly common to use multiple estimators on pairs, simulated from your molecular marker, with a known relationships to determine the most appropriate estimator to use with your given data. PopGen.jl currently implements one of each class of estimator. The moments based estimator developed by Queller & Goodnight 1989 using the variant defined by Lynch & Ritland 1999 and the likelihood estimator created by Milligan 2003 . You can imagine there's a lot that happens under the hood to perform this for all loci across all individuals-- all of which dutifully written by Jason Selwyn . About removing kin There are reasons for removing kin in population genetics datasets. For one, there are no siblings/kin or mixed-generations in a Hardy-Weinberg Equilibrium population, and the inclusion of siblings/kin in analyses that rely on HWE assumptions [technically] violate those assumptions. However, there are also arguments to keep kin/siblings in your data, those data are important for effective population size, linkage disequilibrium, etc. Waples and Anderson (2017) published a great perspective on the matter. Calculate Relatedness Calculate the relatedness of all pairs of individuals in the dataframe using either Milligan's Dyadic Maximum Likelihood estimator or Queller & Goodnight's estimator. pairwise_relatedness ( data :: PopObj ; method :: String , inbreeding :: Bool = true , verbose :: Bool = true ) arguments data : the input PopObj keyword arguments method : Method of relatedness estimation (see below) inbreeding : Include the possibility of inbreeding (true) or not (false) - Only used with method = \"dyadml\" verbose : If false only progress bar will be shown. If true extra output will be shown depending on the method chosen method methods \"dyadml\" : Milligan (2003) Dyadic Likelihood Relatedness \"qg\" : Queller & Goodnight (1989) Relatedness example relatedness cats = nancycats () ; pairwise_relatedness ( cats , method = \"qg\" , verbose = false ) output See Development for all of the APIs associated with relatedness() Speed Depending on the number samples and loci in your data, the maximum-likelihood approach to relatedness can be quite time consuming. We include a progress bar thanks to ProgressMeter.jl to provide some indication of how long it will take. As a point of reference, it takes approximately 13 hours to perform this relatedness calculation on the gulfsharks data (212 samples x 2213 loci). Currently, relatedness calculations run single-threaded, and we hope to parallelize it with the stable release of Julia 1.3 to make it even faster. Many hands make light work! Acknowledgements Both Convex.jl and ECOS.jl are pivotal for these calculations, and we thank the authors for their time developing and maintaining them, along with the members of the Julia Slack channel for pointing us towards those packages.","title":"Relatedness"},{"location":"analyses/relatedness/#background","text":"Sometimes you want or need to know the relatedness of individuals in a sample. Relatedness is exactly what its name implies: how related individuals are given some provided genetic information. Relatedness can be used in quantitative genetics to estimate heritability, additive genetic variances, and covariances. It can also be used in population genetics to study isolation-by-distance or population structure. The goal of calculating relatedness from molecular markers is to accurately estimate the proportion of the genome which is identical by descent between two individuals. With a pedigree this is \"relatively\" straightforward. However, for large, natural, populations pedigrees tend not to exist and so many brilliant minds have developed various equations and algorithms to estimate the relatedness from a set of molecular markers. Given two diploid individuals, there are 9 \"identity by descent\" models available between them ( Jacquard 1975 , paywall), as shown below (from Milligan 2003 ): Broadly speaking there are two different ways of estimating genetic relatedness using molecular markers, methods of moments, and likelihood estimators. Generally moments estimators will be faster but aren't constrained to being between the theoretical minimum and maximum values of 0 and 1. The likelihood estimators use likelihood functions derived from the set of Jacquard Identity States (above) to determine the most likely inheritance pattern. One difference between the two classes is [generally] moments estimators require an assumption of no inbreeding, while that assumption isn't necessarily required for likelihood estimators (though it does simplify the math). It is increasingly common to use multiple estimators on pairs, simulated from your molecular marker, with a known relationships to determine the most appropriate estimator to use with your given data. PopGen.jl currently implements one of each class of estimator. The moments based estimator developed by Queller & Goodnight 1989 using the variant defined by Lynch & Ritland 1999 and the likelihood estimator created by Milligan 2003 . You can imagine there's a lot that happens under the hood to perform this for all loci across all individuals-- all of which dutifully written by Jason Selwyn .","title":"Background"},{"location":"analyses/relatedness/#about-removing-kin","text":"There are reasons for removing kin in population genetics datasets. For one, there are no siblings/kin or mixed-generations in a Hardy-Weinberg Equilibrium population, and the inclusion of siblings/kin in analyses that rely on HWE assumptions [technically] violate those assumptions. However, there are also arguments to keep kin/siblings in your data, those data are important for effective population size, linkage disequilibrium, etc. Waples and Anderson (2017) published a great perspective on the matter.","title":"About removing kin"},{"location":"analyses/relatedness/#calculate-relatedness","text":"Calculate the relatedness of all pairs of individuals in the dataframe using either Milligan's Dyadic Maximum Likelihood estimator or Queller & Goodnight's estimator. pairwise_relatedness ( data :: PopObj ; method :: String , inbreeding :: Bool = true , verbose :: Bool = true )","title":"Calculate Relatedness"},{"location":"analyses/relatedness/#arguments","text":"data : the input PopObj","title":"arguments"},{"location":"analyses/relatedness/#keyword-arguments","text":"method : Method of relatedness estimation (see below) inbreeding : Include the possibility of inbreeding (true) or not (false) - Only used with method = \"dyadml\" verbose : If false only progress bar will be shown. If true extra output will be shown depending on the method chosen","title":"keyword arguments"},{"location":"analyses/relatedness/#method-methods","text":"\"dyadml\" : Milligan (2003) Dyadic Likelihood Relatedness \"qg\" : Queller & Goodnight (1989) Relatedness","title":"method methods"},{"location":"analyses/relatedness/#example","text":"relatedness cats = nancycats () ; pairwise_relatedness ( cats , method = \"qg\" , verbose = false ) output See Development for all of the APIs associated with relatedness()","title":"example"},{"location":"analyses/relatedness/#speed","text":"Depending on the number samples and loci in your data, the maximum-likelihood approach to relatedness can be quite time consuming. We include a progress bar thanks to ProgressMeter.jl to provide some indication of how long it will take. As a point of reference, it takes approximately 13 hours to perform this relatedness calculation on the gulfsharks data (212 samples x 2213 loci). Currently, relatedness calculations run single-threaded, and we hope to parallelize it with the stable release of Julia 1.3 to make it even faster. Many hands make light work!","title":"Speed"},{"location":"analyses/relatedness/#acknowledgements","text":"Both Convex.jl and ECOS.jl are pivotal for these calculations, and we thank the authors for their time developing and maintaining them, along with the members of the Julia Slack channel for pointing us towards those packages.","title":"Acknowledgements"},{"location":"getting_started/accessing_popdata/","text":"A little hands-on training will probably go a long way, so let's through some of the functions available in PopGen.jl with the included data. This tutorial will include both inputs and outputs so you can be confident what you're seeing in your Julia session is exactly what's supposed to happen. Sometimes the outputs can be a little lengthy, so they will be arranged in code \"tabs\", where the left-most tab is the input named after what it's accomplishing, and the right tab is the output of running the command. This guide is to show you how to directly access PopData elements, but there are shortcut commands to view just about every element of the data within. What to avoid! There are specific relationships between the record entries in PopData objects, so do not use sort , sort! , or manually arrange/add/delete anything in PopData. There are included functions to remove samples or loci, rename things, add location data, etc. Loading in the data Let's keep things simple by loading in the nancycats data and calling it ncats . load nancycats julia > ncats = nancycats () ; summary ( ncats ) output PopData Object Marker type: Microsatellite Ploidy: 2 Number of individuals: 237 Number of loci: 9 Populations: 17 Longitude: absent Latitude: absent Now that we have nancycats loaded in, we can use standard Julia accessor conventions to view the elements within our PopData. The IndexedTable format requires a little extra work, so we must use the convention PopData.meta.columns.colname to directly access the columns we want. The metadata table .meta To view the entire meta table. .meta julia > ncats . meta output Table with 237 rows , 5 columns : name population ploidy latitude longitude \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"N1\" \"1\" 2 missing missing \"N2\" \"1\" 2 missing missing \"N3\" \"1\" 2 missing missing \"N4\" \"1\" 2 missing missing \"N5\" \"1\" 2 missing missing \"N6\" \"1\" 2 missing missing \"N7\" \"1\" 2 missing missing \"N8\" \"1\" 2 missing missing \u22ee \"N231\" \"17\" 2 missing missing \"N232\" \"17\" 2 missing missing \"N233\" \"17\" 2 missing missing \"N234\" \"17\" 2 missing missing \"N235\" \"17\" 2 missing missing \"N236\" \"17\" 2 missing missing \"N237\" \"17\" 2 missing missing .name This will access the names of the samples. .ind julia > ncats . meta . columns . name output 237-element Array{String,1}: \"N1\" \"N2\" \"N3\" \"N4\" \"N5\" \"N6\" \"N7\" \"N8\" \u22ee \"N230\" \"N231\" \"N232\" \"N233\" \"N234\" \"N235\" \"N236\" \"N237\" .population This will access the names of the populations associated with each sample, in the same order as the samples. .popid julia > ncats . meta . columns . population output 237-element Array{String,1}: \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \u22ee \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" These ID's aren't super informative. Later, we'll change them using the popid! command. .ploidy This shows you the ploidy of the data per individual .ploidy julia > ncats . meta . columns . ploidy output 237-element Array{Int8,1}: 2 2 2 2 2 2 2 2 \u22ee 2 2 2 2 2 2 2 2 .latitude This accesses the latitude information of the PopObj. If there is none, like in the nancycats data, it returns a vector of missing . .latitude julia > ncats . meta . columns . latitude output 237-element Array{Union{Missing, Float32},1}: missing missing missing missing missing missing missing missing \u22ee missing missing missing missing missing missing missing missing .longitude This accesses the longitude information of the PopObj. Like before, if there is none, like in the nancycats data, it returns an array of missing . .longitude julia > ncats . meta . columns . longitude output 237-element Array{Union{Missing, Float32},1}: missing missing missing missing missing missing missing missing \u22ee missing missing missing missing missing missing missing missing actually seeing some location info The nancycats data has some weird coordinate system for information, so those data were omitted. If you want a proof of concept for .longitude and .latitude , load in gulfsharks and try it out. We'll use hcat (horizontal concatination) to horizontally bind the individual names, their latitude, and longitude. Later, you'll see that the locations command does this. load gulfsharks julia > sharks = gulfsharks () ; # semicolon just supresses printing output julia > hcat ( sharks . meta . columns . name , sharks . meta . columns . latitude , sharks . meta . columns . longitude ) output 212\u00d73 Array{Any,2}: \"cc_001\" 28.3062 -80.5993 \"cc_002\" 28.3079 -80.5995 \"cc_003\" 28.3023 -80.5996 \"cc_005\" 28.6123 -80.4225 \"cc_007\" 27.8666 -80.3578 \"cc_008\" 27.8666 -80.3579 \"cc_009\" 27.8682 -80.3482 \"cc_010\" 27.8711 -80.3482 \"cc_012\" 28.4815 -80.4303 \"cc_013\" 28.2421 -80.2494 \u22ee \"seg_021\" 29.9466 -86.0399 \"seg_023\" 29.9969 -85.6494 \"seg_024\" 29.6966 -87.4403 \"seg_025\" 30.064 -86.5374 \"seg_026\" 30.0696 -86.5376 \"seg_027\" 29.9065 -86.0905 \"seg_028\" 30.0532 -87.3661 \"seg_029\" 30.0522 -87.3662 \"seg_030\" 29.8234 -85.7143 \"seg_031\" 29.8234 -85.7143 The genotype table .loci This will show you the entire loci table. .loci julia > ncats . loci output Table with 2133 rows, 4 columns: name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"N1\" \"1\" \"fca8\" missing \"N1\" \"1\" \"fca23\" (4, 9) \"N1\" \"1\" \"fca43\" (4, 4) \"N1\" \"1\" \"fca45\" (1, 3) \"N1\" \"1\" \"fca77\" (9, 9) \"N1\" \"1\" \"fca78\" (3, 6) \"N1\" \"1\" \"fca90\" (9, 9) \"N1\" \"1\" \"fca96\" (8, 8) \u22ee \"N237\" \"17\" \"fca45\" missing \"N237\" \"17\" \"fca77\" (6, 9) \"N237\" \"17\" \"fca78\" (3, 7) \"N237\" \"17\" \"fca90\" (8, 8) \"N237\" \"17\" \"fca96\" missing \"N237\" \"17\" \"fca37\" (10, 10) locus names This will access the names of the loci as they appear in the data. .loci julia > levels ( ncats . loci . columns . locus ) output 9-element Array{String,1}: \"fca8\" \"fca23\" \"fca43\" \"fca45\" \"fca77\" \"fca78\" \"fca90\" \"fca96\" \"fca37\" Since everything but the genotypes in .loci are coded as Categorical, we need to use levels() from CategoricalArrays.jl to pull out the unique loci, or use unique() from Base to accomplish the same. view genotypes Because the genotype data is in \"tidy\" format, accessing genotypes is not immediately obvious. We can use the JuliaDB or JuliaDBMeta interfaces to retrieve this information. Here is an example using @where from JuliaDBMeta: single locus julia > @where ncats . loci : locus == \"fca8\" Table with 237 rows , 4 columns : name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"N1\" \"1\" \"fca8\" missing \"N2\" \"1\" \"fca8\" missing \"N3\" \"1\" \"fca8\" ( 9 , 13 ) \"N4\" \"1\" \"fca8\" ( 8 , 9 ) \"N5\" \"1\" \"fca8\" ( 8 , 9 ) \"N6\" \"1\" \"fca8\" ( 9 , 13 ) \"N7\" \"1\" \"fca8\" ( 9 , 9 ) \"N8\" \"1\" \"fca8\" ( 9 , 13 ) \u22ee \"N232\" \"17\" \"fca8\" ( 8 , 12 ) \"N233\" \"17\" \"fca8\" ( 8 , 12 ) \"N234\" \"17\" \"fca8\" ( 8 , 13 ) \"N235\" \"17\" \"fca8\" ( 9 , 12 ) \"N236\" \"17\" \"fca8\" ( 10 , 13 ) \"N237\" \"17\" \"fca8\" ( 9 , 12 ) multiple loci julia > @where ncats . loci : locus in [ \"fca8\" , \"fca23\" ] Table with 474 rows , 4 columns : name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"N1\" \"1\" \"fca8\" missing \"N1\" \"1\" \"fca23\" ( 4 , 9 ) \"N2\" \"1\" \"fca8\" missing \"N2\" \"1\" \"fca23\" ( 9 , 9 ) \"N3\" \"1\" \"fca8\" ( 9 , 13 ) \"N3\" \"1\" \"fca23\" ( 4 , 9 ) \"N4\" \"1\" \"fca8\" ( 8 , 9 ) \"N4\" \"1\" \"fca23\" ( 5 , 5 ) \u22ee \"N235\" \"17\" \"fca8\" ( 9 , 12 ) \"N235\" \"17\" \"fca23\" ( 4 , 8 ) \"N236\" \"17\" \"fca8\" ( 10 , 13 ) \"N236\" \"17\" \"fca23\" ( 2 , 4 ) \"N237\" \"17\" \"fca8\" ( 9 , 12 ) \"N237\" \"17\" \"fca23\" ( 2 , 9 ) Now that you're somewhat familiar with the parts of PopData , have a look at the commands to view and manipulate PopData objects.","title":"Accessing parts of PopData"},{"location":"getting_started/accessing_popdata/#loading-in-the-data","text":"Let's keep things simple by loading in the nancycats data and calling it ncats . load nancycats julia > ncats = nancycats () ; summary ( ncats ) output PopData Object Marker type: Microsatellite Ploidy: 2 Number of individuals: 237 Number of loci: 9 Populations: 17 Longitude: absent Latitude: absent Now that we have nancycats loaded in, we can use standard Julia accessor conventions to view the elements within our PopData. The IndexedTable format requires a little extra work, so we must use the convention PopData.meta.columns.colname to directly access the columns we want.","title":"Loading in the data"},{"location":"getting_started/accessing_popdata/#the-metadata-table","text":"","title":"The metadata table"},{"location":"getting_started/accessing_popdata/#meta","text":"To view the entire meta table. .meta julia > ncats . meta output Table with 237 rows , 5 columns : name population ploidy latitude longitude \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"N1\" \"1\" 2 missing missing \"N2\" \"1\" 2 missing missing \"N3\" \"1\" 2 missing missing \"N4\" \"1\" 2 missing missing \"N5\" \"1\" 2 missing missing \"N6\" \"1\" 2 missing missing \"N7\" \"1\" 2 missing missing \"N8\" \"1\" 2 missing missing \u22ee \"N231\" \"17\" 2 missing missing \"N232\" \"17\" 2 missing missing \"N233\" \"17\" 2 missing missing \"N234\" \"17\" 2 missing missing \"N235\" \"17\" 2 missing missing \"N236\" \"17\" 2 missing missing \"N237\" \"17\" 2 missing missing","title":".meta"},{"location":"getting_started/accessing_popdata/#name","text":"This will access the names of the samples. .ind julia > ncats . meta . columns . name output 237-element Array{String,1}: \"N1\" \"N2\" \"N3\" \"N4\" \"N5\" \"N6\" \"N7\" \"N8\" \u22ee \"N230\" \"N231\" \"N232\" \"N233\" \"N234\" \"N235\" \"N236\" \"N237\"","title":".name"},{"location":"getting_started/accessing_popdata/#population","text":"This will access the names of the populations associated with each sample, in the same order as the samples. .popid julia > ncats . meta . columns . population output 237-element Array{String,1}: \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \u22ee \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" These ID's aren't super informative. Later, we'll change them using the popid! command.","title":".population"},{"location":"getting_started/accessing_popdata/#ploidy","text":"This shows you the ploidy of the data per individual .ploidy julia > ncats . meta . columns . ploidy output 237-element Array{Int8,1}: 2 2 2 2 2 2 2 2 \u22ee 2 2 2 2 2 2 2 2","title":".ploidy"},{"location":"getting_started/accessing_popdata/#latitude","text":"This accesses the latitude information of the PopObj. If there is none, like in the nancycats data, it returns a vector of missing . .latitude julia > ncats . meta . columns . latitude output 237-element Array{Union{Missing, Float32},1}: missing missing missing missing missing missing missing missing \u22ee missing missing missing missing missing missing missing missing","title":".latitude"},{"location":"getting_started/accessing_popdata/#longitude","text":"This accesses the longitude information of the PopObj. Like before, if there is none, like in the nancycats data, it returns an array of missing . .longitude julia > ncats . meta . columns . longitude output 237-element Array{Union{Missing, Float32},1}: missing missing missing missing missing missing missing missing \u22ee missing missing missing missing missing missing missing missing actually seeing some location info The nancycats data has some weird coordinate system for information, so those data were omitted. If you want a proof of concept for .longitude and .latitude , load in gulfsharks and try it out. We'll use hcat (horizontal concatination) to horizontally bind the individual names, their latitude, and longitude. Later, you'll see that the locations command does this. load gulfsharks julia > sharks = gulfsharks () ; # semicolon just supresses printing output julia > hcat ( sharks . meta . columns . name , sharks . meta . columns . latitude , sharks . meta . columns . longitude ) output 212\u00d73 Array{Any,2}: \"cc_001\" 28.3062 -80.5993 \"cc_002\" 28.3079 -80.5995 \"cc_003\" 28.3023 -80.5996 \"cc_005\" 28.6123 -80.4225 \"cc_007\" 27.8666 -80.3578 \"cc_008\" 27.8666 -80.3579 \"cc_009\" 27.8682 -80.3482 \"cc_010\" 27.8711 -80.3482 \"cc_012\" 28.4815 -80.4303 \"cc_013\" 28.2421 -80.2494 \u22ee \"seg_021\" 29.9466 -86.0399 \"seg_023\" 29.9969 -85.6494 \"seg_024\" 29.6966 -87.4403 \"seg_025\" 30.064 -86.5374 \"seg_026\" 30.0696 -86.5376 \"seg_027\" 29.9065 -86.0905 \"seg_028\" 30.0532 -87.3661 \"seg_029\" 30.0522 -87.3662 \"seg_030\" 29.8234 -85.7143 \"seg_031\" 29.8234 -85.7143","title":".longitude"},{"location":"getting_started/accessing_popdata/#the-genotype-table","text":"","title":"The genotype table"},{"location":"getting_started/accessing_popdata/#loci","text":"This will show you the entire loci table. .loci julia > ncats . loci output Table with 2133 rows, 4 columns: name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"N1\" \"1\" \"fca8\" missing \"N1\" \"1\" \"fca23\" (4, 9) \"N1\" \"1\" \"fca43\" (4, 4) \"N1\" \"1\" \"fca45\" (1, 3) \"N1\" \"1\" \"fca77\" (9, 9) \"N1\" \"1\" \"fca78\" (3, 6) \"N1\" \"1\" \"fca90\" (9, 9) \"N1\" \"1\" \"fca96\" (8, 8) \u22ee \"N237\" \"17\" \"fca45\" missing \"N237\" \"17\" \"fca77\" (6, 9) \"N237\" \"17\" \"fca78\" (3, 7) \"N237\" \"17\" \"fca90\" (8, 8) \"N237\" \"17\" \"fca96\" missing \"N237\" \"17\" \"fca37\" (10, 10)","title":".loci"},{"location":"getting_started/accessing_popdata/#locus-names","text":"This will access the names of the loci as they appear in the data. .loci julia > levels ( ncats . loci . columns . locus ) output 9-element Array{String,1}: \"fca8\" \"fca23\" \"fca43\" \"fca45\" \"fca77\" \"fca78\" \"fca90\" \"fca96\" \"fca37\" Since everything but the genotypes in .loci are coded as Categorical, we need to use levels() from CategoricalArrays.jl to pull out the unique loci, or use unique() from Base to accomplish the same.","title":"locus names"},{"location":"getting_started/accessing_popdata/#view-genotypes","text":"Because the genotype data is in \"tidy\" format, accessing genotypes is not immediately obvious. We can use the JuliaDB or JuliaDBMeta interfaces to retrieve this information. Here is an example using @where from JuliaDBMeta: single locus julia > @where ncats . loci : locus == \"fca8\" Table with 237 rows , 4 columns : name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"N1\" \"1\" \"fca8\" missing \"N2\" \"1\" \"fca8\" missing \"N3\" \"1\" \"fca8\" ( 9 , 13 ) \"N4\" \"1\" \"fca8\" ( 8 , 9 ) \"N5\" \"1\" \"fca8\" ( 8 , 9 ) \"N6\" \"1\" \"fca8\" ( 9 , 13 ) \"N7\" \"1\" \"fca8\" ( 9 , 9 ) \"N8\" \"1\" \"fca8\" ( 9 , 13 ) \u22ee \"N232\" \"17\" \"fca8\" ( 8 , 12 ) \"N233\" \"17\" \"fca8\" ( 8 , 12 ) \"N234\" \"17\" \"fca8\" ( 8 , 13 ) \"N235\" \"17\" \"fca8\" ( 9 , 12 ) \"N236\" \"17\" \"fca8\" ( 10 , 13 ) \"N237\" \"17\" \"fca8\" ( 9 , 12 ) multiple loci julia > @where ncats . loci : locus in [ \"fca8\" , \"fca23\" ] Table with 474 rows , 4 columns : name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"N1\" \"1\" \"fca8\" missing \"N1\" \"1\" \"fca23\" ( 4 , 9 ) \"N2\" \"1\" \"fca8\" missing \"N2\" \"1\" \"fca23\" ( 9 , 9 ) \"N3\" \"1\" \"fca8\" ( 9 , 13 ) \"N3\" \"1\" \"fca23\" ( 4 , 9 ) \"N4\" \"1\" \"fca8\" ( 8 , 9 ) \"N4\" \"1\" \"fca23\" ( 5 , 5 ) \u22ee \"N235\" \"17\" \"fca8\" ( 9 , 12 ) \"N235\" \"17\" \"fca23\" ( 4 , 8 ) \"N236\" \"17\" \"fca8\" ( 10 , 13 ) \"N236\" \"17\" \"fca23\" ( 2 , 4 ) \"N237\" \"17\" \"fca8\" ( 9 , 12 ) \"N237\" \"17\" \"fca23\" ( 2 , 9 ) Now that you're somewhat familiar with the parts of PopData , have a look at the commands to view and manipulate PopData objects.","title":"view genotypes"},{"location":"getting_started/comparison/","text":"Comparison to adegenet / pegas There's a reason we started investing so many hours and so many new grey hairs into writing PopGen.jl when there was an existing ecosystem in R to perform these same tasks. Like we explain in the home page of these docs, we want a platform that is: fast(er) written in a single language easy to use So, we'd like to prove that Julia and PopGen.jl actually achieves that by showing a few benchmarks comparing PopGen.jl to adegenet and pegas , which along with ape are arguably the most commonly used and robust population genetic packages available. It's worth mentioning that we ourselves use and have published work incorporating these packages, and are tremendously grateful for the work invested in those packages. We appreciate those folks and have tremendous respect and envy for the work they continue to do! Here are links to adegenet , pegas , and ape . Benchmarks To make this a practical comparison, we're going to use the gulfsharks data because it is considerably larger (212 samples x 2213 loci) than nancycats (237 x 9) and a bit more of a \"stress test\". All benchmarks in R are performed using the microbenchmark package, and BenchmarkTools are used for Julia. loading R packages library ( adegenet ) library ( pegas ) library ( microbenchmark ) loading julia packages using BenchmarkTools , PopGen As a note, the reported benchmarks are being performed on a 64-bit Manjaro Linux system on a nothing-special Lenovo Thinkbook 14S with 8gigs of RAM and a 8 th gen Intel i5 mobile processor. Note: all of the Julia benchmarks, unless explicitly stated, are performed single-threaded (i.e. not parallel, distributed, or GPU). Loading in data Since gulfsharks is shamelessly provided in PopGen.jl, we simply invoke the gulfsharks() command in Julia. If you would like to try this yourself in R, find the gulfsharks.gen file in the package repository under /data/data/gulfsharks.gen . It will print out the input filename several times, which is omitted below for clarity. Since the file importer now uses CSV.jl to read in the file, there are two steps of the genepop parser that are multithreaded. However, the majority of the data parsing (formatting the raw data into a correct PopObj structure) occurs using a single thread. Julia julia > @btime x = gulfsharks () ; # hide the output 1.049 s ( 2472280 allocations : 166.30 MiB ) This R benchmark will take a few minutes. Consider making some tea while you wait. R > microbenchmark ( read.genepop ( file = \"/home/pdimens/gulfsharks.gen\" , ncode = 3L , quiet = TRUE )) Unit : seconds read.genepop ( file = \"/home/pdimens/gulfsharks.gen\" , ncode = 3L , quiet = FALSE ) min lq mean median uq max neval 5.670637 6.218719 6.745065 6.387936 7.019667 9.173005 100 Comparing averages, PopGen.jl clocks in at 1.049s versus adegenet's 6.745s , so ~6.4x faster. Julia | R PopObj vs genind size It was pretty tricky to come up with a sensible/efficient/convenient data structure for PopGen.jl, and the original attempt was a Julian variant to a genind , which itself is something known as an S4 class object . While the two-dataframes design might not seem like it took a lot of effort, we ultimately decided that the column-major style and available tools, combined with careful genotype Typing was a decent \"middle-ground\" of ease-of-use vs performance. We may one day change this when IndexedTables facilitates so many columns. Plus, we are suckers for consistent syntax, which genind 's don't have compared to standard R syntax (looking at you too, Tidyverse/ggplot!). Anyway , it's important to understand how much space your data will take up in memory (your RAM) when you load it in, especially since data's only getting bigger! Keep in mind that gulfsharks() in PopGen.jl also provides lat/long data, which should inflate the size of the object somewhat compared to the genind , which we won't add any location data to. Julia julia > Base . summarysize ( x ) 1612428 #bytes versus R > object.size ( gen ) 5331536 bytes What sorcery is this?! Well, it's all in the Typing of the genotypes. Each genotype for each locus is encoded as a Tuple of either Int8 (if SNPs) or Int16 (if msats) to absolutely minimize their footprint without further going into byte-level encoding (so you can still see human-readable alleles). An Int8 is a signed integer that occupies 8bits of memory, whereas an Int16 occupies 16bits (as compared to a standard Int64 ). The original file is 3.2mb , and our PopObj takes up ~ 1.6mb in memory (half as big as the source file!) versus the ~ 5.3mb of a genind , which is ~1.5x larger than the source file and ~3.3x larger than our PopObj . That's quite a big difference! Julia \u200b | R Chi-squared test for HWE This is a classic population genetics test and a relatively simple one. Julia julia > @btime hwe_test ( x , correction = \"bh\" ) ; 392.527 ms ( 1599668 allocations : 57.20 MiB ) The R benchmark will take a while again, so if you're following along, this would be a good time to reconnect with an old friend. R > microbenchmark ( hw.test ( gen , B = 0 )) Unit : seconds expr min lq mean median uq max neval hw.test ( gen , B = 0 ) 5.100298 5.564807 6.265948 5.878842 6.917006 8.815179 100 Comparing averages, PopGen.jl clocks in at ~ 400ms versus adegenet's 6.3s , so ~15x faster. Julia | R","title":"Benchmarks"},{"location":"getting_started/comparison/#comparison-to-adegenet-pegas","text":"There's a reason we started investing so many hours and so many new grey hairs into writing PopGen.jl when there was an existing ecosystem in R to perform these same tasks. Like we explain in the home page of these docs, we want a platform that is: fast(er) written in a single language easy to use So, we'd like to prove that Julia and PopGen.jl actually achieves that by showing a few benchmarks comparing PopGen.jl to adegenet and pegas , which along with ape are arguably the most commonly used and robust population genetic packages available. It's worth mentioning that we ourselves use and have published work incorporating these packages, and are tremendously grateful for the work invested in those packages. We appreciate those folks and have tremendous respect and envy for the work they continue to do! Here are links to adegenet , pegas , and ape .","title":"Comparison to adegenet / pegas"},{"location":"getting_started/comparison/#benchmarks","text":"To make this a practical comparison, we're going to use the gulfsharks data because it is considerably larger (212 samples x 2213 loci) than nancycats (237 x 9) and a bit more of a \"stress test\". All benchmarks in R are performed using the microbenchmark package, and BenchmarkTools are used for Julia. loading R packages library ( adegenet ) library ( pegas ) library ( microbenchmark ) loading julia packages using BenchmarkTools , PopGen As a note, the reported benchmarks are being performed on a 64-bit Manjaro Linux system on a nothing-special Lenovo Thinkbook 14S with 8gigs of RAM and a 8 th gen Intel i5 mobile processor. Note: all of the Julia benchmarks, unless explicitly stated, are performed single-threaded (i.e. not parallel, distributed, or GPU).","title":"Benchmarks"},{"location":"getting_started/comparison/#loading-in-data","text":"Since gulfsharks is shamelessly provided in PopGen.jl, we simply invoke the gulfsharks() command in Julia. If you would like to try this yourself in R, find the gulfsharks.gen file in the package repository under /data/data/gulfsharks.gen . It will print out the input filename several times, which is omitted below for clarity. Since the file importer now uses CSV.jl to read in the file, there are two steps of the genepop parser that are multithreaded. However, the majority of the data parsing (formatting the raw data into a correct PopObj structure) occurs using a single thread. Julia julia > @btime x = gulfsharks () ; # hide the output 1.049 s ( 2472280 allocations : 166.30 MiB ) This R benchmark will take a few minutes. Consider making some tea while you wait. R > microbenchmark ( read.genepop ( file = \"/home/pdimens/gulfsharks.gen\" , ncode = 3L , quiet = TRUE )) Unit : seconds read.genepop ( file = \"/home/pdimens/gulfsharks.gen\" , ncode = 3L , quiet = FALSE ) min lq mean median uq max neval 5.670637 6.218719 6.745065 6.387936 7.019667 9.173005 100 Comparing averages, PopGen.jl clocks in at 1.049s versus adegenet's 6.745s , so ~6.4x faster. Julia | R","title":"Loading in data"},{"location":"getting_started/comparison/#popobj-vs-genind-size","text":"It was pretty tricky to come up with a sensible/efficient/convenient data structure for PopGen.jl, and the original attempt was a Julian variant to a genind , which itself is something known as an S4 class object . While the two-dataframes design might not seem like it took a lot of effort, we ultimately decided that the column-major style and available tools, combined with careful genotype Typing was a decent \"middle-ground\" of ease-of-use vs performance. We may one day change this when IndexedTables facilitates so many columns. Plus, we are suckers for consistent syntax, which genind 's don't have compared to standard R syntax (looking at you too, Tidyverse/ggplot!). Anyway , it's important to understand how much space your data will take up in memory (your RAM) when you load it in, especially since data's only getting bigger! Keep in mind that gulfsharks() in PopGen.jl also provides lat/long data, which should inflate the size of the object somewhat compared to the genind , which we won't add any location data to. Julia julia > Base . summarysize ( x ) 1612428 #bytes versus R > object.size ( gen ) 5331536 bytes What sorcery is this?! Well, it's all in the Typing of the genotypes. Each genotype for each locus is encoded as a Tuple of either Int8 (if SNPs) or Int16 (if msats) to absolutely minimize their footprint without further going into byte-level encoding (so you can still see human-readable alleles). An Int8 is a signed integer that occupies 8bits of memory, whereas an Int16 occupies 16bits (as compared to a standard Int64 ). The original file is 3.2mb , and our PopObj takes up ~ 1.6mb in memory (half as big as the source file!) versus the ~ 5.3mb of a genind , which is ~1.5x larger than the source file and ~3.3x larger than our PopObj . That's quite a big difference! Julia \u200b | R","title":"PopObj vs genind size"},{"location":"getting_started/comparison/#chi-squared-test-for-hwe","text":"This is a classic population genetics test and a relatively simple one. Julia julia > @btime hwe_test ( x , correction = \"bh\" ) ; 392.527 ms ( 1599668 allocations : 57.20 MiB ) The R benchmark will take a while again, so if you're following along, this would be a good time to reconnect with an old friend. R > microbenchmark ( hw.test ( gen , B = 0 )) Unit : seconds expr min lq mean median uq max neval hw.test ( gen , B = 0 ) 5.100298 5.564807 6.265948 5.878842 6.917006 8.815179 100 Comparing averages, PopGen.jl clocks in at ~ 400ms versus adegenet's 6.3s , so ~15x faster. Julia | R","title":"Chi-squared test for HWE"},{"location":"getting_started/install/","text":"Installation Installing PopGen.jl The package is currently unregistered while it's under active early development. However, installation is still simple! In REPL or Juno Invoke the package manager with ] in the REPL and use add \"https://github.com/pdimens/PopGen.jl\" With Jupyter Notebooks or nteract using Pkg Pkg . add ( PackageSpec ( url = \"https://github.com/pdimens/PopGen.jl\" , rev = \"master\" )) Using PopGen Like all Julia packages, to activate PopGen.jl, simply run: julia > using PopGen Feel free to play around with the test data in /data/data/ or add it to your workspace with the nancycats and gulfsharks commands. Arch Linux users If you compiled Julia from source, your PopGen.jl installation may fail due to incorrectly building Arpack , which is expected to be in one place, but the compilation puts in another. Solutions: recommended to install official Julia binaries from the AUR ( julia-bin ), which includes a correctly bundled Arpack if Julia was compiled from source: install julia-arpack from the AUR and make sure to delete ~/.julia/packages/Arpack if it exists. That should fix things, but sometimes it still acts up.","title":"How to Install"},{"location":"getting_started/install/#installation","text":"","title":"Installation"},{"location":"getting_started/install/#installing-popgenjl","text":"The package is currently unregistered while it's under active early development. However, installation is still simple!","title":"Installing PopGen.jl"},{"location":"getting_started/install/#in-repl-or-juno","text":"Invoke the package manager with ] in the REPL and use add \"https://github.com/pdimens/PopGen.jl\"","title":"In REPL or Juno"},{"location":"getting_started/install/#with-jupyter-notebooks-or-nteract","text":"using Pkg Pkg . add ( PackageSpec ( url = \"https://github.com/pdimens/PopGen.jl\" , rev = \"master\" ))","title":"With Jupyter Notebooks or nteract"},{"location":"getting_started/install/#using-popgen","text":"Like all Julia packages, to activate PopGen.jl, simply run: julia > using PopGen Feel free to play around with the test data in /data/data/ or add it to your workspace with the nancycats and gulfsharks commands.","title":"Using PopGen"},{"location":"getting_started/install/#arch-linux-users","text":"If you compiled Julia from source, your PopGen.jl installation may fail due to incorrectly building Arpack , which is expected to be in one place, but the compilation puts in another. Solutions: recommended to install official Julia binaries from the AUR ( julia-bin ), which includes a correctly bundled Arpack if Julia was compiled from source: install julia-arpack from the AUR and make sure to delete ~/.julia/packages/Arpack if it exists. That should fix things, but sometimes it still acts up.","title":"Arch Linux users"},{"location":"getting_started/juliaprimer/","text":"A quick Julia primer for getting the most out of this documentation There is nothing inherently special about this documentation relative to other documentation, other than we really really want you to get the most out of what's written here. This means that we need to embrace the fact that both novice and experienced Julia users may be reading these docs and using this package. So let's cover some Julia basics that will really help in navigating this package before we even get into the complicated genetics stuff. This primer is by no means \"everything you need to get started in Julia\", and is a poor substitute for actually learning the language. In general, we recommend Think Julia: How to Think Like a Data Scientist by Ben Lauwens to establish some solid Julia foundations. It's free online! Also, the Julia language maintains its own great documentation that we rely on quite heavily for development. Using Julia Everyone has their own particular workflows, and if you're new to Julia, you might not have established one yet. Julia can be used rather comfortably using its built-in interpreter, but you can also use it via Atom (the officially supported uber-juno add-on) for an RStudio-like experience. If you're already a fan of Jupyter notebooks (or nteract ), then all you need is to install the IJulia package in Julia and you have full Jupyter support for Julia! Other popular options are VScode (julia add-on), or Emacs. If you didn't already know, the name \"Jupyter\" is actually a concatenation of Ju (julia) Pyt (python) and eR (R). \ud83e\udd2f First-time Performance If you're migrating to Julia from Python or R (or Matlab, etc.), you'll think Julia is slow and laggy because loading packages and running stuff has a noticeable wait time (10-40sec). It's worth mentioning that this lag is \"compilation overhead\". What this means is, Julia tries to pre-compile as much code as possible (into optimized machine code) when running something or loading a package. This lag exists only the first time you run something. Every subsequent run of a function, even with different parameters, will be substantially faster, and in most cases instant. If you want to test this yourself, try to run a line of code twice with @time before the function and compare the results. Here's an example: julia> @time using PopGen 17.415902 seconds (19.88 M allocations: 1.022 GiB, 2.79% gc time) julia> @time using PopGen 0.100233 seconds (64.07 k allocations: 3.123 MiB, 6.02% gc time) Semicolons Semicolons will come up a lot in Julia, probably more than you would expect if you are migrating from another language. They mean different things depending on where they are. At the end of a command When you see a semicolon after invoking a function, what that means is \"don't show me the output in the terminal window\". Example: julia > x = 2 + 2 4 julia > x = 10 + 2 ; julia > x 12 Julia will still process the command and assign 10 + 2 to x , but it won't show you the output in the terminal. We sometimes include a semicolon after commands in these docs to mimic what the REPL output would look like without spitting back out an array of over 200 values. These semicolons are optional In between assignment commands If you see a semicolon in between two variable assignments, like so: julia > x = [ 1 , 2 ] ; y = [ 3 , 4 ] that's a Julia short-hand for making two short lines of code appear on a single line. It's the equivalent of doing: julia > x = [ 1 , 2 ] ; julia > y = [ 3 , 4 ] We sometimes choose this writing format for very quick and small assignments hoping to save some visual space. Use whichever method is most comfortable and sensible for you! Help mode To enter help mode in the REPL, simply press the question mark key ? (shift + key) and you will notice a different prompt help?> for you to type in a function. help ?> population search: population populations population! populations! population(x::PopObj; listall::Bool = false) View unique population ID's in a PopObj. listall = true, displays ind and their population instead (default = false). Type information Julia encourages strong typing of variables, and the functions in PopGen are no exception to this. However, to reduce the barrier of entry required to understand this documentation and the subsequent package, we have chosen to omit some of the type information from functions to reduce visual clutter for newer users. As experienced users already know, if you would like to see the explicit type information, you can look at the code on github, invoke the help system in the REPL (above), or search for a function in the Documentation pane in Juno. You'll notice types follow a specific format, which is object::type . This format is a type declaration, so in the function population , which looks like: population(x::PopObj; listall::Bool = false) : x is a variable of type PopObj listall is a variable of type Bool (boolean) meaning it only takes true or false without quotes, and the default value is set to false . Type Unions You might see the type Union appear occasionally throughout this documentation, and you can consider it a list of allowable types. For example, if something was of type ::Union{String,Integer} , that means that either a String or Integer works. Subtypes The julia language is abound with types (and you can create your own!), and has a hierarchical system of supertypes and subtypes. As you can probably guess, a supertype can contain multiple subtypes, such as Signed being a supertype of (among other things) Int64, Int32, Int16, Int8 . All vectors are subtypes of AbstractVector . If you want to try it yourself, use the supertype() command on your favorite Type, like supertype(Float32) . You will occasionally see <: instead of :: , which means \"is a subtype of\". This is used for condtional evaluation, like typeof(something) <: Signed , and in some function methods like function(var1::T) where T <: Supertype , which leads us to: where T This looks weird at first, but it's actually very simple. When we do method definitions, we can define methods with strict types, like funct(data:PopData, arg1::Int8) , or we can generalize it with where T , which looks like function funct1 ( data :: PopData , thing1 :: T ) where T This will auto-create a method for any possible Type for thing1 . Usually, that's problematic, as incorrect input will lead to obscure errors (e.g. multiplying integers with strings?!). Instead, you can constrain the types for T like this: function funct2 ( data :: PopData , thing1 :: T ) where T <: Signed With the constraint above, it will generate methods for all cases where thing1 is a subtype of Signed , which includes all the numerical Types (integers, Floats, etc.). This will make sure that the function will behave correctly for a range of input types. You can also use this type of notation to clean up a method definition where multiple arguments have the same Type specification: function funct3 ( data :: PopData , thing1 :: T , thing2 :: T , thing3 :: T ) where T :: Float64 So, instead of writing thing1::Float64, thing2::Float64, thing3::Float64 , we just use T as a placeholder and assign it a strict Type at the end. It ends up being pretty handy! Functions vs. Methods As part of Julia's type-safe paradigm and multiple dispatch (see \"ERROR: MethodError: no method matching\" below), type specifications in functions often reduce runtime of functions, but also establish function identity. Multiple dispatch refers to several different functions having the same name, but employing different methods depending on the input. In Julia, it's easier to write a single function with multiple type-safe methods, rather than one mega-function that accepts any type and have a bunch of if statements that determines what the program does depending on the input. As a rule of thumb, for loops with if conditions in them slow down the compiler, so best-practice often encourages us to write type-specific methods. In practice, this looks like: # combine two numbers julia> function add(x::Integer, y::Integer) x+y end add (generic function with 1 method) # combine two strings julia> function add(x::String, y::String) x*y end add (generic function with 2 methods) julia> add(1,2) 3 julia> add(\"water\", \"melon\") \"watermelon\" Multiple dispatch therefor leads to a unique type of possible error: the MethodError ERROR: MethodError: no method matching Using the function add from the example above, let's have a look at what happens when we try to add an Integer with a String : julia > add ( 1 , \"melon\" ) ERROR : MethodError : no method matching add ( :: Int64 , :: String ) Closest candidates are : add ( :: String , :: String ) at none : 2 add ( :: Integer , :: Integer ) at none : 2 Stacktrace : [ 1 ] top - level scope at none : 0 This error is telling us \"there is no such function called add , who's inputs are an Integer followed by a String \". But, it does offer us some alternatives, like the two add functions we created earlier. The functions within PopGen are almost always explicitly typed, so if you are getting the MethodError: no method matching error, then you are inputting the incorrect types into the function, or perhaps your inputs for the arguments are in the wrong order (see \"Functions with and without keywords\" below). Sometimes you might include an argument with a keyword when there isn't one, or include an argument without a keyword when there needs to be one (honestly, we make that mistake too and we wrote this stuff). To help minimize those mistakes, please read below about which arguments have keywords and which don't. MethodError's can definitely get annoying, but they are usually (but not always!) the result of incorrect input from the user. Please double-check your inputs before assuming something is broken or bugged. Functions with and without keywords Let's talk about semicolons some more. TL;DR Reading these docs, pay attention to semicolons in the function argument lists. arguments before a semicolon have no keyword and follow an explicit order arguments after a semicolon have a keyword argument = value and their order doesn't matter MethodError: no methods matching is more likely an issue on your side and not on our side unless we accidentally forgot to export a function! or we typed a function incorrectly ok, maybe we made a mistake and please submit an Issue! Broadly speaking, there are two types of function declarations in Julia: ones with keywords and ones without keywords. The term \"keywords\" refers to an input argument that has the format argument = value . This format is present in many of the functions in this and other packages, however there are some specifics to understand when functions use keywords and when they don't. Format 1: Strict argument order and no keywords - No semicolon in argument list function function_name ( var1 :: type , var2 :: type , var3 :: type ) do stuff with vars end If a function is declared with only commas in the argument list, like shown above, then the arguments to that function must have no keywords and follow the exact order they appear in. If the generic example above had the typing: function function_name ( var1 :: String , var2 :: Float64 , var3 :: Array { String , 1 }) do stuff with vars end then the only acceptable way to run this function without getting a MethodError would be with arguments in the order of function_name(String, Float64, Array{String,1}) . Even if some of the arguments have a default values, like var2::Float64 = 6.66 , the order of arguments/types has to be respected as declared. Format 2 - semicolon in argument list function function_name ( var1 :: type ; var2 :: type , var3 :: type ) do stuff with vars end In this format, everything that comes before the semicolon follows the strict rules from Format 1 , and everything that comes after the semicolon is a keyword argument. Keyword arguments have the flexibility to not require any particular input order. However, you must use the keywords to declare those arguments, or you will receive another MethodError: no method matching , which is, as we've mentioned, annoying.","title":"A Julia primer"},{"location":"getting_started/juliaprimer/#a-quick-julia-primer-for-getting-the-most-out-of-this-documentation","text":"There is nothing inherently special about this documentation relative to other documentation, other than we really really want you to get the most out of what's written here. This means that we need to embrace the fact that both novice and experienced Julia users may be reading these docs and using this package. So let's cover some Julia basics that will really help in navigating this package before we even get into the complicated genetics stuff. This primer is by no means \"everything you need to get started in Julia\", and is a poor substitute for actually learning the language. In general, we recommend Think Julia: How to Think Like a Data Scientist by Ben Lauwens to establish some solid Julia foundations. It's free online! Also, the Julia language maintains its own great documentation that we rely on quite heavily for development.","title":"A quick Julia primer for getting the most out of this documentation"},{"location":"getting_started/juliaprimer/#using-julia","text":"Everyone has their own particular workflows, and if you're new to Julia, you might not have established one yet. Julia can be used rather comfortably using its built-in interpreter, but you can also use it via Atom (the officially supported uber-juno add-on) for an RStudio-like experience. If you're already a fan of Jupyter notebooks (or nteract ), then all you need is to install the IJulia package in Julia and you have full Jupyter support for Julia! Other popular options are VScode (julia add-on), or Emacs. If you didn't already know, the name \"Jupyter\" is actually a concatenation of Ju (julia) Pyt (python) and eR (R). \ud83e\udd2f","title":"Using Julia"},{"location":"getting_started/juliaprimer/#first-time-performance","text":"If you're migrating to Julia from Python or R (or Matlab, etc.), you'll think Julia is slow and laggy because loading packages and running stuff has a noticeable wait time (10-40sec). It's worth mentioning that this lag is \"compilation overhead\". What this means is, Julia tries to pre-compile as much code as possible (into optimized machine code) when running something or loading a package. This lag exists only the first time you run something. Every subsequent run of a function, even with different parameters, will be substantially faster, and in most cases instant. If you want to test this yourself, try to run a line of code twice with @time before the function and compare the results. Here's an example: julia> @time using PopGen 17.415902 seconds (19.88 M allocations: 1.022 GiB, 2.79% gc time) julia> @time using PopGen 0.100233 seconds (64.07 k allocations: 3.123 MiB, 6.02% gc time)","title":"First-time Performance"},{"location":"getting_started/juliaprimer/#semicolons","text":"Semicolons will come up a lot in Julia, probably more than you would expect if you are migrating from another language. They mean different things depending on where they are.","title":"Semicolons"},{"location":"getting_started/juliaprimer/#at-the-end-of-a-command","text":"When you see a semicolon after invoking a function, what that means is \"don't show me the output in the terminal window\". Example: julia > x = 2 + 2 4 julia > x = 10 + 2 ; julia > x 12 Julia will still process the command and assign 10 + 2 to x , but it won't show you the output in the terminal. We sometimes include a semicolon after commands in these docs to mimic what the REPL output would look like without spitting back out an array of over 200 values. These semicolons are optional","title":"At the end of a command"},{"location":"getting_started/juliaprimer/#in-between-assignment-commands","text":"If you see a semicolon in between two variable assignments, like so: julia > x = [ 1 , 2 ] ; y = [ 3 , 4 ] that's a Julia short-hand for making two short lines of code appear on a single line. It's the equivalent of doing: julia > x = [ 1 , 2 ] ; julia > y = [ 3 , 4 ] We sometimes choose this writing format for very quick and small assignments hoping to save some visual space. Use whichever method is most comfortable and sensible for you!","title":"In between assignment commands"},{"location":"getting_started/juliaprimer/#help-mode","text":"To enter help mode in the REPL, simply press the question mark key ? (shift + key) and you will notice a different prompt help?> for you to type in a function. help ?> population search: population populations population! populations! population(x::PopObj; listall::Bool = false) View unique population ID's in a PopObj. listall = true, displays ind and their population instead (default = false).","title":"Help mode"},{"location":"getting_started/juliaprimer/#type-information","text":"Julia encourages strong typing of variables, and the functions in PopGen are no exception to this. However, to reduce the barrier of entry required to understand this documentation and the subsequent package, we have chosen to omit some of the type information from functions to reduce visual clutter for newer users. As experienced users already know, if you would like to see the explicit type information, you can look at the code on github, invoke the help system in the REPL (above), or search for a function in the Documentation pane in Juno. You'll notice types follow a specific format, which is object::type . This format is a type declaration, so in the function population , which looks like: population(x::PopObj; listall::Bool = false) : x is a variable of type PopObj listall is a variable of type Bool (boolean) meaning it only takes true or false without quotes, and the default value is set to false .","title":"Type information"},{"location":"getting_started/juliaprimer/#type-unions","text":"You might see the type Union appear occasionally throughout this documentation, and you can consider it a list of allowable types. For example, if something was of type ::Union{String,Integer} , that means that either a String or Integer works.","title":"Type Unions"},{"location":"getting_started/juliaprimer/#subtypes","text":"The julia language is abound with types (and you can create your own!), and has a hierarchical system of supertypes and subtypes. As you can probably guess, a supertype can contain multiple subtypes, such as Signed being a supertype of (among other things) Int64, Int32, Int16, Int8 . All vectors are subtypes of AbstractVector . If you want to try it yourself, use the supertype() command on your favorite Type, like supertype(Float32) . You will occasionally see <: instead of :: , which means \"is a subtype of\". This is used for condtional evaluation, like typeof(something) <: Signed , and in some function methods like function(var1::T) where T <: Supertype , which leads us to:","title":"Subtypes"},{"location":"getting_started/juliaprimer/#where-t","text":"This looks weird at first, but it's actually very simple. When we do method definitions, we can define methods with strict types, like funct(data:PopData, arg1::Int8) , or we can generalize it with where T , which looks like function funct1 ( data :: PopData , thing1 :: T ) where T This will auto-create a method for any possible Type for thing1 . Usually, that's problematic, as incorrect input will lead to obscure errors (e.g. multiplying integers with strings?!). Instead, you can constrain the types for T like this: function funct2 ( data :: PopData , thing1 :: T ) where T <: Signed With the constraint above, it will generate methods for all cases where thing1 is a subtype of Signed , which includes all the numerical Types (integers, Floats, etc.). This will make sure that the function will behave correctly for a range of input types. You can also use this type of notation to clean up a method definition where multiple arguments have the same Type specification: function funct3 ( data :: PopData , thing1 :: T , thing2 :: T , thing3 :: T ) where T :: Float64 So, instead of writing thing1::Float64, thing2::Float64, thing3::Float64 , we just use T as a placeholder and assign it a strict Type at the end. It ends up being pretty handy!","title":"where T"},{"location":"getting_started/juliaprimer/#functions-vs-methods","text":"As part of Julia's type-safe paradigm and multiple dispatch (see \"ERROR: MethodError: no method matching\" below), type specifications in functions often reduce runtime of functions, but also establish function identity. Multiple dispatch refers to several different functions having the same name, but employing different methods depending on the input. In Julia, it's easier to write a single function with multiple type-safe methods, rather than one mega-function that accepts any type and have a bunch of if statements that determines what the program does depending on the input. As a rule of thumb, for loops with if conditions in them slow down the compiler, so best-practice often encourages us to write type-specific methods. In practice, this looks like: # combine two numbers julia> function add(x::Integer, y::Integer) x+y end add (generic function with 1 method) # combine two strings julia> function add(x::String, y::String) x*y end add (generic function with 2 methods) julia> add(1,2) 3 julia> add(\"water\", \"melon\") \"watermelon\" Multiple dispatch therefor leads to a unique type of possible error: the MethodError","title":"Functions vs. Methods"},{"location":"getting_started/juliaprimer/#error-methoderror-no-method-matching","text":"Using the function add from the example above, let's have a look at what happens when we try to add an Integer with a String : julia > add ( 1 , \"melon\" ) ERROR : MethodError : no method matching add ( :: Int64 , :: String ) Closest candidates are : add ( :: String , :: String ) at none : 2 add ( :: Integer , :: Integer ) at none : 2 Stacktrace : [ 1 ] top - level scope at none : 0 This error is telling us \"there is no such function called add , who's inputs are an Integer followed by a String \". But, it does offer us some alternatives, like the two add functions we created earlier. The functions within PopGen are almost always explicitly typed, so if you are getting the MethodError: no method matching error, then you are inputting the incorrect types into the function, or perhaps your inputs for the arguments are in the wrong order (see \"Functions with and without keywords\" below). Sometimes you might include an argument with a keyword when there isn't one, or include an argument without a keyword when there needs to be one (honestly, we make that mistake too and we wrote this stuff). To help minimize those mistakes, please read below about which arguments have keywords and which don't. MethodError's can definitely get annoying, but they are usually (but not always!) the result of incorrect input from the user. Please double-check your inputs before assuming something is broken or bugged.","title":"ERROR: MethodError: no method matching"},{"location":"getting_started/juliaprimer/#functions-with-and-without-keywords","text":"Let's talk about semicolons some more. TL;DR Reading these docs, pay attention to semicolons in the function argument lists. arguments before a semicolon have no keyword and follow an explicit order arguments after a semicolon have a keyword argument = value and their order doesn't matter MethodError: no methods matching is more likely an issue on your side and not on our side unless we accidentally forgot to export a function! or we typed a function incorrectly ok, maybe we made a mistake and please submit an Issue! Broadly speaking, there are two types of function declarations in Julia: ones with keywords and ones without keywords. The term \"keywords\" refers to an input argument that has the format argument = value . This format is present in many of the functions in this and other packages, however there are some specifics to understand when functions use keywords and when they don't.","title":"Functions with and without keywords"},{"location":"getting_started/juliaprimer/#format-1-strict-argument-order-and-no-keywords-no-semicolon-in-argument-list","text":"function function_name ( var1 :: type , var2 :: type , var3 :: type ) do stuff with vars end If a function is declared with only commas in the argument list, like shown above, then the arguments to that function must have no keywords and follow the exact order they appear in. If the generic example above had the typing: function function_name ( var1 :: String , var2 :: Float64 , var3 :: Array { String , 1 }) do stuff with vars end then the only acceptable way to run this function without getting a MethodError would be with arguments in the order of function_name(String, Float64, Array{String,1}) . Even if some of the arguments have a default values, like var2::Float64 = 6.66 , the order of arguments/types has to be respected as declared.","title":"Format 1: Strict argument order and no keywords - No semicolon in argument list"},{"location":"getting_started/juliaprimer/#format-2-semicolon-in-argument-list","text":"function function_name ( var1 :: type ; var2 :: type , var3 :: type ) do stuff with vars end In this format, everything that comes before the semicolon follows the strict rules from Format 1 , and everything that comes after the semicolon is a keyword argument. Keyword arguments have the flexibility to not require any particular input order. However, you must use the keywords to declare those arguments, or you will receive another MethodError: no method matching , which is, as we've mentioned, annoying.","title":"Format 2 - semicolon in argument list"},{"location":"getting_started/popobj_type/","text":"For the PopGen.jl package to be consistent, a standard flexible data structure needs to be defined. The solution is a custom type called PopData . The struct is defined as: struct PopData meta :: IndexedTable loci :: IndexedTable end As you can see, a PopData is made up of two IndexedTables (from JuliaDB.jl ), one called meta for sample information (metadata), and the other called loci which includes genotype information. This structure allows for easy and convenient access to the fields using dot . accessors.. The meta and loci tables are both specific in their structure, so here is an illustration to help you visualize a PopData object: PopData and other custom types introduced in PopGen.jl fall under an AbstractType we call PopObj , which is short for \"PopGen Object\". pronouncing \"PopObj\" It's not super obvious, but we decided to pronounce PopObj as \"pop ob\" with a silent j because it sounds better than saying \"pop obj\", but writing it as PopOb looks weird. It's a silly little detail that Pavel seems to care a lot about. avoid manual creation While it may seem simple enough to create two IndexedTables and make a PopData out of them, the structure of meta and loci are specific, so small mistakes in creating them can create many errors and prevent PopGen from working correctly on your data. Please use the included csv , genepop , and vcf file importers instead. Metadata The meta table has 5 specific categories/columns: name, population, ploidy, longitude, latitude. These can be directly accessed with PopData.meta.columns.colname where PopData is the name of your PopData object, and colname is one of the five column names below. name ::Vector{String} The individual/sample names [ \"ind_001\" , \"ind_002\" , \"ind_003\" ] population ::Vector{String} The individual/sample population ID's [ \"borneo\" , \"borneo\" , \"new jersey\" ] ploidy ::Vector{Int8} The ploidy of the samples [ 2 , 2 , 2 ] longitude ::Vector{Union{Missing,Float32}} latitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4.42] latitude ::Vector{Union{Missing,Float64}} longitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4] loci The genotype information is stored in a separate table called loci . This table is rather special in that it is stored in \"tidy\" format, i.e. one record per row. Storing data this way makes it a lot easier to interrogate the data and write new functions, along with leveraging JuliaDBMeta.jl . It also means the table will have as many rows as loci x samples, which can become a lot. To reduce redundant objects inflating object size, the columns name, population, and locus are CategoricalStrings from CategoricalArrays.jl , which is a memory-saving data structure for long repetitive categorical data. Without using this format, gulfsharks would occupy about 27mb in your RAM! The classes of .loci can be directly accessed with PopData.loci.columns.colname where PopData is the name of your PopData object, and colname is one of the four column names below. name ::Vector{CategoricalString} The sample name, stored as a CategoricalString . Fundamentally, this acts like the name column of the meta table, except when deleting entries and a few uncommon edge cases. population ::Vector{CategoricalString} The population ID associated with that sample, stored as a CategoricalString . Fundamentally, this acts like the population column of the meta table, except when deleting entries and a few uncommon edge cases. locus ::Vector{CategoricalString} The locus associated with the genotype, stored as a CategoricalString . genotype ::Vector{Tuple{Int16,...}} The genotypes of the loci are an array of tuples, with each value corresponding to an allele. The length of the tuple will vary based on the ploidy of the sample, and the type will vary whether the markers are snps or microsatellites, therefor the type shown above is conceptually accurate, but computationally incorrect. [(0,1),(0,0),(1,2)] We use the tuple type for genotypes of individuals because they are immutable (cannot be changed). By the time you're using PopGen.jl , your data should already be filtered and screened. Hand-editing of genotype values is strongly discouraged, so we outlawed it outright. viewing PopData Given the volume of information that can be present in a PopData , we recommend summary() to summarize/overview the data rather than regurgitate everything on the screen. julia> a = gulfsharks() ; julia> summary(a) PopData Object Marker type: SNP Ploidy: 2 Number of individuals: 212 Number of loci: 2213 Populations: 7 Longitude: present with 0 missing Latitude: present with 0 missing location data Location data is optional for a PopObj . There are functions that use location information (e.g. locations ), but most don't, so it's not a dealbreaker.","title":"PopData and PopObj"},{"location":"getting_started/popobj_type/#metadata","text":"The meta table has 5 specific categories/columns: name, population, ploidy, longitude, latitude. These can be directly accessed with PopData.meta.columns.colname where PopData is the name of your PopData object, and colname is one of the five column names below.","title":"Metadata"},{"location":"getting_started/popobj_type/#name","text":"::Vector{String} The individual/sample names [ \"ind_001\" , \"ind_002\" , \"ind_003\" ]","title":"name"},{"location":"getting_started/popobj_type/#population","text":"::Vector{String} The individual/sample population ID's [ \"borneo\" , \"borneo\" , \"new jersey\" ]","title":"population"},{"location":"getting_started/popobj_type/#ploidy","text":"::Vector{Int8} The ploidy of the samples [ 2 , 2 , 2 ]","title":"ploidy"},{"location":"getting_started/popobj_type/#longitude","text":"::Vector{Union{Missing,Float32}} latitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4.42]","title":"longitude"},{"location":"getting_started/popobj_type/#latitude","text":"::Vector{Union{Missing,Float64}} longitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4]","title":"latitude"},{"location":"getting_started/popobj_type/#loci","text":"The genotype information is stored in a separate table called loci . This table is rather special in that it is stored in \"tidy\" format, i.e. one record per row. Storing data this way makes it a lot easier to interrogate the data and write new functions, along with leveraging JuliaDBMeta.jl . It also means the table will have as many rows as loci x samples, which can become a lot. To reduce redundant objects inflating object size, the columns name, population, and locus are CategoricalStrings from CategoricalArrays.jl , which is a memory-saving data structure for long repetitive categorical data. Without using this format, gulfsharks would occupy about 27mb in your RAM! The classes of .loci can be directly accessed with PopData.loci.columns.colname where PopData is the name of your PopData object, and colname is one of the four column names below.","title":"loci"},{"location":"getting_started/popobj_type/#name_1","text":"::Vector{CategoricalString} The sample name, stored as a CategoricalString . Fundamentally, this acts like the name column of the meta table, except when deleting entries and a few uncommon edge cases.","title":"name"},{"location":"getting_started/popobj_type/#population_1","text":"::Vector{CategoricalString} The population ID associated with that sample, stored as a CategoricalString . Fundamentally, this acts like the population column of the meta table, except when deleting entries and a few uncommon edge cases.","title":"population"},{"location":"getting_started/popobj_type/#locus","text":"::Vector{CategoricalString} The locus associated with the genotype, stored as a CategoricalString .","title":"locus"},{"location":"getting_started/popobj_type/#genotype","text":"::Vector{Tuple{Int16,...}} The genotypes of the loci are an array of tuples, with each value corresponding to an allele. The length of the tuple will vary based on the ploidy of the sample, and the type will vary whether the markers are snps or microsatellites, therefor the type shown above is conceptually accurate, but computationally incorrect. [(0,1),(0,0),(1,2)] We use the tuple type for genotypes of individuals because they are immutable (cannot be changed). By the time you're using PopGen.jl , your data should already be filtered and screened. Hand-editing of genotype values is strongly discouraged, so we outlawed it outright.","title":"genotype"},{"location":"getting_started/popobj_type/#viewing-popdata","text":"Given the volume of information that can be present in a PopData , we recommend summary() to summarize/overview the data rather than regurgitate everything on the screen. julia> a = gulfsharks() ; julia> summary(a) PopData Object Marker type: SNP Ploidy: 2 Number of individuals: 212 Number of loci: 2213 Populations: 7 Longitude: present with 0 missing Latitude: present with 0 missing","title":"viewing PopData"},{"location":"getting_started/popobj_type/#location-data","text":"Location data is optional for a PopObj . There are functions that use location information (e.g. locations ), but most don't, so it's not a dealbreaker.","title":"location data"},{"location":"io/delimited/","text":"Import a delimited file as a PopObj delimited ( infile ; delim = \",\" , digits = 3 , marker = \"snp\" , diploid = true ) # Example julia > a = delimited ( \"/data/cali_poppy.csv\" , digits = 2 ) Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" Arguments infile :: String : path to the input file, in quotes Keyword Arguments delim :: String : delimiter of the file, as a string. must be a single delimiter. (default: \",\" ) digits :: Int64 : the number of digits used to denote an allele (default: 3 ) marker::String : \"snp\" (default) or \"msat\" for microsatellites diploid::Bool : uses memory-optimized parsing for diploid samples (default: true ) Formatting Loci names must be first row Individuals names must be first value in row Population ID's must be second value in row longitude (x) values third value in row, latitude (y) fourth value in row fill with zeroes if no location data example name,population,long,lat,Locus1,Locus2,Locus3 \\n sierra_01,mountain,11.11,-22.22,001001,002002,001001 \\n sierra_02,mountain,11.12,-22.21,001001,001001,001002 \\n snbarb_03,coast,0,0,001001,001001,001002 \\n snbarb_02,coast,11.14,-22.24,001001,001001,001001 \\n snbarb_03,coast,11.15,0,001002,001001,001001 \\n Fun fact You can also use the command csv() synonymously with delimited() . Acknowledgements Thanks to the efforts of the CSV.jl and DataFrames.jl teams, we leverage those packages to do much of the heavy lifting within this parser.","title":"Delimited"},{"location":"io/delimited/#import-a-delimited-file-as-a-popobj","text":"delimited ( infile ; delim = \",\" , digits = 3 , marker = \"snp\" , diploid = true ) # Example julia > a = delimited ( \"/data/cali_poppy.csv\" , digits = 2 ) Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\"","title":"Import a delimited file as a PopObj"},{"location":"io/delimited/#arguments","text":"infile :: String : path to the input file, in quotes","title":"Arguments"},{"location":"io/delimited/#keyword-arguments","text":"delim :: String : delimiter of the file, as a string. must be a single delimiter. (default: \",\" ) digits :: Int64 : the number of digits used to denote an allele (default: 3 ) marker::String : \"snp\" (default) or \"msat\" for microsatellites diploid::Bool : uses memory-optimized parsing for diploid samples (default: true )","title":"Keyword Arguments"},{"location":"io/delimited/#formatting","text":"Loci names must be first row Individuals names must be first value in row Population ID's must be second value in row longitude (x) values third value in row, latitude (y) fourth value in row fill with zeroes if no location data","title":"Formatting"},{"location":"io/delimited/#example","text":"name,population,long,lat,Locus1,Locus2,Locus3 \\n sierra_01,mountain,11.11,-22.22,001001,002002,001001 \\n sierra_02,mountain,11.12,-22.21,001001,001001,001002 \\n snbarb_03,coast,0,0,001001,001001,001002 \\n snbarb_02,coast,11.14,-22.24,001001,001001,001001 \\n snbarb_03,coast,11.15,0,001002,001001,001001 \\n Fun fact You can also use the command csv() synonymously with delimited() .","title":"example"},{"location":"io/delimited/#acknowledgements","text":"Thanks to the efforts of the CSV.jl and DataFrames.jl teams, we leverage those packages to do much of the heavy lifting within this parser.","title":"Acknowledgements"},{"location":"io/example_data/","text":"PopGen.jl provides two datasets as examples, each with their own easy-to-remember function for retrieving those data. nancycats We include the familiar nancycats microsatellite data, as featured in adegenet , for easy importing into PopGen.jl as a PopObj . To use those data, simply invoke nancycats() without any arguments. julia> ncats = nancycats() ; summary(ncats) Object of type PopObj Marker type: Microsatellite Ploidy: 2 Number of individuals: 237 Number of loci: 9 Longitude: absent Latitude: absent Population names and counts: \u2502 num \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 P01 \u2502 10 \u2502 \u2502 2 \u2502 P02 \u2502 22 \u2502 \u2502 3 \u2502 P03 \u2502 12 \u2502 \u2502 4 \u2502 P04 \u2502 23 \u2502 \u2502 5 \u2502 P05 \u2502 15 \u2502 \u2502 6 \u2502 P06 \u2502 11 \u2502 \u2502 7 \u2502 P07 \u2502 14 \u2502 \u2502 8 \u2502 P08 \u2502 10 \u2502 \u2502 9 \u2502 P09 \u2502 9 \u2502 \u2502 10 \u2502 P10 \u2502 11 \u2502 \u2502 11 \u2502 P11 \u2502 20 \u2502 \u2502 12 \u2502 P12 \u2502 14 \u2502 \u2502 13 \u2502 P13 \u2502 13 \u2502 \u2502 14 \u2502 P14 \u2502 17 \u2502 \u2502 15 \u2502 P15 \u2502 11 \u2502 \u2502 16 \u2502 P16 \u2502 12 \u2502 \u2502 17 \u2502 P17 \u2502 13 \u2502 The spatial coordinates provided for the dataset in adegenet are completely unfamiliar to us (and some geospatial folks we spoke to), so they have been omitted. If you recognize what coordinate system has 485.111 appear in Nancy, France, please let us know! gulfsharks We also include the SNP dataset used in Dimens et al. 2019 \" A genomic assessment of movement and gene flow around the South Florida vicariance zone in the migratory coastal blacknose shark, Carcharhinus acronotus \" since it was already on hand. Like nancycats , we provide a convenient function to load these data into PopGen.jl as a PopObj . To use those data, simply invoke gulfsharks() without any arguments. julia> sharks = gulfsharks() ; summary(sharks) Object of type PopObj Marker type: SNP Ploidy: 2 Number of individuals: 212 Number of loci: 2213 Longitude: present with 0 missing Latitude: present with 0 missing Population names and counts: \u2502 num \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 21 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 South Carolina \u2502 28 \u2502 \u2502 4 \u2502 Florida Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502","title":"Example Data"},{"location":"io/example_data/#nancycats","text":"We include the familiar nancycats microsatellite data, as featured in adegenet , for easy importing into PopGen.jl as a PopObj . To use those data, simply invoke nancycats() without any arguments. julia> ncats = nancycats() ; summary(ncats) Object of type PopObj Marker type: Microsatellite Ploidy: 2 Number of individuals: 237 Number of loci: 9 Longitude: absent Latitude: absent Population names and counts: \u2502 num \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 P01 \u2502 10 \u2502 \u2502 2 \u2502 P02 \u2502 22 \u2502 \u2502 3 \u2502 P03 \u2502 12 \u2502 \u2502 4 \u2502 P04 \u2502 23 \u2502 \u2502 5 \u2502 P05 \u2502 15 \u2502 \u2502 6 \u2502 P06 \u2502 11 \u2502 \u2502 7 \u2502 P07 \u2502 14 \u2502 \u2502 8 \u2502 P08 \u2502 10 \u2502 \u2502 9 \u2502 P09 \u2502 9 \u2502 \u2502 10 \u2502 P10 \u2502 11 \u2502 \u2502 11 \u2502 P11 \u2502 20 \u2502 \u2502 12 \u2502 P12 \u2502 14 \u2502 \u2502 13 \u2502 P13 \u2502 13 \u2502 \u2502 14 \u2502 P14 \u2502 17 \u2502 \u2502 15 \u2502 P15 \u2502 11 \u2502 \u2502 16 \u2502 P16 \u2502 12 \u2502 \u2502 17 \u2502 P17 \u2502 13 \u2502 The spatial coordinates provided for the dataset in adegenet are completely unfamiliar to us (and some geospatial folks we spoke to), so they have been omitted. If you recognize what coordinate system has 485.111 appear in Nancy, France, please let us know!","title":"nancycats"},{"location":"io/example_data/#gulfsharks","text":"We also include the SNP dataset used in Dimens et al. 2019 \" A genomic assessment of movement and gene flow around the South Florida vicariance zone in the migratory coastal blacknose shark, Carcharhinus acronotus \" since it was already on hand. Like nancycats , we provide a convenient function to load these data into PopGen.jl as a PopObj . To use those data, simply invoke gulfsharks() without any arguments. julia> sharks = gulfsharks() ; summary(sharks) Object of type PopObj Marker type: SNP Ploidy: 2 Number of individuals: 212 Number of loci: 2213 Longitude: present with 0 missing Latitude: present with 0 missing Population names and counts: \u2502 num \u2502 population \u2502 count \u2502 \u2502 \u2502 Union\u2026 \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 Cape Canaveral \u2502 21 \u2502 \u2502 2 \u2502 Georgia \u2502 30 \u2502 \u2502 3 \u2502 South Carolina \u2502 28 \u2502 \u2502 4 \u2502 Florida Keys \u2502 65 \u2502 \u2502 5 \u2502 Mideast Gulf \u2502 28 \u2502 \u2502 6 \u2502 Northeast Gulf \u2502 20 \u2502 \u2502 7 \u2502 Southeast Gulf \u2502 20 \u2502","title":"gulfsharks"},{"location":"io/file_import/","text":"Reading in Data Currently, PopGen.jl provides three different file parsers with which to create a PopObj : Delimited files Genepop files Variant Call Format files Each of the filetypes have their own file importer denoted simply by the file type: delimited() , genepop() , bcf() , and vcf() . You're encouraged to use functions, but PopGen.jl also provides you with an all-encompassing wrapper for all three called read() . Since read() already exists in Base Julia, this function was not exported, and must be called formally as PopGen.read() to avoid any unintentional dispatch errors. PopGen.read() uses all the same keyword arguments as do the commands specific to their filetypes, therefore you should have a look at those commands (usually the defaults suffice). PopGen . read ( infile :: String ; kwargs ... ) where infile is a String of your filename (in quotes) and kwargs are the corresponding keyword arguments associated with your file type, which are found on their respective pages. PopGen.read() infers the file type from the file extension, so for it to work properly your file must end with the extensions permitted below. If you're feeling particularly rebellious and your file does not conform to these extensions (such as a genepop file with a .gen.final.v2.seriously extension), then feel free to use the specific file importers, since they use the same exact syntax, there is zero difference in performance, and ignore file extensions. Ultimately, what crazy extensions you give your files is your business, and we love that about you. Supported File Types Delimited files Accepted extensions: .csv , .tsv , .txt files in which values are separated using a consistent delimiter, such as commas, spaces, or tabs first rows are column names each line represents a row Genepop Files Accepted extensions: .gen , .genepop first row is a comment and skipped then comes list of all loci, usually 1-per-line sometimes horizontally arranged and separated by commas populations separated by word \"POP\" sample names followed by comma and tab genotypes separated by tabs genotypes represented as a combination of ploidy x n -digits e.g. for genotype 001002 (3 digits per allele) allele 1 = 001 allele 2 = 002 Variant Call Format Accepted extensions: .vcf , .bcf This format is much more abstract and can vary somewhat depending on which variant caller produced the file. If you're super duper interested in the specifications of BCF/VCF files, have a look at the official specification documentation .","title":"Reading in Data"},{"location":"io/file_import/#reading-in-data","text":"Currently, PopGen.jl provides three different file parsers with which to create a PopObj : Delimited files Genepop files Variant Call Format files Each of the filetypes have their own file importer denoted simply by the file type: delimited() , genepop() , bcf() , and vcf() . You're encouraged to use functions, but PopGen.jl also provides you with an all-encompassing wrapper for all three called read() . Since read() already exists in Base Julia, this function was not exported, and must be called formally as PopGen.read() to avoid any unintentional dispatch errors. PopGen.read() uses all the same keyword arguments as do the commands specific to their filetypes, therefore you should have a look at those commands (usually the defaults suffice). PopGen . read ( infile :: String ; kwargs ... ) where infile is a String of your filename (in quotes) and kwargs are the corresponding keyword arguments associated with your file type, which are found on their respective pages. PopGen.read() infers the file type from the file extension, so for it to work properly your file must end with the extensions permitted below. If you're feeling particularly rebellious and your file does not conform to these extensions (such as a genepop file with a .gen.final.v2.seriously extension), then feel free to use the specific file importers, since they use the same exact syntax, there is zero difference in performance, and ignore file extensions. Ultimately, what crazy extensions you give your files is your business, and we love that about you.","title":"Reading in Data"},{"location":"io/file_import/#supported-file-types","text":"","title":"Supported File Types"},{"location":"io/file_import/#delimited-files","text":"Accepted extensions: .csv , .tsv , .txt files in which values are separated using a consistent delimiter, such as commas, spaces, or tabs first rows are column names each line represents a row","title":"Delimited files"},{"location":"io/file_import/#genepop-files","text":"Accepted extensions: .gen , .genepop first row is a comment and skipped then comes list of all loci, usually 1-per-line sometimes horizontally arranged and separated by commas populations separated by word \"POP\" sample names followed by comma and tab genotypes separated by tabs genotypes represented as a combination of ploidy x n -digits e.g. for genotype 001002 (3 digits per allele) allele 1 = 001 allele 2 = 002","title":"Genepop Files"},{"location":"io/file_import/#variant-call-format","text":"Accepted extensions: .vcf , .bcf This format is much more abstract and can vary somewhat depending on which variant caller produced the file. If you're super duper interested in the specifications of BCF/VCF files, have a look at the official specification documentation .","title":"Variant Call Format"},{"location":"io/genepop/","text":"Import a genepop file as a PopObj genepop ( infile ; kwargs ... ) # Example julia > b = genepop ( \"/data/wasp_hive.gen\" , digits = 3 , popsep = \"POP\" ) Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" arguments infile::String : path to genepop file, in quotes keyword Arguments digits::Integer : number of digits denoting each allele (default: 3 ) popsep::String : word that separates populations in infile (default: \"POP\") diploid::Bool : whether samples are diploid for parsing optimizations (default: true ) silent::Bool : whether to print file information during import (default: true ) By default, the file reader will assign numbers as population ID's (as Strings) in order of appearance in the genepop file. Use the populations! function to rename these with your own population ID's. Format Files must follow standard Genepop formatting: First line is a comment (and skipped) Loci are listed after first line as one-per-line without commas or in single comma-separated row A line with a particular and consistent keyword must delimit populations Must be the same word each time and not a unique population name File is tab delimited or space delimited, but not both formatting examples loci stacked vertically Wasp populations in New York Locus1 Locus2 Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 loci stacked horizontally Wasp populations in New York Locus1,Locus2,Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 Acknowledgements The original implementations of this parser were written using only Base Julia, and while the speed was fantastic, the memory footprint involved seemed unusually high (~650mb RAM to parse gulfsharks , which is 3.2mb in size). However, thanks to the efforts of the CSV.jl team, we leverage that package to do much of the heavy lifting, in a multicore way, and all the while while preserving the speed and reducing the memory footprint quite a bit!","title":"Genepop"},{"location":"io/genepop/#import-a-genepop-file-as-a-popobj","text":"genepop ( infile ; kwargs ... ) # Example julia > b = genepop ( \"/data/wasp_hive.gen\" , digits = 3 , popsep = \"POP\" ) Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\"","title":"Import a genepop file as a PopObj"},{"location":"io/genepop/#arguments","text":"infile::String : path to genepop file, in quotes","title":"arguments"},{"location":"io/genepop/#keyword-arguments","text":"digits::Integer : number of digits denoting each allele (default: 3 ) popsep::String : word that separates populations in infile (default: \"POP\") diploid::Bool : whether samples are diploid for parsing optimizations (default: true ) silent::Bool : whether to print file information during import (default: true ) By default, the file reader will assign numbers as population ID's (as Strings) in order of appearance in the genepop file. Use the populations! function to rename these with your own population ID's.","title":"keyword Arguments"},{"location":"io/genepop/#format","text":"Files must follow standard Genepop formatting: First line is a comment (and skipped) Loci are listed after first line as one-per-line without commas or in single comma-separated row A line with a particular and consistent keyword must delimit populations Must be the same word each time and not a unique population name File is tab delimited or space delimited, but not both","title":"Format"},{"location":"io/genepop/#formatting-examples","text":"loci stacked vertically Wasp populations in New York Locus1 Locus2 Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 loci stacked horizontally Wasp populations in New York Locus1,Locus2,Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120","title":"formatting examples"},{"location":"io/genepop/#acknowledgements","text":"The original implementations of this parser were written using only Base Julia, and while the speed was fantastic, the memory footprint involved seemed unusually high (~650mb RAM to parse gulfsharks , which is 3.2mb in size). However, thanks to the efforts of the CSV.jl team, we leverage that package to do much of the heavy lifting, in a multicore way, and all the while while preserving the speed and reducing the memory footprint quite a bit!","title":"Acknowledgements"},{"location":"io/variantcall/","text":"Import a BCF/VCF file as a PopObj PopGen.jl provides a simple command vcf to import a VCF file as a PopObj , which requires only the name of the file and nothing else. While not strictly necessary, if you have polyploid or mixed-ploidy samples, this import method may be most efficient. potato = vcf ( \"/home/data/russet_potatoes.vcf\" ) and similar for bcf formatted files: cabbage = bcf ( \"/home/data/nappa_cabbage.bcf\" ) Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" What BCF/VCF files contain and lack Due to the nature of the file format, importing variant call files will provide: sample names ploidy of each sample locus names genotypes but they will not provide: population information latitude or longitude This means you will need to add that information separately afterwards. Location data (which is optional!) can be added to the PopObj directly to .samples.latitude or .samples.longitude or with the locations! command. Population names (mandatory!) can be added using populations!() Format Variant Call Format (or VCF ) files already follow a format standard, and while there is some wiggle-room for optional values, PopGen.jl only requires the core/mandatory components of a VCF, meaning problems should hopefully not arise regardless of which variant caller you are using (although we use Freebayes ourselves). Please open an issue if they do, or reach out to us on the community Slack. Keep in mind, BCF/VCF files need to be filtered before importing them into PopGen.jl. There is no and will be no VCF-filtering functionality to this package, as it is outside of the purpose of PopGen.jl. Refer to vcftools and vcflib to filter your sequence data. Acknowledgements The majority of the BCF/VCF reader is thanks to the tremendous efforts of Ben J. Ward and the BioJulia contributors involved in GeneticVariation.jl , which we use to parse your files into PopObj format. If you love the file importer, then give those folks your thanks. If something is wrong and/or you hate the importer, blame us (and please open up an issue ).","title":"Variant Call Format"},{"location":"io/variantcall/#import-a-bcfvcf-file-as-a-popobj","text":"PopGen.jl provides a simple command vcf to import a VCF file as a PopObj , which requires only the name of the file and nothing else. While not strictly necessary, if you have polyploid or mixed-ploidy samples, this import method may be most efficient. potato = vcf ( \"/home/data/russet_potatoes.vcf\" ) and similar for bcf formatted files: cabbage = bcf ( \"/home/data/nappa_cabbage.bcf\" ) Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\"","title":"Import a BCF/VCF file as a PopObj"},{"location":"io/variantcall/#what-bcfvcf-files-contain-and-lack","text":"Due to the nature of the file format, importing variant call files will provide: sample names ploidy of each sample locus names genotypes but they will not provide: population information latitude or longitude This means you will need to add that information separately afterwards. Location data (which is optional!) can be added to the PopObj directly to .samples.latitude or .samples.longitude or with the locations! command. Population names (mandatory!) can be added using populations!()","title":"What BCF/VCF files contain and lack"},{"location":"io/variantcall/#format","text":"Variant Call Format (or VCF ) files already follow a format standard, and while there is some wiggle-room for optional values, PopGen.jl only requires the core/mandatory components of a VCF, meaning problems should hopefully not arise regardless of which variant caller you are using (although we use Freebayes ourselves). Please open an issue if they do, or reach out to us on the community Slack. Keep in mind, BCF/VCF files need to be filtered before importing them into PopGen.jl. There is no and will be no VCF-filtering functionality to this package, as it is outside of the purpose of PopGen.jl. Refer to vcftools and vcflib to filter your sequence data.","title":"Format"},{"location":"io/variantcall/#acknowledgements","text":"The majority of the BCF/VCF reader is thanks to the tremendous efforts of Ben J. Ward and the BioJulia contributors involved in GeneticVariation.jl , which we use to parse your files into PopObj format. If you love the file importer, then give those folks your thanks. If something is wrong and/or you hate the importer, blame us (and please open up an issue ).","title":"Acknowledgements"},{"location":"manipulate/exclusion/","text":"This section covers situations where one may want to remove samples or loci from PopData . By design, removal functions do not alter your original PopData , so you always have a backup handy (but don't forget to assign a name to the new PopData ). Since the exclusion functions don't alter the original PopData , they do not end with a bang ! . synonymous functions For the exclusion commands on this page, we made it so the words omit and remove are interchangeable with exclude , meaning remove_samples and omit_loci are the same exact functions as their exclude variants. This was done so you can use them interchangeably and you wont' need to remember the specific name to perform these basic actions. Maybe you just prefer the word omit . We're not here to judge. Exclude samples exclude_samples ( data :: PopObj , samp_id :: Union { String , Vector { String }}) Returns a new PopData object without the sample or samples provided. Input can be a single sample, or an array of samples. Will output an entire PopData , so use a semicolon after the command if you don't want the entire object printed to your screen. Use summary if you want to confirm that the samples were removed. This command will inform you if samples were not found in the data. Examples: single individual julia > fewer_sharks = exclude_samples ( sharks , \"cc_001\" ) ; julia > summary ( fewer_sharks ) PopData Object Marker type : SNP Ploidy : 2 Number of individuals : 211 Number of loci : 2213 Populations : 7 Longitude : present with 0 missing Latitude : present with 0 missing multiple individuals julia > lots_fewer_sharks = remove_samples ( sharks , [ \"cc_001\" , \"cc_002\" , \"cc_003\" ]) ; julia > summary ( lots_fewer_sharks ) PopData Object Marker type : SNP Ploidy : 2 Number of individuals : 209 Number of loci : 2213 Populations : 7 Longitude : present with 0 missing Latitude : present with 0 missing sample not found! If removing a single sample and it is not found in the PopData, an error will be returned. However, if removing multiple samples, you will receive a notice above the PopData output indicating which individuals were not found, while still removing the ones that were present. Exclude loci exclude_loci ( data :: PopObj , loci :: Union { String , Vector { String }}) Returns a new PopData object without the locus or loci provided. Input can be a single locus, or an array of loci, all as Strings. Will output an entire PopData , so use a semicolon after the command if you don't want the entire object printed to your screen. Use summary if you want to confirm that the loci were removed. This command will inform you if loci were not found in the data. Examples: single locus julia > fewer_shark_loci = exclude_loci ( sharks , \"contig_475\" ) ; julia > summary ( fewer_shark_loci ) PopData Object Marker type : SNP Ploidy : 2 Number of individuals : 212 Number of loci : 2212 Populations : 7 Longitude : present with 0 missing Latitude : present with 0 missing multiple loci julia > lots_fewer_loci = remove_loci ( sharks , [ \"contig_475\" , \"contig_2784\" , \"contig_8065\" ]) ; julia > summary ( lots_fewer_loci ) PopData Object Marker type : SNP Ploidy : 2 Number of individuals : 212 Number of loci : 2210 Populations : 7 Longitude : present with 0 missing Latitude : present with 0 missing locus not found! If removing a single locus and it is not found in the PopData, an error will be returned. However, if removing multiple loci, you will receive a notice above the PopData summary indicating which loci were not found, while removing the ones that were. If none of the loci specified were found, it will return an error.","title":"Remove Samples/Loci"},{"location":"manipulate/exclusion/#exclude-samples","text":"exclude_samples ( data :: PopObj , samp_id :: Union { String , Vector { String }}) Returns a new PopData object without the sample or samples provided. Input can be a single sample, or an array of samples. Will output an entire PopData , so use a semicolon after the command if you don't want the entire object printed to your screen. Use summary if you want to confirm that the samples were removed. This command will inform you if samples were not found in the data. Examples: single individual julia > fewer_sharks = exclude_samples ( sharks , \"cc_001\" ) ; julia > summary ( fewer_sharks ) PopData Object Marker type : SNP Ploidy : 2 Number of individuals : 211 Number of loci : 2213 Populations : 7 Longitude : present with 0 missing Latitude : present with 0 missing multiple individuals julia > lots_fewer_sharks = remove_samples ( sharks , [ \"cc_001\" , \"cc_002\" , \"cc_003\" ]) ; julia > summary ( lots_fewer_sharks ) PopData Object Marker type : SNP Ploidy : 2 Number of individuals : 209 Number of loci : 2213 Populations : 7 Longitude : present with 0 missing Latitude : present with 0 missing sample not found! If removing a single sample and it is not found in the PopData, an error will be returned. However, if removing multiple samples, you will receive a notice above the PopData output indicating which individuals were not found, while still removing the ones that were present.","title":"Exclude samples"},{"location":"manipulate/exclusion/#exclude-loci","text":"exclude_loci ( data :: PopObj , loci :: Union { String , Vector { String }}) Returns a new PopData object without the locus or loci provided. Input can be a single locus, or an array of loci, all as Strings. Will output an entire PopData , so use a semicolon after the command if you don't want the entire object printed to your screen. Use summary if you want to confirm that the loci were removed. This command will inform you if loci were not found in the data. Examples: single locus julia > fewer_shark_loci = exclude_loci ( sharks , \"contig_475\" ) ; julia > summary ( fewer_shark_loci ) PopData Object Marker type : SNP Ploidy : 2 Number of individuals : 212 Number of loci : 2212 Populations : 7 Longitude : present with 0 missing Latitude : present with 0 missing multiple loci julia > lots_fewer_loci = remove_loci ( sharks , [ \"contig_475\" , \"contig_2784\" , \"contig_8065\" ]) ; julia > summary ( lots_fewer_loci ) PopData Object Marker type : SNP Ploidy : 2 Number of individuals : 212 Number of loci : 2210 Populations : 7 Longitude : present with 0 missing Latitude : present with 0 missing locus not found! If removing a single locus and it is not found in the PopData, an error will be returned. However, if removing multiple loci, you will receive a notice above the PopData summary indicating which loci were not found, while removing the ones that were. If none of the loci specified were found, it will return an error.","title":"Exclude loci"},{"location":"manipulate/location_and_pop/","text":"Population genetics involves a focus on... populations (gasp!). The commands below show you how to view and modify both population information (names), and location information (geographic coordinates). Location Data View location data locations ( data :: PopData ) View location data ( .longitude and .latitude ) in a PopData , returning a table the longitude and latitude information in meta . locations julia > locations ( sharks ) output Table with 212 rows, 2 columns: longitude latitude \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 28.3062 -80.5993 28.3079 -80.5995 28.3023 -80.5996 28.6123 -80.4225 27.8666 -80.3578 27.8666 -80.3579 27.8682 -80.3482 27.8711 -80.3482 \u22ee 30.0696 -86.5376 29.9065 -86.0905 30.0532 -87.3661 30.0522 -87.3662 29.8234 -85.7143 29.8234 -85.7143 Add location data Location data can be added using one of the methods of locations! . As indicated by the bang ! , your PopData will be edited in place, and there will be no return output. If your data is in Decimal Minutes format, this function will convert your long/lat into Decimal Degrees. To import those data into Julia, you'll likely want to use the wonderful CSV.jl package first. Decimal Degrees : -11.431 Decimal Minutes : -11 43.11 (notice the space) Your data must use the minus sign - (if appropriate) instead of cardinal directions. 11 43.11W is not valid. There are three main ways of adding location data: If already in decimal degrees locations! ( data :: PopObj , long :: Vector { T }, lat :: Vector { T }) where T <: AbstractFloat This method is pretty straightforward, and it tolerates vectors with missing data. # generate some fake location data julia > long = rand ( 212 ) .* 10 ; lat = rand ( 212 ) .* - 10 julia > locations! ( sharks , long , lat ) If in decimal minutes There are two options here, the first is to input two vectors of strings, like: lat = [ \"11 44.31\" , \"-25 41.94\" ] long = [ \"-43 54.11\" , \"22 23.11\" ] For this, the method is locations! ( data :: PopData ; lat :: Vector { String }, long :: Vector { String }) which uses the lat and long keywords. This method tolerates missing values, but you will need to replace! the string \"missing\" with values of missing . Or, you can input four vectors of numbers with the associated keyword arguments: Input Type Keyword Argument Vector of longitude degrees Integer long_deg Vector of longitude minutes Float long_min Vector of latitude degrees Integer lat_deg Vector of latitude minutes Float lat_min This method is easier or more tedious depending on what you consider a more practical approach. For example, if you have decimal-minutes coordinates for two samples: Longitude Latitude Sample 1 11 43.12 15 36.53 Sample 2 -12 41.32 11 22.41 then your inputs would be: lo_deg = [11, -12] lo_min = [43.12, 41.32] la_deg = [15, 11] la_min = [36.53, 22.41] and you would then use locations! like this: locations! ( data , long_deg = lo_deg , long_min = lo_min , lat_deg = la_deg , lat_min = la_min ) Population Names View population names populations ( data :: PopData ; listall :: Bool = false ) Just as you can view population names with PopData.meta.columns.population , you can also view them with the populations command, which by default shows you a summary of the number of individuals in each population. populations julia > populations ( sharks ) output Table with 7 rows, 2 columns: population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Cape Canaveral\" 21 \"Florida Keys\" 65 \"Georgia\" 30 \"Mideast Gulf\" 28 \"Northeast Gulf\" 20 \"South Carolina\" 28 \"Southeast Gulf\" 20 You can use the keyword listall=true to display each individual and their associated population as a table. listall=true julia > populations ( sharks , listall = true ) output Table with 212 rows, 2 columns: name population \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"cc_002\" \"Cape Canaveral\" \"cc_003\" \"Cape Canaveral\" \"cc_005\" \"Cape Canaveral\" \"cc_007\" \"Cape Canaveral\" \"cc_008\" \"Cape Canaveral\" \"cc_009\" \"Cape Canaveral\" \"cc_010\" \"Cape Canaveral\" \u22ee \"seg_026\" \"Southeast Gulf\" \"seg_027\" \"Southeast Gulf\" \"seg_028\" \"Southeast Gulf\" \"seg_029\" \"Southeast Gulf\" \"seg_030\" \"Southeast Gulf\" \"seg_031\" \"Southeast Gulf\" synonymous functions You can use the command population for the same functionality. We made the commands population and populations synonymous so you wouldn't have to memorize if the name was singular or plural-- it just works! This also applies to populations! and population! Rename populations There are a handful of methods to alter PopData population names depending on what you find most convenient. Each of these methods start with populations!() and vary in their inputs. It's for that reason this function has an obnoxiously long docstring. For simplicity, the methods will be separated into categories. However, all the methods for populations! are unified in that they edit PopData in place, and print (rather than return) a table of the new population names and counts courtesy of populations() . Replace by matching Using a Dictionary populations! ( data :: PopData , rename :: Dict ) Rename existing population ID's of PopData using a Dict of population_name => replacement . rename populations # create a dictionary of name conversions julia > new_popnames = Dict ( \"Cape Canaveral\" => \"Atlantic\" , \"Georgia\" => \"Atlantic\" , \"South Carolina\" => \"Atlantic\" , \"Florida Keys\" => \"Gulf\" , \"Mideast Gulf\" => \"Gulf\" , \"Northeast Gulf\" => \"Gulf\" , \"Southeast Gulf\" => \"Gulf\" ); julia > populations! ( sharks , new_popnames ) Table with 2 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Atlantic\" 79 \"Gulf\" 133 Using a Vector of names Vector of new unique population names in the order that they appear in the PopData.meta . julia > new_popnames = [ \"Atlantic\" , \"Atlantic\" , \"Atlantic\" , \"Gulf\" , \"Gulf\" , \"Gulf\" , \"Gulf\" ] julia > populations! ( sharks , new_popnames ) Table with 2 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Atlantic\" 79 \"Gulf\" 133 Using a Vector of oldnames and new names Similar to the Dict method, except instead of creating a dictionary of \"oldname\" => \"newname\", you input a Vector{String} of oldnames followed by another of newnames . Logically, the new names will replace the old names in the same order as they appear in PopData.meta (e.g. the first newname replaces the first oldname, etc.). julia > old_pop = [ \"Cape Canaveral\" , \"Florida Keys\" , \"Georgia\" , \"Mideast Gulf\" , \"Northeast Gulf\" , \"South Carolina\" , \"Southeast Gulf\" ] ; julia > new_pop = [ \"Atlantic\" , \"Gulf\" , \"Atlantic\" , \"Gulf\" , \"Gulf\" , \"Atlantic\" , \"Gulf\" ] ; julia > populations ( sharks , old_pop , new_pop ) Table with 2 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Atlantic\" 79 \"Gulf\" 133 Generate new population information You may want outright overwrite all current population information. This is particularly useful when importing from VCF format when population information is not provided. This method will completely replace the population names of PopData regardless of what they currently are. Double-check your population counts If you're playing along and getting errors that the lengths don't match, then get make sure you're using the right population counts. You can get those numbers with populations(sharks) . counts = [ 21 , 65 , 30 , 28 , 20 , 28 , 20 ] and we then also create the vector of the names in the order in which they appear: popnames = [ \"Cape Canaveral\" , \"Florida Keys\" , \"Georgia\" , \"Mideast Gulf\" , \"Northeast Gulf\" , \"South Carolina\" , \"Southeast Gulf\" ] Now we can combine them with populations! to restore the population names to how they were originally: Using a NamedTuple replace populations julia > populations! ( sharks , ( counts = counts , names = popnames )) Table with 7 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Cape Canaveral\" 21 \"Florida Keys\" 65 \"Georgia\" 30 \"Mideast Gulf\" 28 \"Northeast Gulf\" 20 \"South Carolina\" 28 \"Southeast Gulf\" 20 Using a Vector of names and a Vector of counts This is just about the same as using the NamedTuple , but perhaps some users will prefer this format. julia > populations! ( sharks , popnames , counts ) Table with 7 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Cape Canaveral\" 21 \"Florida Keys\" 65 \"Georgia\" 30 \"Mideast Gulf\" 28 \"Northeast Gulf\" 20 \"South Carolina\" 28 \"Southeast Gulf\" 20","title":"Location and Population Data"},{"location":"manipulate/location_and_pop/#location-data","text":"","title":"Location Data"},{"location":"manipulate/location_and_pop/#view-location-data","text":"locations ( data :: PopData ) View location data ( .longitude and .latitude ) in a PopData , returning a table the longitude and latitude information in meta . locations julia > locations ( sharks ) output Table with 212 rows, 2 columns: longitude latitude \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 28.3062 -80.5993 28.3079 -80.5995 28.3023 -80.5996 28.6123 -80.4225 27.8666 -80.3578 27.8666 -80.3579 27.8682 -80.3482 27.8711 -80.3482 \u22ee 30.0696 -86.5376 29.9065 -86.0905 30.0532 -87.3661 30.0522 -87.3662 29.8234 -85.7143 29.8234 -85.7143","title":"View location data"},{"location":"manipulate/location_and_pop/#add-location-data","text":"Location data can be added using one of the methods of locations! . As indicated by the bang ! , your PopData will be edited in place, and there will be no return output. If your data is in Decimal Minutes format, this function will convert your long/lat into Decimal Degrees. To import those data into Julia, you'll likely want to use the wonderful CSV.jl package first. Decimal Degrees : -11.431 Decimal Minutes : -11 43.11 (notice the space) Your data must use the minus sign - (if appropriate) instead of cardinal directions. 11 43.11W is not valid. There are three main ways of adding location data:","title":"Add location data"},{"location":"manipulate/location_and_pop/#if-already-in-decimal-degrees","text":"locations! ( data :: PopObj , long :: Vector { T }, lat :: Vector { T }) where T <: AbstractFloat This method is pretty straightforward, and it tolerates vectors with missing data. # generate some fake location data julia > long = rand ( 212 ) .* 10 ; lat = rand ( 212 ) .* - 10 julia > locations! ( sharks , long , lat )","title":"If already in decimal degrees"},{"location":"manipulate/location_and_pop/#if-in-decimal-minutes","text":"There are two options here, the first is to input two vectors of strings, like: lat = [ \"11 44.31\" , \"-25 41.94\" ] long = [ \"-43 54.11\" , \"22 23.11\" ] For this, the method is locations! ( data :: PopData ; lat :: Vector { String }, long :: Vector { String }) which uses the lat and long keywords. This method tolerates missing values, but you will need to replace! the string \"missing\" with values of missing . Or, you can input four vectors of numbers with the associated keyword arguments: Input Type Keyword Argument Vector of longitude degrees Integer long_deg Vector of longitude minutes Float long_min Vector of latitude degrees Integer lat_deg Vector of latitude minutes Float lat_min This method is easier or more tedious depending on what you consider a more practical approach. For example, if you have decimal-minutes coordinates for two samples: Longitude Latitude Sample 1 11 43.12 15 36.53 Sample 2 -12 41.32 11 22.41 then your inputs would be: lo_deg = [11, -12] lo_min = [43.12, 41.32] la_deg = [15, 11] la_min = [36.53, 22.41] and you would then use locations! like this: locations! ( data , long_deg = lo_deg , long_min = lo_min , lat_deg = la_deg , lat_min = la_min )","title":"If in decimal minutes"},{"location":"manipulate/location_and_pop/#population-names","text":"","title":"Population Names"},{"location":"manipulate/location_and_pop/#view-population-names","text":"populations ( data :: PopData ; listall :: Bool = false ) Just as you can view population names with PopData.meta.columns.population , you can also view them with the populations command, which by default shows you a summary of the number of individuals in each population. populations julia > populations ( sharks ) output Table with 7 rows, 2 columns: population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Cape Canaveral\" 21 \"Florida Keys\" 65 \"Georgia\" 30 \"Mideast Gulf\" 28 \"Northeast Gulf\" 20 \"South Carolina\" 28 \"Southeast Gulf\" 20 You can use the keyword listall=true to display each individual and their associated population as a table. listall=true julia > populations ( sharks , listall = true ) output Table with 212 rows, 2 columns: name population \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"cc_002\" \"Cape Canaveral\" \"cc_003\" \"Cape Canaveral\" \"cc_005\" \"Cape Canaveral\" \"cc_007\" \"Cape Canaveral\" \"cc_008\" \"Cape Canaveral\" \"cc_009\" \"Cape Canaveral\" \"cc_010\" \"Cape Canaveral\" \u22ee \"seg_026\" \"Southeast Gulf\" \"seg_027\" \"Southeast Gulf\" \"seg_028\" \"Southeast Gulf\" \"seg_029\" \"Southeast Gulf\" \"seg_030\" \"Southeast Gulf\" \"seg_031\" \"Southeast Gulf\" synonymous functions You can use the command population for the same functionality. We made the commands population and populations synonymous so you wouldn't have to memorize if the name was singular or plural-- it just works! This also applies to populations! and population!","title":"View population names"},{"location":"manipulate/location_and_pop/#rename-populations","text":"There are a handful of methods to alter PopData population names depending on what you find most convenient. Each of these methods start with populations!() and vary in their inputs. It's for that reason this function has an obnoxiously long docstring. For simplicity, the methods will be separated into categories. However, all the methods for populations! are unified in that they edit PopData in place, and print (rather than return) a table of the new population names and counts courtesy of populations() .","title":"Rename populations"},{"location":"manipulate/location_and_pop/#replace-by-matching","text":"","title":"Replace by matching"},{"location":"manipulate/location_and_pop/#using-a-dictionary","text":"populations! ( data :: PopData , rename :: Dict ) Rename existing population ID's of PopData using a Dict of population_name => replacement . rename populations # create a dictionary of name conversions julia > new_popnames = Dict ( \"Cape Canaveral\" => \"Atlantic\" , \"Georgia\" => \"Atlantic\" , \"South Carolina\" => \"Atlantic\" , \"Florida Keys\" => \"Gulf\" , \"Mideast Gulf\" => \"Gulf\" , \"Northeast Gulf\" => \"Gulf\" , \"Southeast Gulf\" => \"Gulf\" ); julia > populations! ( sharks , new_popnames ) Table with 2 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Atlantic\" 79 \"Gulf\" 133","title":"Using a Dictionary"},{"location":"manipulate/location_and_pop/#using-a-vector-of-names","text":"Vector of new unique population names in the order that they appear in the PopData.meta . julia > new_popnames = [ \"Atlantic\" , \"Atlantic\" , \"Atlantic\" , \"Gulf\" , \"Gulf\" , \"Gulf\" , \"Gulf\" ] julia > populations! ( sharks , new_popnames ) Table with 2 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Atlantic\" 79 \"Gulf\" 133","title":"Using a Vector of names"},{"location":"manipulate/location_and_pop/#using-a-vector-of-oldnames-and-new-names","text":"Similar to the Dict method, except instead of creating a dictionary of \"oldname\" => \"newname\", you input a Vector{String} of oldnames followed by another of newnames . Logically, the new names will replace the old names in the same order as they appear in PopData.meta (e.g. the first newname replaces the first oldname, etc.). julia > old_pop = [ \"Cape Canaveral\" , \"Florida Keys\" , \"Georgia\" , \"Mideast Gulf\" , \"Northeast Gulf\" , \"South Carolina\" , \"Southeast Gulf\" ] ; julia > new_pop = [ \"Atlantic\" , \"Gulf\" , \"Atlantic\" , \"Gulf\" , \"Gulf\" , \"Atlantic\" , \"Gulf\" ] ; julia > populations ( sharks , old_pop , new_pop ) Table with 2 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Atlantic\" 79 \"Gulf\" 133","title":"Using a Vector of oldnames and new names"},{"location":"manipulate/location_and_pop/#generate-new-population-information","text":"You may want outright overwrite all current population information. This is particularly useful when importing from VCF format when population information is not provided. This method will completely replace the population names of PopData regardless of what they currently are. Double-check your population counts If you're playing along and getting errors that the lengths don't match, then get make sure you're using the right population counts. You can get those numbers with populations(sharks) . counts = [ 21 , 65 , 30 , 28 , 20 , 28 , 20 ] and we then also create the vector of the names in the order in which they appear: popnames = [ \"Cape Canaveral\" , \"Florida Keys\" , \"Georgia\" , \"Mideast Gulf\" , \"Northeast Gulf\" , \"South Carolina\" , \"Southeast Gulf\" ] Now we can combine them with populations! to restore the population names to how they were originally:","title":"Generate new population information"},{"location":"manipulate/location_and_pop/#using-a-namedtuple","text":"replace populations julia > populations! ( sharks , ( counts = counts , names = popnames )) Table with 7 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Cape Canaveral\" 21 \"Florida Keys\" 65 \"Georgia\" 30 \"Mideast Gulf\" 28 \"Northeast Gulf\" 20 \"South Carolina\" 28 \"Southeast Gulf\" 20","title":"Using a NamedTuple"},{"location":"manipulate/location_and_pop/#using-a-vector-of-names-and-a-vector-of-counts","text":"This is just about the same as using the NamedTuple , but perhaps some users will prefer this format. julia > populations! ( sharks , popnames , counts ) Table with 7 rows , 2 columns : population count \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Cape Canaveral\" 21 \"Florida Keys\" 65 \"Georgia\" 30 \"Mideast Gulf\" 28 \"Northeast Gulf\" 20 \"South Carolina\" 28 \"Southeast Gulf\" 20","title":"Using a Vector of names and a Vector of counts"},{"location":"manipulate/manipulate/","text":"Manipulating PopData PopGen.jl includes basic commands to provide obvious methods to inspect and alter PopData . Using standard Julia conventions, only commands ending with a bang ! are mutable, meaning they alter the input data. So, commands like populations will show you population information, whereas populations! will change that information in your PopData . The mutable commands here alter the data in your PopData , but not the source data (i.e. the files used to create the PopData ). Read over Accessing parts of PopData to become familiar with the components of PopData . The \"manipulation\" commands were separated into three sections to make it less overwhelming, and using the gulfsharks data, you can explore each of the sections like a little tutorial. The sections don't follow any particular order, so feel free to jump around however you like. To follow along like a tutorial, load the gulfsharks data in if you haven't already: julia > using PopGen julia > sharks = gulfsharks () ; Viewing and Sorting Sample and Locus Exclusion/Removal Location and Population Information","title":"Getting Started"},{"location":"manipulate/manipulate/#manipulating-popdata","text":"PopGen.jl includes basic commands to provide obvious methods to inspect and alter PopData . Using standard Julia conventions, only commands ending with a bang ! are mutable, meaning they alter the input data. So, commands like populations will show you population information, whereas populations! will change that information in your PopData . The mutable commands here alter the data in your PopData , but not the source data (i.e. the files used to create the PopData ). Read over Accessing parts of PopData to become familiar with the components of PopData . The \"manipulation\" commands were separated into three sections to make it less overwhelming, and using the gulfsharks data, you can explore each of the sections like a little tutorial. The sections don't follow any particular order, so feel free to jump around however you like. To follow along like a tutorial, load the gulfsharks data in if you haven't already: julia > using PopGen julia > sharks = gulfsharks () ;","title":"Manipulating PopData"},{"location":"manipulate/manipulate/#viewing-and-sorting","text":"","title":"Viewing and Sorting"},{"location":"manipulate/manipulate/#sample-and-locus-exclusionremoval","text":"","title":"Sample and Locus Exclusion/Removal"},{"location":"manipulate/manipulate/#location-and-population-information","text":"","title":"Location and Population Information"},{"location":"manipulate/view_and_sort/","text":"The functions here help you inspect your PopData and pull information from it easily. Individuals / Samples view individuals' names samples ( data :: PopObj ) View individual/sample names in a PopData . samples samples ( sharks ) 212 - element Array { String , 1 } : \"cc_001\" \"cc_002\" \"cc_003\" \"cc_005\" \"cc_007\" \"cc_008\" \"cc_009\" \"cc_010\" \"cc_012\" \"cc_013\" \u22ee \"seg_023\" \"seg_024\" \"seg_025\" \"seg_026\" \"seg_027\" \"seg_028\" \"seg_029\" \"seg_030\" \"seg_031\" Sorting reindex ( data :: PopData , col :: Union { String , Symbol }) By default, the loci table of PopData is sorted by the name column. For performance or convenience reasons, you can sort it using any column you want. This will sort the loci table of a PopData object by column col and return new PopData object, keeping the original intact. The column names can be Strings or Symbols. Example: sorted_sharks = reindex ( sharks , : population ) Display Specific Loci and/or Samples Get loci names loci ( data :: PopData ) Returns a vector of strings of the loci names in a PopData example julia > loci ( sharks ) output 2213-element Array{String,1}: \"contig_35208\" \"contig_23109\" \"contig_4493\" \"contig_10742\" \"contig_14898\" \"contig_8483\" \"contig_8065\" \"contig_14708\" \"contig_2307\" \u22ee \"contig_24711\" \"contig_18959\" \"contig_43517\" \"contig_27356\" \"contig_475\" \"contig_19384\" \"contig_22368\" \"contig_2784\" View genotypes at a locus locus ( data :: PopData , locus :: String ) Default shows all genotypes for all individuals. Returns a Vector. all loci julia > locus ( sharks , \"contig_2784\" ) output 212-element view(::Array{Union{Missing, Tuple{Int8,Int8}},1}, [2213, 4426, 6639, 8852, 11065, 13278, 15491, 17704, 19917, 22130 \u2026 449239, 451452, 453665, 455878, 458091, 460304, 462517, 464730, 466943, 469156]) with eltype Union{Missing, Tuple{Int8,Int8}}: (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) \u22ee (1, 1) (1, 1) (1, 1) (1, 1) missing (1, 1) (1, 1) (1, 1) returning a view The locus function gives a view into the genotype section of the loci table.. The text above the output is isn't anything to be worried about-- it's indicating you are looking at a view of a column of the table and that it's not returning a new vector. View genotypes by sample (or anything) This can be done fairly easily using JuliaDBMeta macro @where single sample julia> @where sharks.loci :name == \"cc_001\" Table with 2213 rows, 4 columns: name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"contig_35208\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_23109\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_4493\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_10742\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14898\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_8483\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_8065\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14708\" (1, 1) \u22ee \"cc_001\" \"Cape Canaveral\" \"contig_43517\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_27356\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_475\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_19384\" (2, 2) \"cc_001\" \"Cape Canaveral\" \"contig_22368\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_2784\" (1, 1) multiple samples julia> @where sharks.loci :name in [\"cc_001\", \"cc_002\"] Table with 4426 rows, 4 columns: name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"contig_35208\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_23109\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_4493\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_10742\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14898\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_8483\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_8065\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14708\" (1, 1) \u22ee \"cc_002\" \"Cape Canaveral\" \"contig_43517\" (1, 1) \"cc_002\" \"Cape Canaveral\" \"contig_27356\" (1, 1) \"cc_002\" \"Cape Canaveral\" \"contig_475\" (1, 2) \"cc_002\" \"Cape Canaveral\" \"contig_19384\" (2, 2) \"cc_002\" \"Cape Canaveral\" \"contig_22368\" (1, 1) \"cc_002\" \"Cape Canaveral\" \"contig_2784\" (1, 1) It also means that you can combine different queries with \"and\" && and \"or\" || both name and locus julia > @where sharks . loci : name in [ \"cc_001\" , \"cc_002\" ] && : locus == \"contig_2784\" Table with 2 rows , 4 columns : name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"contig_2784\" ( 1 , 1 ) \"cc_002\" \"Cape Canaveral\" \"contig_2784\" ( 1 , 1 ) Missing Data missing ( data :: PopData ; mode :: String = \"sample\" ) Get missing genotype information in a PopData . Specify a mode of operation to return a DataFrame corresponding with that missing information type. mode alternative name what it does \"sample\" \"individual\" returns a count and list of missing loci per individual (default) \"pop\" \"population\" returns a count of missing genotypes per population \"locus\" \"loci\" returns a count of missing genotypes per locus \"full\" \"detailed\" returns a count of missing genotypes per locus per population sample julia> missing(sharks) Table with 212 rows, 2 columns: name missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" 124 \"cc_002\" 94 \"cc_003\" 100 \"cc_005\" 0 \"cc_007\" 2 \"cc_008\" 1 \"cc_009\" 2 \"cc_010\" 1 \u22ee \"seg_026\" 0 \"seg_027\" 2 \"seg_028\" 25 \"seg_029\" 0 \"seg_030\" 1 \"seg_031\" 1 pop julia> missing(sharks, mode = \"pop\") Table with 7 rows, 2 columns: population missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Florida Keys\" 782 \"Cape Canaveral\" 666 \"Mideast Gulf\" 379 \"Georgia\" 744 \"Northeast Gulf\" 93 \"Southeast Gulf\" 1504 \"South Carolina\" 480 locus julia> missing(sharks, mode = \"locus\") Table with 2213 rows, 2 columns: locus missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"contig_35208\" 0 \"contig_23109\" 6 \"contig_4493\" 3 \"contig_10742\" 2 \"contig_14898\" 0 \"contig_8483\" 0 \"contig_8065\" 0 \"contig_14708\" 1 \u22ee \"contig_43517\" 6 \"contig_27356\" 2 \"contig_475\" 0 \"contig_19384\" 5 \"contig_22368\" 3 \"contig_2784\" 7 full julia> missing(sharks, mode = \"full\") Table with 15491 rows, 3 columns: locus population missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"contig_35208\" \"Florida Keys\" 0 \"contig_35208\" \"Cape Canaveral\" 0 \"contig_35208\" \"Mideast Gulf\" 0 \"contig_35208\" \"Georgia\" 0 \"contig_35208\" \"Northeast Gulf\" 0 \"contig_35208\" \"Southeast Gulf\" 0 \"contig_35208\" \"South Carolina\" 0 \"contig_23109\" \"Florida Keys\" 0 \u22ee \"contig_2784\" \"Cape Canaveral\" 0 \"contig_2784\" \"Mideast Gulf\" 1 \"contig_2784\" \"Georgia\" 1 \"contig_2784\" \"Northeast Gulf\" 1 \"contig_2784\" \"Southeast Gulf\" 1 \"contig_2784\" \"South Carolina\" 0 alternative names Each mode has an extra synonymous (alternative) name just because we can and want you to have the option of more explicitly legible code. If you get the mode wrong, it will let you know with an error message and run the default \"sample\" mode anyway.","title":"Viewing and Sorting"},{"location":"manipulate/view_and_sort/#individuals-samples","text":"","title":"Individuals / Samples"},{"location":"manipulate/view_and_sort/#view-individuals-names","text":"samples ( data :: PopObj ) View individual/sample names in a PopData . samples samples ( sharks ) 212 - element Array { String , 1 } : \"cc_001\" \"cc_002\" \"cc_003\" \"cc_005\" \"cc_007\" \"cc_008\" \"cc_009\" \"cc_010\" \"cc_012\" \"cc_013\" \u22ee \"seg_023\" \"seg_024\" \"seg_025\" \"seg_026\" \"seg_027\" \"seg_028\" \"seg_029\" \"seg_030\" \"seg_031\"","title":"view individuals' names"},{"location":"manipulate/view_and_sort/#sorting","text":"reindex ( data :: PopData , col :: Union { String , Symbol }) By default, the loci table of PopData is sorted by the name column. For performance or convenience reasons, you can sort it using any column you want. This will sort the loci table of a PopData object by column col and return new PopData object, keeping the original intact. The column names can be Strings or Symbols. Example: sorted_sharks = reindex ( sharks , : population )","title":"Sorting"},{"location":"manipulate/view_and_sort/#display-specific-loci-andor-samples","text":"","title":"Display Specific Loci and/or Samples"},{"location":"manipulate/view_and_sort/#get-loci-names","text":"loci ( data :: PopData ) Returns a vector of strings of the loci names in a PopData example julia > loci ( sharks ) output 2213-element Array{String,1}: \"contig_35208\" \"contig_23109\" \"contig_4493\" \"contig_10742\" \"contig_14898\" \"contig_8483\" \"contig_8065\" \"contig_14708\" \"contig_2307\" \u22ee \"contig_24711\" \"contig_18959\" \"contig_43517\" \"contig_27356\" \"contig_475\" \"contig_19384\" \"contig_22368\" \"contig_2784\"","title":"Get loci names"},{"location":"manipulate/view_and_sort/#view-genotypes-at-a-locus","text":"locus ( data :: PopData , locus :: String ) Default shows all genotypes for all individuals. Returns a Vector. all loci julia > locus ( sharks , \"contig_2784\" ) output 212-element view(::Array{Union{Missing, Tuple{Int8,Int8}},1}, [2213, 4426, 6639, 8852, 11065, 13278, 15491, 17704, 19917, 22130 \u2026 449239, 451452, 453665, 455878, 458091, 460304, 462517, 464730, 466943, 469156]) with eltype Union{Missing, Tuple{Int8,Int8}}: (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) (1, 1) \u22ee (1, 1) (1, 1) (1, 1) (1, 1) missing (1, 1) (1, 1) (1, 1) returning a view The locus function gives a view into the genotype section of the loci table.. The text above the output is isn't anything to be worried about-- it's indicating you are looking at a view of a column of the table and that it's not returning a new vector.","title":"View genotypes at a locus"},{"location":"manipulate/view_and_sort/#view-genotypes-by-sample-or-anything","text":"This can be done fairly easily using JuliaDBMeta macro @where single sample julia> @where sharks.loci :name == \"cc_001\" Table with 2213 rows, 4 columns: name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"contig_35208\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_23109\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_4493\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_10742\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14898\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_8483\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_8065\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14708\" (1, 1) \u22ee \"cc_001\" \"Cape Canaveral\" \"contig_43517\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_27356\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_475\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_19384\" (2, 2) \"cc_001\" \"Cape Canaveral\" \"contig_22368\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_2784\" (1, 1) multiple samples julia> @where sharks.loci :name in [\"cc_001\", \"cc_002\"] Table with 4426 rows, 4 columns: name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"contig_35208\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_23109\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_4493\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_10742\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14898\" (1, 2) \"cc_001\" \"Cape Canaveral\" \"contig_8483\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_8065\" (1, 1) \"cc_001\" \"Cape Canaveral\" \"contig_14708\" (1, 1) \u22ee \"cc_002\" \"Cape Canaveral\" \"contig_43517\" (1, 1) \"cc_002\" \"Cape Canaveral\" \"contig_27356\" (1, 1) \"cc_002\" \"Cape Canaveral\" \"contig_475\" (1, 2) \"cc_002\" \"Cape Canaveral\" \"contig_19384\" (2, 2) \"cc_002\" \"Cape Canaveral\" \"contig_22368\" (1, 1) \"cc_002\" \"Cape Canaveral\" \"contig_2784\" (1, 1) It also means that you can combine different queries with \"and\" && and \"or\" || both name and locus julia > @where sharks . loci : name in [ \"cc_001\" , \"cc_002\" ] && : locus == \"contig_2784\" Table with 2 rows , 4 columns : name population locus genotype \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" \"Cape Canaveral\" \"contig_2784\" ( 1 , 1 ) \"cc_002\" \"Cape Canaveral\" \"contig_2784\" ( 1 , 1 )","title":"View genotypes by sample (or anything)"},{"location":"manipulate/view_and_sort/#missing-data","text":"missing ( data :: PopData ; mode :: String = \"sample\" ) Get missing genotype information in a PopData . Specify a mode of operation to return a DataFrame corresponding with that missing information type. mode alternative name what it does \"sample\" \"individual\" returns a count and list of missing loci per individual (default) \"pop\" \"population\" returns a count of missing genotypes per population \"locus\" \"loci\" returns a count of missing genotypes per locus \"full\" \"detailed\" returns a count of missing genotypes per locus per population sample julia> missing(sharks) Table with 212 rows, 2 columns: name missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"cc_001\" 124 \"cc_002\" 94 \"cc_003\" 100 \"cc_005\" 0 \"cc_007\" 2 \"cc_008\" 1 \"cc_009\" 2 \"cc_010\" 1 \u22ee \"seg_026\" 0 \"seg_027\" 2 \"seg_028\" 25 \"seg_029\" 0 \"seg_030\" 1 \"seg_031\" 1 pop julia> missing(sharks, mode = \"pop\") Table with 7 rows, 2 columns: population missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"Florida Keys\" 782 \"Cape Canaveral\" 666 \"Mideast Gulf\" 379 \"Georgia\" 744 \"Northeast Gulf\" 93 \"Southeast Gulf\" 1504 \"South Carolina\" 480 locus julia> missing(sharks, mode = \"locus\") Table with 2213 rows, 2 columns: locus missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"contig_35208\" 0 \"contig_23109\" 6 \"contig_4493\" 3 \"contig_10742\" 2 \"contig_14898\" 0 \"contig_8483\" 0 \"contig_8065\" 0 \"contig_14708\" 1 \u22ee \"contig_43517\" 6 \"contig_27356\" 2 \"contig_475\" 0 \"contig_19384\" 5 \"contig_22368\" 3 \"contig_2784\" 7 full julia> missing(sharks, mode = \"full\") Table with 15491 rows, 3 columns: locus population missing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \"contig_35208\" \"Florida Keys\" 0 \"contig_35208\" \"Cape Canaveral\" 0 \"contig_35208\" \"Mideast Gulf\" 0 \"contig_35208\" \"Georgia\" 0 \"contig_35208\" \"Northeast Gulf\" 0 \"contig_35208\" \"Southeast Gulf\" 0 \"contig_35208\" \"South Carolina\" 0 \"contig_23109\" \"Florida Keys\" 0 \u22ee \"contig_2784\" \"Cape Canaveral\" 0 \"contig_2784\" \"Mideast Gulf\" 1 \"contig_2784\" \"Georgia\" 1 \"contig_2784\" \"Northeast Gulf\" 1 \"contig_2784\" \"Southeast Gulf\" 1 \"contig_2784\" \"South Carolina\" 0 alternative names Each mode has an extra synonymous (alternative) name just because we can and want you to have the option of more explicitly legible code. If you get the mode wrong, it will let you know with an error message and run the default \"sample\" mode anyway.","title":"Missing Data"},{"location":"other/logo_graveyard/","text":"Hi, Pavel here. Despite all the fancy stuff in the package and in these docs, I wanna talk about our logo real quick. What exactly that logo? If you haven't guessed already, it's the beloved Punnett Square! Nothing screams genetics like everyone's first entry-level genetic diagram. And guess what this package doesn't do... Punnett Squares! The irony is deliberate, we swear . The Logo Graveyard While this is completely unrelated to anything important about population genetics or Julia, I want you all to understand the logo-development process that led us to our logo so you can feel my struggle. The process is as follows: Jason and Pavel spitball ideas Pavel procrastinates real work and opens up Inkscape to draft some ideas Pavel composes 1-3 versions of an idea and sends it to Jason if Jason != veto for i in 1:5 Jason critiques and suggests changes Pavel makes the changes end end Pavel and Jason finalize the idea! Weeks pass and Pavel isn't quite satisfied and we start at 1 again I'm happy to say that we love the Punnett Square and it's for keeps, but have a look at the scrapped ideas as a little walk down memory lane:","title":"Logo Graveyard"},{"location":"other/logo_graveyard/#what-exactly-that-logo","text":"If you haven't guessed already, it's the beloved Punnett Square! Nothing screams genetics like everyone's first entry-level genetic diagram. And guess what this package doesn't do... Punnett Squares! The irony is deliberate, we swear .","title":"What exactly that logo?"},{"location":"other/logo_graveyard/#the-logo-graveyard","text":"While this is completely unrelated to anything important about population genetics or Julia, I want you all to understand the logo-development process that led us to our logo so you can feel my struggle. The process is as follows: Jason and Pavel spitball ideas Pavel procrastinates real work and opens up Inkscape to draft some ideas Pavel composes 1-3 versions of an idea and sends it to Jason if Jason != veto for i in 1:5 Jason critiques and suggests changes Pavel makes the changes end end Pavel and Jason finalize the idea! Weeks pass and Pavel isn't quite satisfied and we start at 1 again I'm happy to say that we love the Punnett Square and it's for keeps, but have a look at the scrapped ideas as a little walk down memory lane:","title":"The Logo Graveyard"},{"location":"other/api/hidden_api/","text":"Like most Julia packages, there are a lot of functions in PopGen.jl, but only a number of them are exported , which are the ones you the user can casually use after calling using PopGen . You'll often see other Julia packages refer to these as API's, or \"Application Programming Interface\". If you want to contribute to PopGen.jl, then it will be super useful to know what API's are already available and save you the trouble of reinventing the wheel. If you would like to use any of these functions by themselves (outside the scope of development), then you will need to use the Package.function() syntax, which looks like PopGen.het_sample in practice. Genotype Value Found in Manipulate.jl get_genotype ( x :: PopObj ; sample :: String , locus :: String ) Return the genotype of a specific sample for specific locus in a PopObj . This is a barebones variant to isolate_genotypes that is ~ 1,000 - 10,000x faster depending on the size of the data. Example get_genotype ( nancycats , sample = \"N115\" , locus = \"fca8\" ) ` Allele Frequencies These are found in AlleleFreq.jl allele_freq allele_freq ( x :: Array { Union { Missing , Tuple }, 1 }) Calculate allele counts for a single locus of a PopObj . Returns a Dict of allele's and their frequencies. allele_freq ( x :: SubArray { Union { Missing , Tuple }, 1 }) Calculate allele counts for a single locus of a PopObj split by population using group() . Returns a Dict of allele's and their frequencies. Genotype Frequencies These are found in AlleleFreq.jl geno_freq geno_freq ( x :: Array { Union { Missing , Tuple }, 1 }) Calculate genotype frequencies of all loci in a PopObj . Returns a Dict of genotypes and their frequencies. geno_freq ( x :: SubArray { Union { Missing , Tuple }, 1 }) Calculate genotype frequencies of all loci in PopObj split by population using group() . Returns a Dict of genotypes and their frequencies. Observed Heterozygosity These are found in HardyWeinberg.jl het_observed het_observed ( x :: PopObj ) Calculate the observed heterozygosity for each locus in a PopObj . Returns an array of heterozygosity values. het_population_obs het_population_obs ( x :: PopObj ) Return a Dict of the observed heterozygosity per population for each locus in a PopObj het_sample het_sample ( x :: PopObj ) Calculate the observed heterozygosity for each individual in a PopObj . Returns an array of heterozygosity values. Expected Heterozygosity These are found in HardyWeinberg.jl het_expected het_expected ( x :: PopObj ) Calculate the expected heterozygosity for each locus in a PopObj . Returns an array of heterozygosity values. het_population_exp het_population_exp ( x :: PopObj ) Return a Dict of the expected heterozygosity per population for each locus in a PopObj . Chi Squared Found in HardyWeinberg.jl locus_chi_sq locus_chi_sq ( locus :: Array { Union { Missing , Tuple }, 1 }) Calculate the chi square statistic and p-value for a locus. Returns a tuple with chi-square statistic, degrees of freedom, and p-value. Multiple Testing Found in HardyWeinberg.jl multitest_missing multitest_missing ( pvals :: Array { Float64 , 1 }, correction :: String ) Modification to MultipleTesting.adjust to include missing values. Missing values are first removed from the array, the appropriate correction made, then missing values are re-added to the array at their original positions. See MultipleTesting.jl docs for full more detailed information. Example: multitest_missing([0.1, 0.01, 0.005, 0.3], \"bh\") correction methods (case insensitive): \"bonferroni\" : Bonferroni adjustment \"holm\" : Holm adjustment \"hochberg\" : Hochberg adjustment \"bh\" or \"b-h\" : Benjamini-Hochberg adjustment \"by\" or \"b-y\" : Benjamini-Yekutieli adjustment \"bl\" or \"b-l\" : Benjamini-Liu adjustment \"hommel\" : Hommel adjustment \"sidak\" : \u0160id\u00e1k adjustment \"forward stop\" or \"fs\" : Forward-Stop adjustment \"bc\" or \"b-c\" : Barber-Cande\u0300s adjustment","title":"Under the hood functions"},{"location":"other/api/hidden_api/#genotype-value","text":"Found in Manipulate.jl get_genotype ( x :: PopObj ; sample :: String , locus :: String ) Return the genotype of a specific sample for specific locus in a PopObj . This is a barebones variant to isolate_genotypes that is ~ 1,000 - 10,000x faster depending on the size of the data. Example get_genotype ( nancycats , sample = \"N115\" , locus = \"fca8\" ) `","title":"Genotype Value"},{"location":"other/api/hidden_api/#allele-frequencies","text":"These are found in AlleleFreq.jl","title":"Allele Frequencies"},{"location":"other/api/hidden_api/#allele_freq","text":"allele_freq ( x :: Array { Union { Missing , Tuple }, 1 }) Calculate allele counts for a single locus of a PopObj . Returns a Dict of allele's and their frequencies. allele_freq ( x :: SubArray { Union { Missing , Tuple }, 1 }) Calculate allele counts for a single locus of a PopObj split by population using group() . Returns a Dict of allele's and their frequencies.","title":"allele_freq"},{"location":"other/api/hidden_api/#genotype-frequencies","text":"These are found in AlleleFreq.jl","title":"Genotype Frequencies"},{"location":"other/api/hidden_api/#geno_freq","text":"geno_freq ( x :: Array { Union { Missing , Tuple }, 1 }) Calculate genotype frequencies of all loci in a PopObj . Returns a Dict of genotypes and their frequencies. geno_freq ( x :: SubArray { Union { Missing , Tuple }, 1 }) Calculate genotype frequencies of all loci in PopObj split by population using group() . Returns a Dict of genotypes and their frequencies.","title":"geno_freq"},{"location":"other/api/hidden_api/#observed-heterozygosity","text":"These are found in HardyWeinberg.jl","title":"Observed Heterozygosity"},{"location":"other/api/hidden_api/#het_observed","text":"het_observed ( x :: PopObj ) Calculate the observed heterozygosity for each locus in a PopObj . Returns an array of heterozygosity values.","title":"het_observed"},{"location":"other/api/hidden_api/#het_population_obs","text":"het_population_obs ( x :: PopObj ) Return a Dict of the observed heterozygosity per population for each locus in a PopObj","title":"het_population_obs"},{"location":"other/api/hidden_api/#het_sample","text":"het_sample ( x :: PopObj ) Calculate the observed heterozygosity for each individual in a PopObj . Returns an array of heterozygosity values.","title":"het_sample"},{"location":"other/api/hidden_api/#expected-heterozygosity","text":"These are found in HardyWeinberg.jl","title":"Expected Heterozygosity"},{"location":"other/api/hidden_api/#het_expected","text":"het_expected ( x :: PopObj ) Calculate the expected heterozygosity for each locus in a PopObj . Returns an array of heterozygosity values.","title":"het_expected"},{"location":"other/api/hidden_api/#het_population_exp","text":"het_population_exp ( x :: PopObj ) Return a Dict of the expected heterozygosity per population for each locus in a PopObj .","title":"het_population_exp"},{"location":"other/api/hidden_api/#chi-squared","text":"Found in HardyWeinberg.jl","title":"Chi Squared"},{"location":"other/api/hidden_api/#locus_chi_sq","text":"locus_chi_sq ( locus :: Array { Union { Missing , Tuple }, 1 }) Calculate the chi square statistic and p-value for a locus. Returns a tuple with chi-square statistic, degrees of freedom, and p-value.","title":"locus_chi_sq"},{"location":"other/api/hidden_api/#multiple-testing","text":"Found in HardyWeinberg.jl","title":"Multiple Testing"},{"location":"other/api/hidden_api/#multitest_missing","text":"multitest_missing ( pvals :: Array { Float64 , 1 }, correction :: String ) Modification to MultipleTesting.adjust to include missing values. Missing values are first removed from the array, the appropriate correction made, then missing values are re-added to the array at their original positions. See MultipleTesting.jl docs for full more detailed information. Example: multitest_missing([0.1, 0.01, 0.005, 0.3], \"bh\") correction methods (case insensitive): \"bonferroni\" : Bonferroni adjustment \"holm\" : Holm adjustment \"hochberg\" : Hochberg adjustment \"bh\" or \"b-h\" : Benjamini-Hochberg adjustment \"by\" or \"b-y\" : Benjamini-Yekutieli adjustment \"bl\" or \"b-l\" : Benjamini-Liu adjustment \"hommel\" : Hommel adjustment \"sidak\" : \u0160id\u00e1k adjustment \"forward stop\" or \"fs\" : Forward-Stop adjustment \"bc\" or \"b-c\" : Barber-Cande\u0300s adjustment","title":"multitest_missing"},{"location":"other/misc/genepopIBD/","text":"Modifying a genepop file for Genepop Isolation by Distance calculations Before we get into the nitty-gritty, allow me a moment to gripe: So, the (beloved) genepop file format specification exists to be used by the software (or R package) Genepop . That's all well and good (though honestly XML or JSON is probably a better format for SNP data with metadata), but if you want to perform Isolation by Distance calculations using Genepop, they ask that you reformat your genepop file for a completely wacky format, where you preface each sample name with x and y coordinates. Example: Normal sample row for genepop file: thing_001, 001001 002001 001002 002002 With location data: -43.111 12.221 thing_001, 001001 002001 001002 002002 The name thing_001 is optional under this format (to my understanding), but it doesn't hurt to have it. But If you want to perform an individual-based model, you must also separate each sample as its own \"population\" using the word POP . POP -43.111 12.221 thing_001, 001001 002001 001002 002002 POP -43.121 21.261 thing_002, 002001 002001 001002 002001 POP -43.411 11.211 thing_002, 001002 001001 001002 001002 POP -43.177 13.271 thing_002, 001001 002001 002001 002002 As you can imagine, the amount of work to do this correctly quickly adds up if you are editing the file by hand. Modern SNP datasets have hundreds of individuals, and that reformatting is an absurd amount of work to do, and every time you manually edit something, it introduces the possibility of human error . Hopefully there will be a time when PopGen.jl will incorporate Isolation-by-Distance calculations (looking for volunteers ) and you won't need to format your PopObj whatsoever, but until then we encourage you to continue using Genepop (available here ) or whatever your preferred method is. In the meantime, using the most basic parts of PopGen.jl and Julia, we can reformat a genepop file really quickly and relatively painlessly because most of the work is already done for you in the code snippets below. If you set up those first three variables gfile , loc_data , and outfile correctly and your coordinate data is in a two-column X/Y format, the rest of this code should work to generate your modified Isolation-by-Distance ready genepop file. Make sure your outfile doesn't exist yet (or is empty) or else the output will append to whatever is in that file. Conversion for by-individual Along with prefixing the sample names with the location data, this snippet will force a POP to separate individuals are shown above. using PopGen , CSV gfile = \"PATH/TO/YOUR/GENEPOP/FILE\" loc_data = \"PATH/TO/YOUR/LAT-LONG/FILE\" outfile = \"PATH/AND/NAME/OF/INTENDED/OUTPUT/FILE\" #load in your genepop as a PopObj gpop_file = genepop ( gfile ) # load in your location data as a table loc_df = DataFrame ( CSV . File ( loc_data )) oldnames = sample_names ( gpop_file ) # this is the only reason we need PopGen.jl here newnames = Vector { String }() # merge the x,y coordinates with the original sample name # make sure your longitude (x) and latitude (y) are in the correct order # this loop generates the format \"x y sample_name\" as a string for ( i , j , k ) in zip ( loc_df [ ! , 1 ], loc_df [ ! , 2 ], oldnames ) push! ( newnames , string ( \" $i \\t $j \\t $k \" )) end # open the original genepop file and parse each line as a string popgenfile = open ( readlines , gfile ) # Create the output file (if it doesn't already exist) and parse the original genepop file to replace the sample names with the new names we created above and print to outfile open ( outfile , \"w\" ) do f name_num = 1 len = length ( popgenfile ) for line in 1 : len if occursin ( \"POP\" , popgenfile [ line ]) == true # A little condition to add the first POP to the file if name_num == 1 println ( f , \"POP\" ) end # skip POP lines continue elseif occursin ( \",\" , popgenfile [ line ]) != true # output locus names println ( f , popgenfile [ line ]) continue else eachline_mod = replace ( popgenfile [ line ], oldnames [ name_num ] => newnames [ name_num ]) if line != len println ( f , eachline_mod , \" \\n POP\" ) name_num += 1 else print ( f , \" $eachline_mod \" ) end end end end Conversion for by-population This snippet will prefix the location information to each sample name, but preserve the original POP tags. using PopGen , CSV gfile = \"PATH/TO/YOUR/GENEPOP/FILE\" loc_data = \"PATH/TO/YOUR/LAT-LONG/FILE\" outfile = \"PATH/AND/NAME/OF/INTENDED/OUTPUT/FILE\" #load in your genepop as a PopObj gpop_file = genepop ( gfile ) # load in your location data as a table loc_df = DataFrame ( CSV . File ( loc_data )) oldnames = sample_names ( gpop_file ) # this is the only reason we need PopGen.jl here newnames = Vector { String }() # merge the x,y coordinates with the original sample name # make sure your longitude (x) and latitude (y) are in the correct order # this loop generates the format \"x y sample_name\" as a string for ( i , j , k ) in zip ( loc_df [ ! , 1 ], loc_df [ ! , 2 ], oldnames ) push! ( newnames , string ( \" $i \\t $j \\t $k \" )) end # open the original genepop file and parse each line as a string popgenfile = open ( readlines , gfile ) # Create the output file (if it doesn't already exist) and parse the original genepop file to replace the sample names with the new names we created above and print to outfile open ( outfile , \"w\" ) do f name_num = 1 len = length ( popgenfile ) for line in 1 : len if occursin ( \"POP\" , popgenfile [ line ]) == true println ( f , \"POP\" ) continue elseif occursin ( \",\" , popgenfile [ line ]) != true # output locus names println ( f , popgenfile [ line ]) continue else eachline_mod = replace ( popgenfile [ line ], oldnames [ name_num ] => newnames [ name_num ]) println ( f , eachline_mod ) name_num += 1 end end end","title":"Genepop IBD Conversion"},{"location":"other/misc/genepopIBD/#modifying-a-genepop-file-for-genepop-isolation-by-distance-calculations","text":"Before we get into the nitty-gritty, allow me a moment to gripe: So, the (beloved) genepop file format specification exists to be used by the software (or R package) Genepop . That's all well and good (though honestly XML or JSON is probably a better format for SNP data with metadata), but if you want to perform Isolation by Distance calculations using Genepop, they ask that you reformat your genepop file for a completely wacky format, where you preface each sample name with x and y coordinates. Example: Normal sample row for genepop file: thing_001, 001001 002001 001002 002002 With location data: -43.111 12.221 thing_001, 001001 002001 001002 002002 The name thing_001 is optional under this format (to my understanding), but it doesn't hurt to have it. But If you want to perform an individual-based model, you must also separate each sample as its own \"population\" using the word POP . POP -43.111 12.221 thing_001, 001001 002001 001002 002002 POP -43.121 21.261 thing_002, 002001 002001 001002 002001 POP -43.411 11.211 thing_002, 001002 001001 001002 001002 POP -43.177 13.271 thing_002, 001001 002001 002001 002002 As you can imagine, the amount of work to do this correctly quickly adds up if you are editing the file by hand. Modern SNP datasets have hundreds of individuals, and that reformatting is an absurd amount of work to do, and every time you manually edit something, it introduces the possibility of human error . Hopefully there will be a time when PopGen.jl will incorporate Isolation-by-Distance calculations (looking for volunteers ) and you won't need to format your PopObj whatsoever, but until then we encourage you to continue using Genepop (available here ) or whatever your preferred method is. In the meantime, using the most basic parts of PopGen.jl and Julia, we can reformat a genepop file really quickly and relatively painlessly because most of the work is already done for you in the code snippets below. If you set up those first three variables gfile , loc_data , and outfile correctly and your coordinate data is in a two-column X/Y format, the rest of this code should work to generate your modified Isolation-by-Distance ready genepop file. Make sure your outfile doesn't exist yet (or is empty) or else the output will append to whatever is in that file.","title":"Modifying a genepop file for Genepop Isolation by Distance calculations"},{"location":"other/misc/genepopIBD/#conversion-for-by-individual","text":"Along with prefixing the sample names with the location data, this snippet will force a POP to separate individuals are shown above. using PopGen , CSV gfile = \"PATH/TO/YOUR/GENEPOP/FILE\" loc_data = \"PATH/TO/YOUR/LAT-LONG/FILE\" outfile = \"PATH/AND/NAME/OF/INTENDED/OUTPUT/FILE\" #load in your genepop as a PopObj gpop_file = genepop ( gfile ) # load in your location data as a table loc_df = DataFrame ( CSV . File ( loc_data )) oldnames = sample_names ( gpop_file ) # this is the only reason we need PopGen.jl here newnames = Vector { String }() # merge the x,y coordinates with the original sample name # make sure your longitude (x) and latitude (y) are in the correct order # this loop generates the format \"x y sample_name\" as a string for ( i , j , k ) in zip ( loc_df [ ! , 1 ], loc_df [ ! , 2 ], oldnames ) push! ( newnames , string ( \" $i \\t $j \\t $k \" )) end # open the original genepop file and parse each line as a string popgenfile = open ( readlines , gfile ) # Create the output file (if it doesn't already exist) and parse the original genepop file to replace the sample names with the new names we created above and print to outfile open ( outfile , \"w\" ) do f name_num = 1 len = length ( popgenfile ) for line in 1 : len if occursin ( \"POP\" , popgenfile [ line ]) == true # A little condition to add the first POP to the file if name_num == 1 println ( f , \"POP\" ) end # skip POP lines continue elseif occursin ( \",\" , popgenfile [ line ]) != true # output locus names println ( f , popgenfile [ line ]) continue else eachline_mod = replace ( popgenfile [ line ], oldnames [ name_num ] => newnames [ name_num ]) if line != len println ( f , eachline_mod , \" \\n POP\" ) name_num += 1 else print ( f , \" $eachline_mod \" ) end end end end","title":"Conversion for by-individual"},{"location":"other/misc/genepopIBD/#conversion-for-by-population","text":"This snippet will prefix the location information to each sample name, but preserve the original POP tags. using PopGen , CSV gfile = \"PATH/TO/YOUR/GENEPOP/FILE\" loc_data = \"PATH/TO/YOUR/LAT-LONG/FILE\" outfile = \"PATH/AND/NAME/OF/INTENDED/OUTPUT/FILE\" #load in your genepop as a PopObj gpop_file = genepop ( gfile ) # load in your location data as a table loc_df = DataFrame ( CSV . File ( loc_data )) oldnames = sample_names ( gpop_file ) # this is the only reason we need PopGen.jl here newnames = Vector { String }() # merge the x,y coordinates with the original sample name # make sure your longitude (x) and latitude (y) are in the correct order # this loop generates the format \"x y sample_name\" as a string for ( i , j , k ) in zip ( loc_df [ ! , 1 ], loc_df [ ! , 2 ], oldnames ) push! ( newnames , string ( \" $i \\t $j \\t $k \" )) end # open the original genepop file and parse each line as a string popgenfile = open ( readlines , gfile ) # Create the output file (if it doesn't already exist) and parse the original genepop file to replace the sample names with the new names we created above and print to outfile open ( outfile , \"w\" ) do f name_num = 1 len = length ( popgenfile ) for line in 1 : len if occursin ( \"POP\" , popgenfile [ line ]) == true println ( f , \"POP\" ) continue elseif occursin ( \",\" , popgenfile [ line ]) != true # output locus names println ( f , popgenfile [ line ]) continue else eachline_mod = replace ( popgenfile [ line ], oldnames [ name_num ] => newnames [ name_num ]) println ( f , eachline_mod ) name_num += 1 end end end","title":"Conversion for by-population"}]}